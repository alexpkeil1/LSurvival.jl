var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = LSurvival=","category":"page"},{"location":"#[LSurvival](https://github.com/alexpkeil1/LSurvival.jl)","page":"Home","title":"LSurvival","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Survival analysis functions in Julia for time-to-event outcomes that can include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Loss-to-follow-up/right censoring\nLate entry/left truncation (not available in the Survival.jl package)\n\"Person-period\" data structures (not available in the Survival.jl package)\nObservation weights (not available in the Survival.jl package)\nCompeting risks (not available in the Survival.jl package)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Capabilities include estimators for","category":"page"},{"location":"","page":"Home","title":"Home","text":"Kaplan-Meier non-parametric conditional risk functions\nAalen-Johansen non-parametric cause-specific unconditional risk functions\nCox proportional hazards model (Efron's or Breslow's methods for ties)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Convenience functions enable:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Non-parametric bootstrapping, cluster-bootstrapping\nEstimating baseline hazards from a Cox Model\nEstimating cause-specific risk from an exhaustive set of Cox models for competing risk outcomes\nSimple simulation of competing and non-competing survival events\nCluster robust variance estimation (without bootstrapping)\nMartingale, score, Schoenfeld, and dfbeta residuals\nCluster robust variance estimation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Plans to include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Parametric survival models\nStratification in Cox models","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package has been tuned to follow the \"survival\" package from R in terms of specific estimators/results.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Report issues here","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(url = \"https://github.com/alexpkeil1/LSurvival.jl\")","category":"page"},{"location":"#Quick-examples","page":"Home","title":"Quick examples","text":"","category":"section"},{"location":"#Single-event-type:-Cox-model-and-Kaplan-Meier-curve","page":"Home","title":"Single event type: Cox model and Kaplan-Meier curve","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Random, LSurvival, Distributions, LinearAlgebra\n\n# generate some data under a discrete hazards model\nexpit(mu) = inv(1.0 + exp(-mu))\n\nfunction dgm(rng, n, maxT; regimefun = int_0)\n    V = rand(rng, n)\n    LAY = Array{Float64,2}(undef, n * maxT, 4)\n    keep = ones(Bool, n * maxT)\n    id = sort(reduce(vcat, fill(collect(1:n), maxT)))\n    time = (reduce(vcat, fill(collect(1:maxT), n)))\n    for i = 1:n\n        v = V[i]\n        l = 0\n        a = 0\n        lkeep = true\n        for t = 1:maxT\n            currIDX = (i - 1) * maxT + t\n            l = expit(-3 + 2 * v + 0 * l + 0 * a) > rand(rng) ? 1 : 0\n            a = 0.1 > rand(rng) ? 1 : 0\n            y = expit(-3 + 2 * v + 0 * l + 2 * a) > rand(rng) ? 1 : 0\n            LAY[currIDX, :] .= [v, l, a, y]\n            keep[currIDX] = lkeep\n            lkeep = (!lkeep || (y == 1)) ? false : true\n        end\n    end\n    id[findall(keep)], time[findall(keep)] .- 1, time[findall(keep)], LAY[findall(keep), :]\nend\n\nid, int, outt, data = dgm(MersenneTwister(), 1000, 10; regimefun = int_0)\ndata[:, 1] = round.(data[:, 1], digits = 3)\nd, X = data[:, 4], data[:, 1:3]\nwt = rand(length(d)) # random weights just to demonstrate usage\n\n# Cox model\n# Breslow's partial likelihood\nm = fit(PHModel, X, int, outt, d, ties = \"breslow\", wts = wt)\n\n# Efron's partial likelihood\nm2 = fit(PHModel, X, int, outt, d, ties = \"efron\", wts = wt)\n\n#equivalent way to specify \n# using `coxph` function\nm2b = coxph(X, int, outt, d, ties = \"efron\", wts = wt)\n\n# using `coxph` function with `Tables.jl` and `StatsAPI.@formula` interface (similar to GLM.jl)\ntab = ( in = int, out = out, d=d, x=X[:,1], z1=X[:,2], z2=X[:,3]) # can also be a DataFrame from DataFrames.jl\nm2b = coxph(@formula(Surv(in, out, d)~x+z1+z2), ties = \"efron\", wts = wt)\n\n# can also be done if there is no late entry\nm2b = coxph(@formula(Surv(out, d)~x+z1+z2), ties = \"efron\", wts = wt)\n# can also be done if there is no late entry and no right censoring (i.e. all times are failure times)\nm2b = coxph(@formula(Surv(out)~x+z1+z2), ties = \"efron\", wts = wt)\n\n\n\n# Kaplan-Meier estimator of the cumulative risk/survival\nres = kaplan_meier(int, outt, d)","category":"page"},{"location":"#Competing-event-analysis:-Aalen-Johansen-and-Cox-model-based-estimators-of-the-cumulative-risk/survival","page":"Home","title":"Competing event analysis: Aalen-Johansen and Cox-model-based estimators of the cumulative risk/survival","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Random, LSurvival, Distributions, LinearAlgebra\n\n# simulate some data\nfunction dgm_comprisk(; n = 100, rng = MersenneTwister())\n    z = rand(rng, n) .* 5\n    x = rand(rng, n) .* 5\n    dt1 = Weibull.(fill(0.75, n), inv.(exp.(-x .- z)))\n    dt2 = Weibull.(fill(0.75, n), inv.(exp.(-x .- z)))\n    t01 = rand.(rng, dt1)\n    t02 = rand.(rng, dt2)\n    t0 = min.(t01, t02)\n    t = Array{Float64,1}(undef, n)\n    for i = 1:n\n        t[i] = t0[i] > 1.0 ? 1.0 : t0[i]\n    end\n    d = (t .== t0)\n    event = (t .== t01) .+ 2.0 .* (t .== t02)\n    wtu = rand(rng, n) .* 5.0\n    wt = wtu ./ mean(wtu)\n    reshape(round.(z, digits = 4), (n, 1)),\n    reshape(round.(x, digits = 4), (n, 1)),\n    round.(t, digits = 4),\n    d,\n    event,\n    round.(wt, digits = 4)\nend\n\nz, x, t, d, event, wt = dgm_comprisk(; n = 100, rng = MersenneTwister(12))\nX = hcat(x,z)\nenter = t .* rand(length(d))*0.02 # create some fake entry times\n\n# Aalen-Johansen estimator: marginal cause-specific risks\nres_aj = aalen_johansen(enter, t, event; wts = wt);\nres_aj\n\n# Cox-model estimator: cause-specific risks at given levels of covariates\nfit1 = fit(PHModel, X, enter, t, (event .== 1), ties = \"efron\",  wts = wt)\n#n2idx = findall(event .!= 1)\nn2idx = findall(event .> -1)\nfit2 = fit(PHModel, X[n2idx,:], enter[n2idx], t[n2idx], (event[n2idx] .== 2), ties = \"breslow\",  wts = wt[n2idx])\n\n# risk at referent levels of `x` and `z` (can be very extreme if referent levels are unlikely/unobservable)\nres_cph_ref = risk_from_coxphmodels([fit1,fit2])\n\n# risk at average levels of `x` and `z`\nmnx = sum(x)/length(x)\nmnz = sum(z)/length(z)\nres_cph = risk_from_coxphmodels([fit1,fit2], coef_vectors=[coef(ft1), coef(ft2)], pred_profile=mean(X, dims=1))\n# compare to Aalen-Johansen fit\nres_aj\n\n\n# this approach operates on left censored outcomes (which operate in the background in model fitting)\nLSurvResp(enter, t, d, origintime=0)\nLSurvCompResp(enter, t, event) # automatically infers origin\n\n\n# can use the ID type to refer to units with multiple observations\nid, int, outt, data = dgm(MersenneTwister(), 1000, 10; regimefun = int_0)\nLSurvResp(int, outt, data[:,4], ID.(id))","category":"page"},{"location":"#Index-of-functions","page":"Home","title":"Index of functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Function-help","page":"Home","title":"Function help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [LSurvival]","category":"page"},{"location":"#LSurvival.AbstractLSurvParms","page":"Home","title":"LSurvival.AbstractLSurvParms","text":"AbstractLsurvParms\n\nAbstract type representing a model predictors and coefficient parameters\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractLSurvResp","page":"Home","title":"LSurvival.AbstractLSurvResp","text":"AbstractLsurvResp\n\nAbstract type representing a model response vector\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractNPSurv","page":"Home","title":"LSurvival.AbstractNPSurv","text":"Abstract type for non-parametric survival models, including Kaplan-Meier, Aalen Johansen, and Cox-model based estimates of survival using an Aalen-Johansen-like estimator\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractPH","page":"Home","title":"LSurvival.AbstractPH","text":"Abstract type for proportional hazards models\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.ID","page":"Home","title":"LSurvival.ID","text":"Type for identifying individuals in survival outcomes.\n\nUsed for the id argument in \n\nOutcome types: LSurvResp, LSurvCompResp \nModel types: PHModel, KMRisk, AJRisk\n\nAccepts any Number or String. There is no significance to having this particular struct, but it enables easier use of multiple dispatch.\n\n [ID(i) for i in 1:10]\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.LSurvCompResp","page":"Home","title":"LSurvival.LSurvCompResp","text":"Outcome type for competing risk survival outcomes subject to left truncation and right censoring (not generally needed for users)\n\nParameters\n\nenter Time at observation start\nexit Time at observation end\ny event occurrence in observation\nwts observation weights\neventtimes unique event times\norigin origin on the time scale\nid person level identifier (must be wrapped in ID() function)\neventtypes vector of unique event types\neventmatrix matrix of indicators on the observation level\n\nSignatures:\n\n struct LSurvCompResp{\n E<:AbstractVector,\n X<:AbstractVector,\n Y<:AbstractVector,\n W<:AbstractVector,\n T<:Real,\n I<:AbstractLSurvID,\n V<:AbstractVector,\n M<:AbstractMatrix,\n } <: AbstractLSurvResp\n enter::E\n exit::X\n y::Y\n wts::W\n eventtimes::X\n origin::T\n id::Vector{I}\n eventtypes::V\n eventmatrix::M\n end\n\n LSurvCompResp(\n enter::E,\n exit::X,\n y::Y,\n wts::W,\n id::Vector{I}\n )\n\n LSurvCompResp(\n enter::E,\n exit::X,\n y::Y,\n id::Vector{I}\n )\n\n LSurvCompResp(\n enter::E,\n exit::X,\n y::Y,\n wts::W,\n )\n\n LSurvCompResp(\n enter::E,\n exit::X,\n y::Y,\n )\n\n LSurvCompResp(\n  exit::X,\n  y::Y,\n) where {X<:Vector,Y<:Union{Vector{<:Real},BitVector}}\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.LSurvResp","page":"Home","title":"LSurvival.LSurvResp","text":"Outcome type for survival outcome subject to left truncation and right censoring. \n\nWill not generally be needed by users\n\nParameters\n\nenter: Time at observation start\nexit: Time at observation end\ny: event occurrence in observation\nwts: observation weights\neventtimes: unique event times\norigin: origin on the time scale\nid: person level identifier (must be wrapped in ID() function)\n\n struct LSurvResp{\n E<:AbstractVector,\n X<:AbstractVector,\n Y<:AbstractVector,\n W<:AbstractVector,\n T<:Real,\n I<:AbstractLSurvID,\n } <: AbstractLSurvResp\n enter::E\n exit::X\n y::Y\n wts::W\n eventtimes::E\n origin::T\n id::Vector{I}\n end\n\n\n LSurvResp(\n    enter::E,\n    exit::X,\n    y::Y,\n    wts::W,\n    id::Vector{I},\n) where {\n    E<:Vector,\n    X<:Vector,\n    Y<:Union{Vector{<:Real},BitVector},\n    W<:Vector,\n    I<:AbstractLSurvID,\n}\n\n LSurvResp(\n enter::E,\n exit::X,\n y::Y,\n id::Vector{I},\n ) \n\n\n LSurvResp(\n  y::Vector{Y},\n  wts::W,\n  id::Vector{I},\n) where {Y<:AbstractSurvTime,W<:Vector,I<:AbstractLSurvID}\n\n LSurvResp(\n  enter::E,\n  exit::X,\n  y::Y,\n) where {E<:Vector,X<:Vector,Y<:Union{Vector{<:Real},BitVector}}\n\n LSurvResp(exit::X, y::Y) where {X<:Vector,Y<:Vector}\n\nExamples\n\n# no late entry\nLSurvResp([.5, .6], [1,0])\n\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.PHModel","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression (not generally needed for users)\n\nParameters\n\nR Survival response\nP        # parameters\nties String: \"efron\" or \"breslow\"\nfit Bool: logical for whether the model has been fitted\nbh AbstractMatrix: baseline hazard estimates\n\nSignatures\n\n mutable struct PHModel{G<:LSurvResp,L<:AbstractLSurvParms} <: AbstractPH\n R::G        # Survival response\n P::L        # parameters\n ties::String #\"efron\" or\"breslow\"\n fit::Bool\n bh::AbstractMatrix\n end\n\n PHModel(\n R::G,\n P::L,\n ties::String,\n fit::Bool,\n ) where {G<:LSurvResp,L<:AbstractLSurvParms}\n PHModel(R::G, P::L, ties::String) where {G<:LSurvResp,L<:AbstractLSurvParms}\n PHModel(R::G, P::L) where {G<:LSurvResp,L<:AbstractLSurvParms}\n\nMethods: fit, coef, confint, std_err, show\n\nExample\n\n using LSurvival\n using Random\n import LSurvival: _stepcox!, dgm_comprisk\n\n z,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\n enter = zeros(length(t));\n X = hcat(x,z);\n R = LSurvResp(enter, t, Int.(d), wt)\n P = PHParms(X)\n mf = PHModel(R,P)\n  LSurvival._fit!(mf)\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L, String}} where {G<:LSurvResp, L<:AbstractLSurvParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression (not generally needed for users)\n\nParameters\n\nR Survival response\nP        # parameters\nties String: \"efron\" or \"breslow\"\nfit Bool: logical for whether the model has been fitted\nbh AbstractMatrix: baseline hazard estimates\n\nSignatures\n\n mutable struct PHModel{G<:LSurvResp,L<:AbstractLSurvParms} <: AbstractPH\n R::G        # Survival response\n P::L        # parameters\n ties::String #\"efron\" or\"breslow\"\n fit::Bool\n bh::AbstractMatrix\n end\n\n PHModel(\n R::G,\n P::L,\n ties::String,\n fit::Bool,\n ) where {G<:LSurvResp,L<:AbstractLSurvParms}\n PHModel(R::G, P::L, ties::String) where {G<:LSurvResp,L<:AbstractLSurvParms}\n PHModel(R::G, P::L) where {G<:LSurvResp,L<:AbstractLSurvParms}\n\nMethods: fit, coef, confint, std_err, show\n\nExample\n\n using LSurvival\n using Random\n import LSurvival: _stepcox!, dgm_comprisk\n\n z,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\n enter = zeros(length(t));\n X = hcat(x,z);\n R = LSurvResp(enter, t, Int.(d), wt)\n P = PHParms(X)\n mf = PHModel(R,P)\n  LSurvival._fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L, Union{Nothing, FormulaTerm}, String, Bool, Matrix{Float64}}} where {G<:LSurvResp, L<:AbstractLSurvParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression (not generally needed for users)\n\nParameters\n\nR Survival response\nP        # parameters\nties String: \"efron\" or \"breslow\"\nfit Bool: logical for whether the model has been fitted\nbh AbstractMatrix: baseline hazard estimates\n\nSignatures\n\n mutable struct PHModel{G<:LSurvResp,L<:AbstractLSurvParms} <: AbstractPH\n R::G        # Survival response\n P::L        # parameters\n ties::String #\"efron\" or\"breslow\"\n fit::Bool\n bh::AbstractMatrix\n end\n\n PHModel(\n R::G,\n P::L,\n ties::String,\n fit::Bool,\n ) where {G<:LSurvResp,L<:AbstractLSurvParms}\n PHModel(R::G, P::L, ties::String) where {G<:LSurvResp,L<:AbstractLSurvParms}\n PHModel(R::G, P::L) where {G<:LSurvResp,L<:AbstractLSurvParms}\n\nMethods: fit, coef, confint, std_err, show\n\nExample\n\n using LSurvival\n using Random\n import LSurvival: _stepcox!, dgm_comprisk\n\n z,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\n enter = zeros(length(t));\n X = hcat(x,z);\n R = LSurvResp(enter, t, Int.(d), wt)\n P = PHParms(X)\n mf = PHModel(R,P)\n  LSurvival._fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L, Union{Nothing, FormulaTerm}, String, Bool}} where {G<:LSurvResp, L<:AbstractLSurvParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression (not generally needed for users)\n\nParameters\n\nR Survival response\nP        # parameters\nties String: \"efron\" or \"breslow\"\nfit Bool: logical for whether the model has been fitted\nbh AbstractMatrix: baseline hazard estimates\n\nSignatures\n\n mutable struct PHModel{G<:LSurvResp,L<:AbstractLSurvParms} <: AbstractPH\n R::G        # Survival response\n P::L        # parameters\n ties::String #\"efron\" or\"breslow\"\n fit::Bool\n bh::AbstractMatrix\n end\n\n PHModel(\n R::G,\n P::L,\n ties::String,\n fit::Bool,\n ) where {G<:LSurvResp,L<:AbstractLSurvParms}\n PHModel(R::G, P::L, ties::String) where {G<:LSurvResp,L<:AbstractLSurvParms}\n PHModel(R::G, P::L) where {G<:LSurvResp,L<:AbstractLSurvParms}\n\nMethods: fit, coef, confint, std_err, show\n\nExample\n\n using LSurvival\n using Random\n import LSurvival: _stepcox!, dgm_comprisk\n\n z,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\n enter = zeros(length(t));\n X = hcat(x,z);\n R = LSurvResp(enter, t, Int.(d), wt)\n P = PHParms(X)\n mf = PHModel(R,P)\n  LSurvival._fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L, Union{Nothing, FormulaTerm}, String}} where {G<:LSurvResp, L<:AbstractLSurvParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression (not generally needed for users)\n\nParameters\n\nR Survival response\nP        # parameters\nties String: \"efron\" or \"breslow\"\nfit Bool: logical for whether the model has been fitted\nbh AbstractMatrix: baseline hazard estimates\n\nSignatures\n\n mutable struct PHModel{G<:LSurvResp,L<:AbstractLSurvParms} <: AbstractPH\n R::G        # Survival response\n P::L        # parameters\n ties::String #\"efron\" or\"breslow\"\n fit::Bool\n bh::AbstractMatrix\n end\n\n PHModel(\n R::G,\n P::L,\n ties::String,\n fit::Bool,\n ) where {G<:LSurvResp,L<:AbstractLSurvParms}\n PHModel(R::G, P::L, ties::String) where {G<:LSurvResp,L<:AbstractLSurvParms}\n PHModel(R::G, P::L) where {G<:LSurvResp,L<:AbstractLSurvParms}\n\nMethods: fit, coef, confint, std_err, show\n\nExample\n\n using LSurvival\n using Random\n import LSurvival: _stepcox!, dgm_comprisk\n\n z,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\n enter = zeros(length(t));\n X = hcat(x,z);\n R = LSurvResp(enter, t, Int.(d), wt)\n P = PHParms(X)\n mf = PHModel(R,P)\n  LSurvival._fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L, Union{Nothing, FormulaTerm}}} where {G<:LSurvResp, L<:AbstractLSurvParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression (not generally needed for users)\n\nParameters\n\nR Survival response\nP        # parameters\nties String: \"efron\" or \"breslow\"\nfit Bool: logical for whether the model has been fitted\nbh AbstractMatrix: baseline hazard estimates\n\nSignatures\n\n mutable struct PHModel{G<:LSurvResp,L<:AbstractLSurvParms} <: AbstractPH\n R::G        # Survival response\n P::L        # parameters\n ties::String #\"efron\" or\"breslow\"\n fit::Bool\n bh::AbstractMatrix\n end\n\n PHModel(\n R::G,\n P::L,\n ties::String,\n fit::Bool,\n ) where {G<:LSurvResp,L<:AbstractLSurvParms}\n PHModel(R::G, P::L, ties::String) where {G<:LSurvResp,L<:AbstractLSurvParms}\n PHModel(R::G, P::L) where {G<:LSurvResp,L<:AbstractLSurvParms}\n\nMethods: fit, coef, confint, std_err, show\n\nExample\n\n using LSurvival\n using Random\n import LSurvival: _stepcox!, dgm_comprisk\n\n z,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\n enter = zeros(length(t));\n X = hcat(x,z);\n R = LSurvResp(enter, t, Int.(d), wt)\n P = PHParms(X)\n mf = PHModel(R,P)\n  LSurvival._fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L}} where {G<:LSurvResp, L<:AbstractLSurvParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression (not generally needed for users)\n\nParameters\n\nR Survival response\nP        # parameters\nties String: \"efron\" or \"breslow\"\nfit Bool: logical for whether the model has been fitted\nbh AbstractMatrix: baseline hazard estimates\n\nSignatures\n\n mutable struct PHModel{G<:LSurvResp,L<:AbstractLSurvParms} <: AbstractPH\n R::G        # Survival response\n P::L        # parameters\n ties::String #\"efron\" or\"breslow\"\n fit::Bool\n bh::AbstractMatrix\n end\n\n PHModel(\n R::G,\n P::L,\n ties::String,\n fit::Bool,\n ) where {G<:LSurvResp,L<:AbstractLSurvParms}\n PHModel(R::G, P::L, ties::String) where {G<:LSurvResp,L<:AbstractLSurvParms}\n PHModel(R::G, P::L) where {G<:LSurvResp,L<:AbstractLSurvParms}\n\nMethods: fit, coef, confint, std_err, show\n\nExample\n\n using LSurvival\n using Random\n import LSurvival: _stepcox!, dgm_comprisk\n\n z,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\n enter = zeros(length(t));\n X = hcat(x,z);\n R = LSurvResp(enter, t, Int.(d), wt)\n P = PHParms(X)\n mf = PHModel(R,P)\n  LSurvival._fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHSurv","page":"Home","title":"LSurvival.PHSurv","text":"Mutable type for proportional hazards models (not generally needed by users)\n\nPHSsurv: Object type for proportional hazards regression\n\nsurv::Vector{Float64}  risk::Matrix{Float64}  basehaz::Vector{Float64}  event::Vector{Float64}\n\nfitlist: vector of PHSurv objects (Cox model fits)\neventtypes: vector of unique event types\ntimes: unique event times\nsurv: Overall survival at each time\nrisk: Cause-specific risk  at each time (1 for each outcome type)\nbasehaz: baseline hazard for a specific event type\nevent: value of event type that occurred at each time\n\nMethods: fit, show\n\n mutable struct PHSurv{G<:Array{T} where {T<:PHModel}} <: AbstractNPSurv\n fitlist::G        \n eventtypes::AbstractVector\n times::AbstractVector\n surv::Vector{Float64}\n risk::Matrix{Float64}\n basehaz::Vector{Float64}\n event::Vector{Float64}\n end\n\n PHSurv(fitlist::Array{T}, eventtypes) where {T<:PHModel}\n PHSurv(fitlist::Array{T}) where {T<:PHModel}\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.PHSurv-Union{Tuple{Array{T}}, Tuple{T}} where T<:PHModel","page":"Home","title":"LSurvival.PHSurv","text":"Mutable type for proportional hazards models (not generally needed by users)\n\nPHSsurv: Object type for proportional hazards regression\n\nsurv::Vector{Float64}  risk::Matrix{Float64}  basehaz::Vector{Float64}  event::Vector{Float64}\n\nfitlist: vector of PHSurv objects (Cox model fits)\neventtypes: vector of unique event types\ntimes: unique event times\nsurv: Overall survival at each time\nrisk: Cause-specific risk  at each time (1 for each outcome type)\nbasehaz: baseline hazard for a specific event type\nevent: value of event type that occurred at each time\n\nMethods: fit, show\n\n mutable struct PHSurv{G<:Array{T} where {T<:PHModel}} <: AbstractNPSurv\n fitlist::G        \n eventtypes::AbstractVector\n times::AbstractVector\n surv::Vector{Float64}\n risk::Matrix{Float64}\n basehaz::Vector{Float64}\n event::Vector{Float64}\n end\n\n PHSurv(fitlist::Array{T}, eventtypes) where {T<:PHModel}\n PHSurv(fitlist::Array{T}) where {T<:PHModel}\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHSurv-Union{Tuple{T}, Tuple{Array{T}, Any}} where T<:PHModel","page":"Home","title":"LSurvival.PHSurv","text":"Mutable type for proportional hazards models (not generally needed by users)\n\nPHSsurv: Object type for proportional hazards regression\n\nsurv::Vector{Float64}  risk::Matrix{Float64}  basehaz::Vector{Float64}  event::Vector{Float64}\n\nfitlist: vector of PHSurv objects (Cox model fits)\neventtypes: vector of unique event types\ntimes: unique event times\nsurv: Overall survival at each time\nrisk: Cause-specific risk  at each time (1 for each outcome type)\nbasehaz: baseline hazard for a specific event type\nevent: value of event type that occurred at each time\n\nMethods: fit, show\n\n mutable struct PHSurv{G<:Array{T} where {T<:PHModel}} <: AbstractNPSurv\n fitlist::G        \n eventtypes::AbstractVector\n times::AbstractVector\n surv::Vector{Float64}\n risk::Matrix{Float64}\n basehaz::Vector{Float64}\n event::Vector{Float64}\n end\n\n PHSurv(fitlist::Array{T}, eventtypes) where {T<:PHModel}\n PHSurv(fitlist::Array{T}) where {T<:PHModel}\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.Strata","page":"Home","title":"LSurvival.Strata","text":"Type for identifying individuals in survival outcomes.  Used for the strata argument in PHModel (not yet implemented)\n\nAccepts any Number or String. There is no significance to having this particular struct, but it enables easier use of multiple dispatch.\n\n [Strata(i) for i in 1:10]\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival._update_PHParms!-Union{Tuple{T}, Tuple{I}, Tuple{M}, Tuple{M, I, Array{Vector{T}, 1}, Array{Vector{T}, 1}}} where {M<:AbstractPH, I<:Int64, T<:Int64}","page":"Home","title":"LSurvival._update_PHParms!","text":"Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).\n\nUses Breslow's or Efron's partial likelihood.\n\nUpdates over all observations\n\n function _update_PHParms!(\n  m::M,\n  # big indexes\n  ne::I,\n  caseidxs::Vector{Vector{T}},\n  risksetidxs::Vector{Vector{T}},\n) where {M<:AbstractPH,I<:Int,T<:Int}\n\nupdatePHParms!(m, risksetidxs, caseidxs, ne, den)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.aalen_johansen-Tuple{Any, Any, Any, Vararg{Any}}","page":"Home","title":"LSurvival.aalen_johansen","text":"Aalen-Johansen estimator for cumulative risk\n\nSignatures\n\n  StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n \n  aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n    ; <keyword arguments>)\n \n\n using LSurvival\n using Random\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n    # event variable is coded 0[referent],1,2\n m = fit(AJSurv, enter, t, event)\n mw = fit(AJSurv, enter, t, event, wts=wt)\n\nor, equivalently:\n\n aalen_johansen(enter, t, event, wts=wt)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Tuple{MersenneTwister, PHModel, Int64}","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrapping coefficients of a proportional hazards model\n\nSignatures\n\n # single bootstrap draw, keeping the entire object\n bootstrap(rng::MersenneTwister, m::PHModel)\n bootstrap(m::PHModel)\n # muliple bootstrap draws, keeping only coefficient estimates\n bootstrap(rng::MersenneTwister, m::PHModel, iter::Int; kwargs...)\n bootstrap(m::PHModel, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up\n\n using LSurvival, Random\n\n id, int, outt, data =\n LSurvival.dgm(MersenneTwister(1212), 500, 5; afun = LSurvival.int_0)\n\n d, X = data[:, 4], data[:, 1:3]\n weights = rand(length(d))\n\n # survival outcome:\n R = LSurvResp(int, outt, d, ID.(id))    # specification with ID only\n P = PHParms(X)\n\n Mod = PHModel(R, P)\n LSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)\n\n\n # careful propogation of bootstrap sampling\n idx, R2 = bootstrap(R)\n P2 = bootstrap(idx, P)\n Modb = PHModel(R2, P2)\n LSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)\n\n # convenience function for bootstrapping a model\n Modc = bootstrap(Mod)\n LSurvival._fit!(Modc, start=Modc.P._B);\n Modc\n Modc.P.X == nothing\n Modc.R == nothing\n\n\nBootstrap Cox model coefficients\n\n LSurvival._fit!(mb, keepx=true, keepy=true, start=[0.0, 0.0])\n\n using LSurvival, Random\n res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 200)\n int = zeros(length(d)) # no late entry\n X = hcat(z, x)\n\n mainfit = fit(PHModel, X, int, outt, d .* (event .== 1), keepx=true, keepy=true)\n\n function stddev_finite(x)\n  n = length(x)\n  mnx = sum(x)/n\n  ret = sum((x .- mnx) .^ 2)\n  ret /= n-1\n  sqrt(ret)\n end\n\n # bootstrap standard error versus asymptotic\n mb = bootstrap(MersenneTwister(123123), mainfit, 200)\n ## bootstrap standard error\n [stddev_finite(mb[:,i]) for i in 1:2]\n ## asymptotic standard error\n stderror(mainfit)\n \n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Tuple{MersenneTwister, PHModel}","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrapping coefficients of a proportional hazards model\n\nSignatures\n\n # single bootstrap draw, keeping the entire object\n bootstrap(rng::MersenneTwister, m::PHModel)\n bootstrap(m::PHModel)\n # muliple bootstrap draws, keeping only coefficient estimates\n bootstrap(rng::MersenneTwister, m::PHModel, iter::Int; kwargs...)\n bootstrap(m::PHModel, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up\n\n using LSurvival, Random\n\n id, int, outt, data =\n LSurvival.dgm(MersenneTwister(1212), 500, 5; afun = LSurvival.int_0)\n\n d, X = data[:, 4], data[:, 1:3]\n weights = rand(length(d))\n\n # survival outcome:\n R = LSurvResp(int, outt, d, ID.(id))    # specification with ID only\n P = PHParms(X)\n\n Mod = PHModel(R, P)\n LSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)\n\n\n # careful propogation of bootstrap sampling\n idx, R2 = bootstrap(R)\n P2 = bootstrap(idx, P)\n Modb = PHModel(R2, P2)\n LSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)\n\n # convenience function for bootstrapping a model\n Modc = bootstrap(Mod)\n LSurvival._fit!(Modc, start=Modc.P._B);\n Modc\n Modc.P.X == nothing\n Modc.R == nothing\n\n\nBootstrap Cox model coefficients\n\n LSurvival._fit!(mb, keepx=true, keepy=true, start=[0.0, 0.0])\n\n using LSurvival, Random\n res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 200)\n int = zeros(length(d)) # no late entry\n X = hcat(z, x)\n\n mainfit = fit(PHModel, X, int, outt, d .* (event .== 1), keepx=true, keepy=true)\n\n function stddev_finite(x)\n  n = length(x)\n  mnx = sum(x)/n\n  ret = sum((x .- mnx) .^ 2)\n  ret /= n-1\n  sqrt(ret)\n end\n\n # bootstrap standard error versus asymptotic\n mb = bootstrap(MersenneTwister(123123), mainfit, 200)\n ## bootstrap standard error\n [stddev_finite(mb[:,i]) for i in 1:2]\n ## asymptotic standard error\n stderror(mainfit)\n \n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Tuple{Vector{Int64}, PHParms}","page":"Home","title":"LSurvival.bootstrap","text":"using LSurvival, Random\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nweights = rand(length(d))\n\n# survival outcome:\nR = LSurvResp(int, outt, d, ID.(id))    # specification with ID only\nP = PHParms(X)\nidx, R2 = bootstrap(R)\nP2 = bootstrap(idx, P)\n\nMod = PHModel(R2, P2)\nLSurvival._fit!(Mod, start=Mod.P._B)\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M, Int64}} where M<:AJSurv","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrap methods for Aalen-Johansen cumulative risk estimator\n\nSignatures\n\n  # single bootstrap draw, keeping the entire object\n  bootstrap(rng::MersenneTwister, m::AJSurv)\n  bootstrap(m::AJSurv)\n  # muliple bootstrap draws, keeping only coefficient estimates\n  bootstrap(rng::MersenneTwister, m::AJSurv, iter::Int; kwargs...)\n  bootstrap(m::AJSurv, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up\n\n using LSurvival\n using Random\n\n z, x, t, d, event, wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 100)\n id = 1:length(x)\n enter = zeros(length(t))\n\n aj1 = aalen_johansen(enter, t, event, id=ID.(id), wts=wt)\n aj2 = bootstrap(aj1, keepy=false);\n ajboot = bootstrap(aj1, 10, keepy=false);\n aj1\n\n\n aj1.R\n aj2.R\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M, Int64}} where M<:KMSurv","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrap methods for Kaplan-Meier survival curve estimator\n\nSignatures\n\n  # single bootstrap draw, keeping the entire object\n  bootstrap(rng::MersenneTwister, m::KMSurv)\n  bootstrap(m::KMSurv)\n  # muliple bootstrap draws, keeping only coefficient estimates\n  bootstrap(rng::MersenneTwister, m::KMSurv, iter::Int; kwargs...)\n  bootstrap(m::KMSurv, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the survival probability at the end of follow up\n\n using LSurvival\n using Random\n\n id, int, outt, data =\n LSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\n d, X = data[:, 4], data[:, 1:3]\n wts = rand(length(d))\n\n km1 = kaplan_meier(int, outt, d, id=ID.(id), wts=wts)\n km2 = bootstrap(km1, keepy=false)\n km3 = bootstrap(km1, 10, keepy=false)\n km1\n\n km1.R\n km2.R\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M<:AJSurv","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrap methods for Aalen-Johansen cumulative risk estimator\n\nSignatures\n\n  # single bootstrap draw, keeping the entire object\n  bootstrap(rng::MersenneTwister, m::AJSurv)\n  bootstrap(m::AJSurv)\n  # muliple bootstrap draws, keeping only coefficient estimates\n  bootstrap(rng::MersenneTwister, m::AJSurv, iter::Int; kwargs...)\n  bootstrap(m::AJSurv, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up\n\n using LSurvival\n using Random\n\n z, x, t, d, event, wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 100)\n id = 1:length(x)\n enter = zeros(length(t))\n\n aj1 = aalen_johansen(enter, t, event, id=ID.(id), wts=wt)\n aj2 = bootstrap(aj1, keepy=false);\n ajboot = bootstrap(aj1, 10, keepy=false);\n aj1\n\n\n aj1.R\n aj2.R\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M<:KMSurv","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrap methods for Kaplan-Meier survival curve estimator\n\nSignatures\n\n  # single bootstrap draw, keeping the entire object\n  bootstrap(rng::MersenneTwister, m::KMSurv)\n  bootstrap(m::KMSurv)\n  # muliple bootstrap draws, keeping only coefficient estimates\n  bootstrap(rng::MersenneTwister, m::KMSurv, iter::Int; kwargs...)\n  bootstrap(m::KMSurv, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the survival probability at the end of follow up\n\n using LSurvival\n using Random\n\n id, int, outt, data =\n LSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\n d, X = data[:, 4], data[:, 1:3]\n wts = rand(length(d))\n\n km1 = kaplan_meier(int, outt, d, id=ID.(id), wts=wts)\n km2 = bootstrap(km1, keepy=false)\n km3 = bootstrap(km1, 10, keepy=false)\n km1\n\n km1.R\n km2.R\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T<:LSurvCompResp","page":"Home","title":"LSurvival.bootstrap","text":"z,x,t,d,event,weights =\nLSurvival.dgm_comprisk(MersenneTwister(1212), 300)\nenter = zeros(length(event))\n\n# survival outcome:\nR = LSurvCompResp(enter, t, event, weights, ID.(collect(1:length(t))))    # specification with ID only\nbootstrap(R) # note that entire observations/clusters identified by id are kept\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T<:LSurvResp","page":"Home","title":"LSurvival.bootstrap","text":"id, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nweights = rand(length(d))\n\n# survival outcome:\nR = LSurvResp(int, outt, d, ID.(id))    # specification with ID only\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.coxph-Tuple{Any, Any, Any, Any, Vararg{Any}}","page":"Home","title":"LSurvival.coxph","text":"Fit method for AbstractPH objects\n\n  fit(::Type{M},\n  X::AbstractMatrix,#{<:FP},\n  enter::AbstractVector{<:Real},\n  exit::AbstractVector{<:Real},\n  y::Union{AbstractVector{<:Real},BitVector}\n  ;\n  ties =\"breslow\",\n  wts::AbstractVector{<:Real}      = similar(y, 0),\n  offset::AbstractVector{<:Real}   = similar(y, 0),\n  fitargs...) where {M<:AbstractPH}\n ```\n\n ```\n coxph(f::FormulaTerm, data; kwargs...)\n\ncoxph(X, enter, exit, y, args...; kwargs...)\n\njulia    using LSurvival, Random    z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);    enter = zeros(length(t));    X = hcat(x,rand(length(x)));     m = fit(PHModel, X, enter, t, d, ties=\"efron\")    m2 = fit(PHModel, X, enter, t, d, ties=\"breslow\")    coeftable(m)\n\n```@example   using Random, LSurvival      id, int, outt, dat =          LSurvival.dgm(MersenneTwister(123123), 100, 100; afun = LSurvival.int_0)      data = (              int = int,              outt = outt,              d = dat[:,4] .== 1,              x = dat[:,1],              z = dat[:,2]      )\n\n f = @formula(Surv(int, outt,d)~x+z)\n coxph(f, data)\n\n```\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.dgm-Tuple{Any, Any, Any}","page":"Home","title":"LSurvival.dgm","text":"Generating discrete survival data without competing risks\n\nUsage: dgm(rng, n, maxT;afun=int0, yfun=yprob, lfun=lprob)  dgm(n, maxT;afun=int0, yfun=yprob, lfun=lprob)\n\nWhere afun, yfun, and lfun are all functions that take arguments v,l,a and output time-specific values of a, y, and l respectively  Example:\n\n\n expit(mu) =  inv(1.0+exp(-mu))\n\n function aprob(v,l,a)\n expit(-1.0 + 3*v + 2*l)\n end\n   \n function lprob(v,l,a)\n expit(-3 + 2*v + 0*l + 0*a)\n end\n   \n function yprob(v,l,a)\n expit(-3 + 2*v + 0*l + 2*a)\n end\n   # 10 individuals followed for up to 5 times\n LSurvival.dgm(10, 5;afun=aprob, yfun=yprob, lfun=lprob)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.dgm_comprisk-Tuple{Any, Any}","page":"Home","title":"LSurvival.dgm_comprisk","text":"Generating continuous survival data with competing risks\n\nUsage: dgmcomprisk(rng, n)  dgmcomprisk(n)\n\n     - rng = random number generator    \n     - n = sample size\n\nExample:\n\n using LSurvival\n     # 100 individuals with two competing events\n z,x,t,d,event,weights = LSurvival.dgm_comprisk(100)\n     \n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.kaplan_meier-Tuple{Any, Any, Any, Vararg{Any}}","page":"Home","title":"LSurvival.kaplan_meier","text":"Fit methods for KMSurv objects\n\nSignatures\n\n StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\n kaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n    ; <keyword arguments>)\n\n using LSurvival\n using Random\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n m = fit(KMSurv, enter, t, d)\n mw = fit(KMSurv, enter, t, d, wts=wt)\n\nor, equivalently:\n\n kaplan_meier(enter, t, d, wts=wt)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lgh_breslow!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M<:AbstractPH","page":"Home","title":"LSurvival.lgh_breslow!","text":"Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).\n\nUses Breslow's partial likelihood.\n\nUpdates over all observations\n\nSignature\n\n lgh_breslow!(m::M, j, caseidx, risksetidx) where {M<:AbstractPH}\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lgh_efron!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M<:AbstractPH","page":"Home","title":"LSurvival.lgh_efron!","text":"Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).\n\nUses Efron's partial likelihood.\n\nUpdates over all observations\n\nSignature\n\n lgh_efron!(m::M, j, caseidx, risksetidx) where {M<:AbstractPH}\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.risk_from_coxphmodels-Union{Tuple{T}, Tuple{Array{T}, Vararg{Any}}} where T<:PHModel","page":"Home","title":"LSurvival.risk_from_coxphmodels","text":"Survival curve estimation using multiple cox models\n\nFunction Signatures\n\nrisk_from_coxphmodels(fitlist::Array{T}, args...; kwargs...) where {T<:PHModel}\n\nfit(::Type{M}, fitlist::Vector{<:T}, ; fitargs...) where {M<:PHSurv,T<:PHModel}\n\nOptional keywords\n\ncoef_vectors = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]\npred_profile = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]\n\n using LSurvival\n using Random\n # event variable is coded 0[referent],1,2\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n\n ft1 = coxph(hcat(x,z), enter, t, (event .== 1))\n nidx = findall(event .!= 1)\n ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))\n\n # risk at referent levels of `x` and `z`\n risk_from_coxphmodels([ft1,ft2])\n\n # risk at average levels of `x` and `z`\n mnx = sum(x)/length(x)\n mnz = sum(z)/length(z)\n risk_from_coxphmodels([ft1,ft2], pred_profile=[mnx,mnz])\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.robust_vcov-Tuple{M} where M<:PHModel","page":"Home","title":"LSurvival.robust_vcov","text":"using LSurvival\ndat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n)\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"breslow\")\n\nrobust_vcov(ft)\nvcov(ft)                   # model based\nvcov(ft, type=\"robust\")    # robust variance, based on dfbeta residuals\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.confint-Tuple{AJSurv}","page":"Home","title":"StatsAPI.confint","text":"Greenwood's formula for variance and confidence intervals of a Aalen-Johansen risk function\n\n res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)\n int = zeros(length(d)) # no late entry\n m = fit(AJSurv, int, outt, event)\n stderror(m)\n confint(m, level=0.95)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.confint-Tuple{KMSurv}","page":"Home","title":"StatsAPI.confint","text":"Greenwood's formula for variance and confidence intervals of a Kaplan-Meier survival curve\n\nSignatures:\n\n StatsBase.stderror(m::KMSurv)\n\n StatsBase.confint(m:KMSurv; level=0.95, method=\"normal\")\n\nmethod:\n\n\"normal\" normality-based confidence intervals\n\"lognlog\" log(-log(S(t))) based confidence intervals\n\n using LSurvival\n using Random\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n m = fit(KMSurv, enter, t, d)\n mw = fit(KMSurv, enter, t, d, wts=wt)\n stderror(m)\n confint(m, method=\"normal\")\n confint(m, method=\"lognlog\") # log-log transformation\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.confint-Tuple{M} where M<:AbstractPH","page":"Home","title":"StatsAPI.confint","text":"dat1 = (     time = [1,1,6,6,8,9],     status = [1,0,1,1,0,1],     x = [1,1,1,0,0,0] )\n\nft = coxph(@formula(Surv(time, status) ~ x),dat1, keepx=true)\n\nmodel-based variance\n\nconfint(ft)\n\nrobust variance\n\nconfint(ft, type=\"robust\")\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit!-Tuple{T} where T<:AbstractNPSurv","page":"Home","title":"StatsAPI.fit!","text":"Fit methods for KMSurv objects\n\nSignatures\n\n StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\n kaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n    ; <keyword arguments>)\n\n using LSurvival\n using Random\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n m = fit(KMSurv, enter, t, d)\n mw = fit(KMSurv, enter, t, d, wts=wt)\n\nor, equivalently:\n\n kaplan_meier(enter, t, d, wts=wt)\n\nAalen-Johansen estimator for cumulative risk\n\nSignatures\n\n  StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n \n  aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n    ; <keyword arguments>)\n \n\n using LSurvival\n using Random\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n    # event variable is coded 0[referent],1,2\n m = fit(AJSurv, enter, t, event)\n mw = fit(AJSurv, enter, t, event, wts=wt)\n\nor, equivalently:\n\n aalen_johansen(enter, t, event, wts=wt)\n\nSurvival curve estimation using multiple cox models\n\nFunction Signatures\n\nrisk_from_coxphmodels(fitlist::Array{T}, args...; kwargs...) where {T<:PHModel}\n\nfit(::Type{M}, fitlist::Vector{<:T}, ; fitargs...) where {M<:PHSurv,T<:PHModel}\n\nOptional keywords\n\ncoef_vectors = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]\npred_profile = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]\n\n using LSurvival\n using Random\n # event variable is coded 0[referent],1,2\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n\n ft1 = coxph(hcat(x,z), enter, t, (event .== 1))\n nidx = findall(event .!= 1)\n ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))\n\n # risk at referent levels of `x` and `z`\n risk_from_coxphmodels([ft1,ft2])\n\n # risk at average levels of `x` and `z`\n mnx = sum(x)/length(x)\n mnz = sum(z)/length(z)\n risk_from_coxphmodels([ft1,ft2], pred_profile=[mnx,mnz])\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{T}, Tuple{M}, Tuple{Type{M}, Vector{<:T}}} where {M<:PHSurv, T<:PHModel}","page":"Home","title":"StatsAPI.fit","text":"Survival curve estimation using multiple cox models\n\nFunction Signatures\n\nrisk_from_coxphmodels(fitlist::Array{T}, args...; kwargs...) where {T<:PHModel}\n\nfit(::Type{M}, fitlist::Vector{<:T}, ; fitargs...) where {M<:PHSurv,T<:PHModel}\n\nOptional keywords\n\ncoef_vectors = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]\npred_profile = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]\n\n using LSurvival\n using Random\n # event variable is coded 0[referent],1,2\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n\n ft1 = coxph(hcat(x,z), enter, t, (event .== 1))\n nidx = findall(event .!= 1)\n ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))\n\n # risk at referent levels of `x` and `z`\n risk_from_coxphmodels([ft1,ft2])\n\n # risk at average levels of `x` and `z`\n mnx = sum(x)/length(x)\n mnz = sum(z)/length(z)\n risk_from_coxphmodels([ft1,ft2], pred_profile=[mnx,mnz])\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Matrix{<:Real}, Vector{<:Real}, Vector{<:Real}, Y}} where {M<:AbstractPH, Y<:Union{BitVector, Vector{<:Real}}}","page":"Home","title":"StatsAPI.fit","text":"Fit method for AbstractPH objects\n\n  fit(::Type{M},\n  X::AbstractMatrix,#{<:FP},\n  enter::AbstractVector{<:Real},\n  exit::AbstractVector{<:Real},\n  y::Union{AbstractVector{<:Real},BitVector}\n  ;\n  ties =\"breslow\",\n  wts::AbstractVector{<:Real}      = similar(y, 0),\n  offset::AbstractVector{<:Real}   = similar(y, 0),\n  fitargs...) where {M<:AbstractPH}\n ```\n\n ```\n coxph(f::FormulaTerm, data; kwargs...)\n\ncoxph(X, enter, exit, y, args...; kwargs...)\n\njulia    using LSurvival, Random    z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);    enter = zeros(length(t));    X = hcat(x,rand(length(x)));     m = fit(PHModel, X, enter, t, d, ties=\"efron\")    m2 = fit(PHModel, X, enter, t, d, ties=\"breslow\")    coeftable(m)\n\n```@example   using Random, LSurvival      id, int, outt, dat =          LSurvival.dgm(MersenneTwister(123123), 100, 100; afun = LSurvival.int_0)      data = (              int = int,              outt = outt,              d = dat[:,4] .== 1,              x = dat[:,1],              z = dat[:,2]      )\n\n f = @formula(Surv(int, outt,d)~x+z)\n coxph(f, data)\n\n```\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{<:Real}, Vector{<:Real}, Y}} where {M<:AJSurv, Y<:Union{BitVector, Vector{<:Real}}}","page":"Home","title":"StatsAPI.fit","text":"Aalen-Johansen estimator for cumulative risk\n\nSignatures\n\n  StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n \n  aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n    ; <keyword arguments>)\n \n\n using LSurvival\n using Random\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n    # event variable is coded 0[referent],1,2\n m = fit(AJSurv, enter, t, event)\n mw = fit(AJSurv, enter, t, event, wts=wt)\n\nor, equivalently:\n\n aalen_johansen(enter, t, event, wts=wt)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{<:Real}, Vector{<:Real}, Y}} where {M<:KMSurv, Y<:Union{BitVector, Vector{<:Real}}}","page":"Home","title":"StatsAPI.fit","text":"Fit methods for KMSurv objects\n\nSignatures\n\n StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\n kaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n    ; <keyword arguments>)\n\n using LSurvival\n using Random\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n m = fit(KMSurv, enter, t, d)\n mw = fit(KMSurv, enter, t, d, wts=wt)\n\nor, equivalently:\n\n kaplan_meier(enter, t, d, wts=wt)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.loglikelihood-Tuple{M} where M<:AbstractPH","page":"Home","title":"StatsAPI.loglikelihood","text":"Maximum log partial likelihood for a fitted AbstractPH model Efron or Breslow (depending on the ties` parameter)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.nullloglikelihood-Tuple{M} where M<:AbstractPH","page":"Home","title":"StatsAPI.nullloglikelihood","text":"Null log-partial likelihood for a fitted AbstractPH model Efron or Breslow (depending on the ties` parameter)\n\nNote: this is just the log partial likelihood at the initial values of the model, which default to 0. If initial values are non-null, then this function no longer validly returns the null log-partial likelihood.\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.residuals-Tuple{M} where M<:PHModel","page":"Home","title":"StatsAPI.residuals","text":"#################################################################### Cox proportional hazards model residuals:\n\nSignature\n\nresiduals(m::M; type = \"martingale\") where {M<:PHModel}\n\nwhere type is one of \n\nmartingale\nschoenfeld\nscore\ndfbeta\nscaled_schoenfeld\n\nResiduals from the residuals function are designed to exactly emulate those from the survival package in R. Currently, they are validated for single observation data (e.g. one data row per individual).\n\n####################################################################\n\nMartingale residuals: Observed versus expected\n\n# example from https://cran.r-project.org/web/packages/survival/vignettes/validate.pdf\n# by Terry Therneau\n\ndat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n)\n\n# Nelson-Aalen type estimator for Breslow partial likelihood\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"breslow\")\nresiduals(ft, type=\"martingale\")\n\ndat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n)\n\n# Fleming-Harrington type estimator for Efron partial likelihood\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"efron\")\nresiduals(ft, type=\"martingale\")\n\n\n####################################################################\n\nScore residuals: Per observation contribution to score function\n\nusing LSurvival\ndat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n)\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"breslow\")\nS = residuals(ft, type=\"score\")[:]\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"efron\", maxiter=0)\nS = residuals(ft, type=\"score\")[:]\n\n####################################################################\n\nSchoenfeld residuals: Per time contribution to score function\n\nusing LSurvival\ndat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n)\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"breslow\", maxiter=0)\n\n\nX = ft.P.X\nM = residuals(ft, type=\"martingale\")\nS = residuals(ft, type=\"schoenfeld\")[:]\n\n####################################################################\n\ndfbeta residuals: influence of individual observations on each parameter\n\nusing LSurvival\ndat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n)\n\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"breslow\")\nL = residuals(ft, type=\"score\") # n X p\nH = ft.P._hess   # p X p\ndfbeta = L*inv(H)\nrobVar = dfbeta'dfbeta\nsqrt(robVar)\n\nusing LSurvival\ndat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n)\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"breslow\")\n\nresiduals(ft, type=\"dfbeta\")\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.stderror-Tuple{AJSurv}","page":"Home","title":"StatsAPI.stderror","text":"Greenwood's formula for variance and confidence intervals of a Aalen-Johansen risk function\n\n res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)\n int = zeros(length(d)) # no late entry\n m = fit(AJSurv, int, outt, event)\n stderror(m)\n confint(m, level=0.95)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.stderror-Tuple{KMSurv}","page":"Home","title":"StatsAPI.stderror","text":"Greenwood's formula for variance and confidence intervals of a Kaplan-Meier survival curve\n\nSignatures:\n\n StatsBase.stderror(m::KMSurv)\n\n StatsBase.confint(m:KMSurv; level=0.95, method=\"normal\")\n\nmethod:\n\n\"normal\" normality-based confidence intervals\n\"lognlog\" log(-log(S(t))) based confidence intervals\n\n using LSurvival\n using Random\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n m = fit(KMSurv, enter, t, d)\n mw = fit(KMSurv, enter, t, d, wts=wt)\n stderror(m)\n confint(m, method=\"normal\")\n confint(m, method=\"lognlog\") # log-log transformation\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.vcov-Tuple{M} where M<:AbstractPH","page":"Home","title":"StatsAPI.vcov","text":"Covariance matrix for Cox proportional hazards models  \n\nKeyword arguments\n\ntype nothing or \"robust\": determines whether model based or robust (dfbeta based) variance is returned.\n\nSee ?residuals for info on dfbeta residuals\n\nusing LSurvival\ndat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n)\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"breslow\")\n\nrobust_vcov(ft)\nvcov(ft)                   # model based\nvcov(ft, type=\"robust\")    # robust variance, based on dfbeta residuals\n\n\n\n\n\n","category":"method"}]
}
