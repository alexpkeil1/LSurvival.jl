var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = LSurvival=","category":"page"},{"location":"#[LSurvival](https://github.com/alexpkeil1/LSurvival.jl).","page":"Home","title":"LSurvival.","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Survival analysis functions in Julia for time-to-event outcomes that can include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Loss-to-follow-up/right censoring\nLate entry/left truncation (not available in the Survival.jl package)\n\"Person-period\" data structures (not available in the Survival.jl package)\nObservation weights (not available in the Survival.jl package)\nCompeting risks (not available in the Survival.jl package)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Capabilities include estimators for","category":"page"},{"location":"","page":"Home","title":"Home","text":"Kaplan-Meier non-parametric conditional risk functions\nAalen-Johansen non-parametric cause-specific unconditional risk functions\nCox proportional hazards model (Efron's or Breslow's methods for ties)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Convenience functions enable:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Non-parametric bootstrapping, cluster-bootstrapping\nEstimating baseline hazards from a Cox Model\nEstimating cause-specific risk from an exhaustive set of Cox models for competing risk outcomes\nSimple simulation of competing and non-competing survival events","category":"page"},{"location":"","page":"Home","title":"Home","text":"Plans to include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Cluster robust variance estimation (without bootstrapping)\nScore and Schoenfeld residuals","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package has been tuned to follow the \"survival\" package from R in terms of specific estimators/results.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Report issues here","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(url = \"https://github.com/alexpkeil1/LSurvival.jl\")","category":"page"},{"location":"#Quick-examples","page":"Home","title":"Quick examples","text":"","category":"section"},{"location":"#Single-event-type:-Cox-model-and-Kaplan-Meier-curve","page":"Home","title":"Single event type: Cox model and Kaplan-Meier curve","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Random, LSurvival, Distributions, LinearAlgebra\n\n# generate some data under a discrete hazards model\nexpit(mu) = inv(1.0 + exp(-mu))\n\nfunction dgm(rng, n, maxT; regimefun = int_0)\n    V = rand(rng, n)\n    LAY = Array{Float64,2}(undef, n * maxT, 4)\n    keep = ones(Bool, n * maxT)\n    id = sort(reduce(vcat, fill(collect(1:n), maxT)))\n    time = (reduce(vcat, fill(collect(1:maxT), n)))\n    for i = 1:n\n        v = V[i]\n        l = 0\n        a = 0\n        lkeep = true\n        for t = 1:maxT\n            currIDX = (i - 1) * maxT + t\n            l = expit(-3 + 2 * v + 0 * l + 0 * a) > rand(rng) ? 1 : 0\n            a = 0.1 > rand(rng) ? 1 : 0\n            y = expit(-3 + 2 * v + 0 * l + 2 * a) > rand(rng) ? 1 : 0\n            LAY[currIDX, :] .= [v, l, a, y]\n            keep[currIDX] = lkeep\n            lkeep = (!lkeep || (y == 1)) ? false : true\n        end\n    end\n    id[findall(keep)], time[findall(keep)] .- 1, time[findall(keep)], LAY[findall(keep), :]\nend\n\nid, int, outt, data = dgm(MersenneTwister(), 1000, 10; regimefun = int_0)\ndata[:, 1] = round.(data[:, 1], digits = 3)\nd, X = data[:, 4], data[:, 1:3]\nwt = rand(length(d)) # random weights just to demonstrate usage\n\n# Cox model\n# Breslow's partial likelihood\nm = fit(PHModel, X, int, outt, d, ties = \"breslow\", wts = wt)\n\n# Efron's partial likelihood\nm2 = fit(PHModel, X, int, outt, d, ties = \"efron\", wts = wt)\n\n#equivalent way to specify \n# using `coxph` function\nm2b = coxph(X, int, outt, d, ties = \"efron\", wts = wt)\n\n# using `coxph` function with `Tables.jl` and `StatsAPI.@formula` interface (similar to GLM.jl)\ntab = ( in = int, out = out, d=d, x=X[:,1], z1=X[:,2], z2=X[:,3]) # can also be a DataFrame from DataFrames.jl\nm2b = coxph(@formula(Surv(in, out, d)~x+z1+z2), ties = \"efron\", wts = wt)\n\n# can also be done if there is no late entry\nm2b = coxph(@formula(Surv(out, d)~x+z1+z2), ties = \"efron\", wts = wt)\n# can also be done if there is no late entry and no right censoring (i.e. all times are failure times)\nm2b = coxph(@formula(Surv(out)~x+z1+z2), ties = \"efron\", wts = wt)\n\n\n\n# Kaplan-Meier estimator of the cumulative risk/survival\nres = kaplan_meier(int, outt, d)","category":"page"},{"location":"#Competing-event-analysis:-Aalen-Johansen-and-Cox-model-based-estimators-of-the-cumulative-risk/survival","page":"Home","title":"Competing event analysis: Aalen-Johansen and Cox-model-based estimators of the cumulative risk/survival","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Random, LSurvival, Distributions, LinearAlgebra\n\n# simulate some data\nfunction dgm_comprisk(; n = 100, rng = MersenneTwister())\n    z = rand(rng, n) .* 5\n    x = rand(rng, n) .* 5\n    dt1 = Weibull.(fill(0.75, n), inv.(exp.(-x .- z)))\n    dt2 = Weibull.(fill(0.75, n), inv.(exp.(-x .- z)))\n    t01 = rand.(rng, dt1)\n    t02 = rand.(rng, dt2)\n    t0 = min.(t01, t02)\n    t = Array{Float64,1}(undef, n)\n    for i = 1:n\n        t[i] = t0[i] > 1.0 ? 1.0 : t0[i]\n    end\n    d = (t .== t0)\n    event = (t .== t01) .+ 2.0 .* (t .== t02)\n    wtu = rand(rng, n) .* 5.0\n    wt = wtu ./ mean(wtu)\n    reshape(round.(z, digits = 4), (n, 1)),\n    reshape(round.(x, digits = 4), (n, 1)),\n    round.(t, digits = 4),\n    d,\n    event,\n    round.(wt, digits = 4)\nend\n\nz, x, t, d, event, wt = dgm_comprisk(; n = 100, rng = MersenneTwister(12))\nX = hcat(x,z)\nenter = t .* rand(length(d))*0.02 # create some fake entry times\n\n# Aalen-Johansen estimator: marginal cause-specific risks\nres_aj = aalen_johansen(enter, t, event; wts = wt);\nres_aj\n\n# Cox-model estimator: cause-specific risks at given levels of covariates\nfit1 = fit(PHModel, X, enter, t, (event .== 1), ties = \"efron\",  wts = wt)\n#n2idx = findall(event .!= 1)\nn2idx = findall(event .> -1)\nfit2 = fit(PHModel, X[n2idx,:], enter[n2idx], t[n2idx], (event[n2idx] .== 2), ties = \"breslow\",  wts = wt[n2idx])\n\n# risk at referent levels of `x` and `z` (can be very extreme if referent levels are unlikely/unobservable)\nres_cph_ref = risk_from_coxphmodels([fit1,fit2])\n\n# risk at average levels of `x` and `z`\nmnx = sum(x)/length(x)\nmnz = sum(z)/length(z)\nres_cph = risk_from_coxphmodels([fit1,fit2], coef_vectors=[coef(ft1), coef(ft2)], pred_profile=mean(X, dims=1))\n# compare to Aalen-Johansen fit\nres_aj\n\n\n# this approach operates on left censored outcomes (which operate in the background in model fitting)\nLSurvResp(enter, t, d, origintime=0)\nLSurvCompResp(enter, t, event) # automatically infers origin\n\n\n# can use the ID type to refer to units with multiple observations\nid, int, outt, data = dgm(MersenneTwister(), 1000, 10; regimefun = int_0)\nLSurvResp(int, outt, data[:,4], ID.(id))","category":"page"},{"location":"#Index-of-functions","page":"Home","title":"Index of functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Function-help","page":"Home","title":"Function help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [LSurvival]","category":"page"},{"location":"#LSurvival.AbstractLSurvParms","page":"Home","title":"LSurvival.AbstractLSurvParms","text":"AbstractLsurvParms\n\nAbstract type representing a model predictors and coefficient parameters\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractLSurvResp","page":"Home","title":"LSurvival.AbstractLSurvResp","text":"AbstractLsurvResp\n\nAbstract type representing a model response vector\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractNPSurv","page":"Home","title":"LSurvival.AbstractNPSurv","text":"Abstract type for non-parametric survival models, including Kaplan-Meier, Aalen Johansen, and Cox-model based estimates of survival using an Aalen-Johansen-like estimator\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractPH","page":"Home","title":"LSurvival.AbstractPH","text":"Abstract type for proportional hazards models\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.ID","page":"Home","title":"LSurvival.ID","text":"Type for identifying individuals in survival outcomes.\n\nAccepts any Number or String\n\n[ID(i) for i in 1:10]\n\nUsed for the id argument in \n\nOutcome types: LSurvResp, LSurvCompResp \nModel types: PHModel, KMRisk, AJRisk\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.LSurvCompResp","page":"Home","title":"LSurvival.LSurvCompResp","text":"Outcome type for competing risk survival outcomes subject to left truncation and right censoring\n\n struct LSurvCompResp{\n E<:AbstractVector,\n X<:AbstractVector,\n Y<:AbstractVector,\n W<:AbstractVector,\n T<:Real,\n I<:AbstractLSurvID,\n V<:AbstractVector,\n M<:AbstractMatrix,\n } <: AbstractLSurvResp\n enter::E\n \"`exit`: Time at observation end\"\n exit::X\n \"`y`: event type in observation (integer)\"\n y::Y\n \"`wts`: observation weights\"\n wts::W\n \"`eventtimes`: unique event times\"\n eventtimes::X\n \"`origin`: origin on the time scale\"\n origin::T\n \"`id`: person level identifier (must be wrapped in ID() function)\"\n id::Vector{I}\n \"`eventtypes`: vector of unique event types\"\n eventtypes::V\n \"`eventmatrix`: matrix of indicators on the observation level\"\n eventmatrix::M\n end\n\n ```\n\n ```\n LSurvCompResp(\n enter::E,\n exit::X,\n y::Y,\n wts::W,\n id::Vector{I}\n )\n ```\n\n ```\n LSurvCompResp(\n enter::E,\n exit::X,\n y::Y,\n id::Vector{I}\n )\n ```\n\n ```\n LSurvCompResp(\n enter::E,\n exit::X,\n y::Y,\n wts::W,\n )\n ```\n\n ```{julia}\n LSurvCompResp(\n enter::E,\n exit::X,\n y::Y,\n )\n ```\n\n ```{julia}\n LSurvCompResp(\n  exit::X,\n  y::Y,\n) where {X<:Vector,Y<:Union{Vector{<:Real},BitVector}}\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.LSurvResp","page":"Home","title":"LSurvival.LSurvResp","text":"Outcome type for survival outcome subject to left truncation and right censoring. \n\nWill not generally be needed by users\n\n struct LSurvResp{\n E<:AbstractVector,\n X<:AbstractVector,\n Y<:AbstractVector,\n W<:AbstractVector,\n T<:Real,\n I<:AbstractLSurvID,\n } <: AbstractLSurvResp\n enter::E\n \"`exit`: Time at observation end\"\n exit::X\n \"`y`: event occurrence in observation\"\n y::Y\n \"`wts`: observation weights\"\n wts::W\n \"`eventtimes`: unique event times\"\n eventtimes::E\n \"`origin`: origin on the time scale\"\n origin::T\n \"`id`: person level identifier (must be wrapped in ID() function)\"\n id::Vector{I}\n end\n\n ```\n\n ```{julia}\n LSurvResp(\n    enter::E,\n    exit::X,\n    y::Y,\n    wts::W,\n    id::Vector{I},\n) where {\n    E<:Vector,\n    X<:Vector,\n    Y<:Union{Vector{<:Real},BitVector},\n    W<:Vector,\n    I<:AbstractLSurvID,\n}\n ```\n\n ```{julia}\n LSurvResp(\n enter::E,\n exit::X,\n y::Y,\n id::Vector{I},\n ) \n\n ```\n\n ```{julia}\n LSurvResp(\n  y::Vector{Y},\n  wts::W,\n  id::Vector{I},\n) where {Y<:AbstractSurvTime,W<:Vector,I<:AbstractLSurvID}\n ```\n\n ```{julia}\n LSurvResp(\n  enter::E,\n  exit::X,\n  y::Y,\n) where {E<:Vector,X<:Vector,Y<:Union{Vector{<:Real},BitVector}}\n ```\n\n ```{julia}\n LSurvResp(exit::X, y::Y) where {X<:Vector,Y<:Vector}\n ```\n\n# Examples\n\n{julia}\n\nno late entry\n\nLSurvResp([.5, .6], [1,0])\n\n```\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.PHModel","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression\n\nmutable struct PHModel{G<:LSurvResp,L<:AbstractLSurvParms} <: AbstractPH\nR::G        # Survival response\nP::L        # parameters\nties::String #\"efron\" or\"breslow\"\nfit::Bool\nbh::AbstractMatrix\nend\n\nPHModel(\nR::G,\nP::L,\nties::String,\nfit::Bool,\n) where {G<:LSurvResp,L<:AbstractLSurvParms}\nPHModel(R::G, P::L, ties::String) where {G<:LSurvResp,L<:AbstractLSurvParms}\nPHModel(R::G, P::L) where {G<:LSurvResp,L<:AbstractLSurvParms}\n\nMethods: fit, coef, confint, std_err, show\n\nusing LSurvival\nusing Random\nimport LSurvival: _stepcox!, dgm_comprisk\n\nz,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\nenter = zeros(length(t));\nX = hcat(x,z);\nR = LSurvResp(enter, t, Int.(d), wt)\nP = PHParms(X)\nmf = PHModel(R,P)\n _fit!(mf)\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L, String}} where {G<:LSurvResp, L<:AbstractLSurvParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression\n\nmutable struct PHModel{G<:LSurvResp,L<:AbstractLSurvParms} <: AbstractPH\nR::G        # Survival response\nP::L        # parameters\nties::String #\"efron\" or\"breslow\"\nfit::Bool\nbh::AbstractMatrix\nend\n\nPHModel(\nR::G,\nP::L,\nties::String,\nfit::Bool,\n) where {G<:LSurvResp,L<:AbstractLSurvParms}\nPHModel(R::G, P::L, ties::String) where {G<:LSurvResp,L<:AbstractLSurvParms}\nPHModel(R::G, P::L) where {G<:LSurvResp,L<:AbstractLSurvParms}\n\nMethods: fit, coef, confint, std_err, show\n\nusing LSurvival\nusing Random\nimport LSurvival: _stepcox!, dgm_comprisk\n\nz,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\nenter = zeros(length(t));\nX = hcat(x,z);\nR = LSurvResp(enter, t, Int.(d), wt)\nP = PHParms(X)\nmf = PHModel(R,P)\n _fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L, Union{Nothing, FormulaTerm}, String, Bool}} where {G<:LSurvResp, L<:AbstractLSurvParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression\n\nmutable struct PHModel{G<:LSurvResp,L<:AbstractLSurvParms} <: AbstractPH\nR::G        # Survival response\nP::L        # parameters\nties::String #\"efron\" or\"breslow\"\nfit::Bool\nbh::AbstractMatrix\nend\n\nPHModel(\nR::G,\nP::L,\nties::String,\nfit::Bool,\n) where {G<:LSurvResp,L<:AbstractLSurvParms}\nPHModel(R::G, P::L, ties::String) where {G<:LSurvResp,L<:AbstractLSurvParms}\nPHModel(R::G, P::L) where {G<:LSurvResp,L<:AbstractLSurvParms}\n\nMethods: fit, coef, confint, std_err, show\n\nusing LSurvival\nusing Random\nimport LSurvival: _stepcox!, dgm_comprisk\n\nz,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\nenter = zeros(length(t));\nX = hcat(x,z);\nR = LSurvResp(enter, t, Int.(d), wt)\nP = PHParms(X)\nmf = PHModel(R,P)\n _fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L, Union{Nothing, FormulaTerm}, String}} where {G<:LSurvResp, L<:AbstractLSurvParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression\n\nmutable struct PHModel{G<:LSurvResp,L<:AbstractLSurvParms} <: AbstractPH\nR::G        # Survival response\nP::L        # parameters\nties::String #\"efron\" or\"breslow\"\nfit::Bool\nbh::AbstractMatrix\nend\n\nPHModel(\nR::G,\nP::L,\nties::String,\nfit::Bool,\n) where {G<:LSurvResp,L<:AbstractLSurvParms}\nPHModel(R::G, P::L, ties::String) where {G<:LSurvResp,L<:AbstractLSurvParms}\nPHModel(R::G, P::L) where {G<:LSurvResp,L<:AbstractLSurvParms}\n\nMethods: fit, coef, confint, std_err, show\n\nusing LSurvival\nusing Random\nimport LSurvival: _stepcox!, dgm_comprisk\n\nz,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\nenter = zeros(length(t));\nX = hcat(x,z);\nR = LSurvResp(enter, t, Int.(d), wt)\nP = PHParms(X)\nmf = PHModel(R,P)\n _fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L, Union{Nothing, FormulaTerm}}} where {G<:LSurvResp, L<:AbstractLSurvParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression\n\nmutable struct PHModel{G<:LSurvResp,L<:AbstractLSurvParms} <: AbstractPH\nR::G        # Survival response\nP::L        # parameters\nties::String #\"efron\" or\"breslow\"\nfit::Bool\nbh::AbstractMatrix\nend\n\nPHModel(\nR::G,\nP::L,\nties::String,\nfit::Bool,\n) where {G<:LSurvResp,L<:AbstractLSurvParms}\nPHModel(R::G, P::L, ties::String) where {G<:LSurvResp,L<:AbstractLSurvParms}\nPHModel(R::G, P::L) where {G<:LSurvResp,L<:AbstractLSurvParms}\n\nMethods: fit, coef, confint, std_err, show\n\nusing LSurvival\nusing Random\nimport LSurvival: _stepcox!, dgm_comprisk\n\nz,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\nenter = zeros(length(t));\nX = hcat(x,z);\nR = LSurvResp(enter, t, Int.(d), wt)\nP = PHParms(X)\nmf = PHModel(R,P)\n _fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L}} where {G<:LSurvResp, L<:AbstractLSurvParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression\n\nmutable struct PHModel{G<:LSurvResp,L<:AbstractLSurvParms} <: AbstractPH\nR::G        # Survival response\nP::L        # parameters\nties::String #\"efron\" or\"breslow\"\nfit::Bool\nbh::AbstractMatrix\nend\n\nPHModel(\nR::G,\nP::L,\nties::String,\nfit::Bool,\n) where {G<:LSurvResp,L<:AbstractLSurvParms}\nPHModel(R::G, P::L, ties::String) where {G<:LSurvResp,L<:AbstractLSurvParms}\nPHModel(R::G, P::L) where {G<:LSurvResp,L<:AbstractLSurvParms}\n\nMethods: fit, coef, confint, std_err, show\n\nusing LSurvival\nusing Random\nimport LSurvival: _stepcox!, dgm_comprisk\n\nz,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\nenter = zeros(length(t));\nX = hcat(x,z);\nR = LSurvResp(enter, t, Int.(d), wt)\nP = PHParms(X)\nmf = PHModel(R,P)\n _fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHSurv","page":"Home","title":"LSurvival.PHSurv","text":"Mutable type for proportional hazards models\n\nPHSsurv: Object type for proportional hazards regression\n\nMethods: fit, show\n\nmutable struct PHSurv{G<:Array{T} where {T<:PHModel}} <: AbstractNPSurv\nfitlist::G        # Survival response\neventtypes::AbstractVector\ntimes::AbstractVector\nsurv::Vector{Float64}\nrisk::Matrix{Float64}\nbasehaz::Vector{Float64}\nevent::Vector{Float64}\nend\n\nPHSurv(fitlist::Array{T}, eventtypes) where {T<:PHModel}\nPHSurv(fitlist::Array{T}) where {T<:PHModel}\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.PHSurv-Union{Tuple{Array{T}}, Tuple{T}} where T<:PHModel","page":"Home","title":"LSurvival.PHSurv","text":"Mutable type for proportional hazards models\n\nPHSsurv: Object type for proportional hazards regression\n\nMethods: fit, show\n\nmutable struct PHSurv{G<:Array{T} where {T<:PHModel}} <: AbstractNPSurv\nfitlist::G        # Survival response\neventtypes::AbstractVector\ntimes::AbstractVector\nsurv::Vector{Float64}\nrisk::Matrix{Float64}\nbasehaz::Vector{Float64}\nevent::Vector{Float64}\nend\n\nPHSurv(fitlist::Array{T}, eventtypes) where {T<:PHModel}\nPHSurv(fitlist::Array{T}) where {T<:PHModel}\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHSurv-Union{Tuple{T}, Tuple{Array{T}, Any}} where T<:PHModel","page":"Home","title":"LSurvival.PHSurv","text":"Mutable type for proportional hazards models\n\nPHSsurv: Object type for proportional hazards regression\n\nMethods: fit, show\n\nmutable struct PHSurv{G<:Array{T} where {T<:PHModel}} <: AbstractNPSurv\nfitlist::G        # Survival response\neventtypes::AbstractVector\ntimes::AbstractVector\nsurv::Vector{Float64}\nrisk::Matrix{Float64}\nbasehaz::Vector{Float64}\nevent::Vector{Float64}\nend\n\nPHSurv(fitlist::Array{T}, eventtypes) where {T<:PHModel}\nPHSurv(fitlist::Array{T}) where {T<:PHModel}\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.Strata","page":"Home","title":"LSurvival.Strata","text":"Type for identifying individuals in survival outcomes.\n\nAccepts any Number or String\n\n[ID(i) for i in 1:10]\n\nUsed for the id argument in \n\nOutcome types: LSurvResp, LSurvCompResp \nModel types: PHModel, KMRisk, AJRisk\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival._update_PHParms!-Union{Tuple{T}, Tuple{I}, Tuple{M}, Tuple{M, I, Array{Vector{T}, 1}, Array{Vector{T}, 1}}} where {M<:AbstractPH, I<:Int64, T<:Int64}","page":"Home","title":"LSurvival._update_PHParms!","text":"calculate log likelihood, gradient, hessian at set value of coefficients\n\nfunction _partial_LL!(\n  m::M,\n  # big indexes\n  risksetidxs::Vector{Vector{T}},\n  caseidxs::Vector{Vector{T}},\n  ne::I,\n  den::Vector{<:Real},\n) where {M<:AbstractPH,I<:Int,T<:Int}\n\nwrapper: calculate log partial likelihood, gradient, hessian contributions across all risk sets under a specified method for handling ties (efron and breslow estimators only)\n\np = size(X,2)\n_LL = zeros(1)\n_grad = zeros(p)\n_hess = zeros(p,p)\n_den = zeros(1)\n#\n_B = rand(p)\neventtimes = sort(unique(_out[findall(d.==1)]))\n\nupdatePHParms!(m, risksetidxs, caseidxs, ne, den)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.aalen_johansen-Tuple{Any, Any, Any, Vararg{Any}}","page":"Home","title":"LSurvival.aalen_johansen","text":"Aalen-Johansen estimator for cumulative risk\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\n   # event variable is coded 0[referent],1,2\nm = fit(AJSurv, enter, t, event)\nmw = fit(AJSurv, enter, t, event, wts=wt)\n\nor, equivalently:\n\naalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; <keyword arguments>)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.aj-Tuple{Any, Any, Any}","page":"Home","title":"LSurvival.aj","text":"Deprecated function\n\nAalen-Johansen (survival) with late entry, possibly multiple observations per unit   (simple function)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Tuple{MersenneTwister, PHModel, Int64}","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrapping coefficients of a proportional hazards model\n\nbootstrap(rng::MersenneTwister, m::PHModel)\n\nusing LSurvival, Random\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 500, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nweights = rand(length(d))\n\n# survival outcome:\nR = LSurvResp(int, outt, d, ID.(id))    # specification with ID only\nP = PHParms(X)\n\nMod = PHModel(R, P)\nLSurvival._fit!(Mod, start=Mod.P._B)\n\n\n# careful propogation of bootstrap sampling\nidx, R2 = bootstrap(R)\nP2 = bootstrap(idx, P)\nModb = PHModel(R2, P2)\nLSurvival._fit!(Mod, start=Mod.P._B)\n\n# convenience function for bootstrapping a model\nModc = bootstrap(Mod)\nLSurvival._fit!(Modc, start=Modc.P._B)\nModc.P.X = nothing\nModc.R = nothing\n\n\nbootstrap(rng::MersenneTwister, m::PHModel, iter::Int; kwargs...)\n\nBootstrap Cox model coefficients\n\nLSurvival._fit!(mb, keepx=true, keepy=true, start=[0.0, 0.0])\n\nusing LSurvival, Random\nres = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)\nint = zeros(length(d)) # no late entry\nX = hcat(z, x)\n\nmainfit = fit(PHModel, X, int, outt, d .* (event .== 1), keepx=true, keepy=true)\n\nmb = bootstrap(mainfit, 1000)\nmainfit\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Tuple{MersenneTwister, PHModel}","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrapping coefficients of a proportional hazards model\n\nbootstrap(rng::MersenneTwister, m::PHModel)\n\nusing LSurvival, Random\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 500, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nweights = rand(length(d))\n\n# survival outcome:\nR = LSurvResp(int, outt, d, ID.(id))    # specification with ID only\nP = PHParms(X)\n\nMod = PHModel(R, P)\nLSurvival._fit!(Mod, start=Mod.P._B)\n\n\n# careful propogation of bootstrap sampling\nidx, R2 = bootstrap(R)\nP2 = bootstrap(idx, P)\nModb = PHModel(R2, P2)\nLSurvival._fit!(Mod, start=Mod.P._B)\n\n# convenience function for bootstrapping a model\nModc = bootstrap(Mod)\nLSurvival._fit!(Modc, start=Modc.P._B)\nModc.P.X = nothing\nModc.R = nothing\n\n\nbootstrap(rng::MersenneTwister, m::PHModel, iter::Int; kwargs...)\n\nBootstrap Cox model coefficients\n\nLSurvival._fit!(mb, keepx=true, keepy=true, start=[0.0, 0.0])\n\nusing LSurvival, Random\nres = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)\nint = zeros(length(d)) # no late entry\nX = hcat(z, x)\n\nmainfit = fit(PHModel, X, int, outt, d .* (event .== 1), keepx=true, keepy=true)\n\nmb = bootstrap(mainfit, 1000)\nmainfit\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Tuple{Vector{Int64}, PHParms}","page":"Home","title":"LSurvival.bootstrap","text":"using LSurvival, Random\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nweights = rand(length(d))\n\n# survival outcome:\nR = LSurvResp(int, outt, d, ID.(id))    # specification with ID only\nP = PHParms(X)\nidx, R2 = bootstrap(R)\nP2 = bootstrap(idx, P)\n\nMod = PHModel(R2, P2)\nLSurvival._fit!(Mod, start=Mod.P._B)\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M, Int64}} where M<:AJSurv","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrap methods for Aalen-Johansen cumulative risk estimator\n\nReturns:\n\nIf using bootstrap(fit): a single bootstrap draw\nIf using bootstrap(fit, 10) (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up\n\nusing LSurvival\nusing Random\n\nz, x, t, d, event, wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 100)\nid = 1:length(x)\nenter = zeros(length(t))\n\naj1 = aalen_johansen(enter, t, event, id=ID.(id), wts=wt)\naj2 = bootstrap(aj1, keepy=false);\najboot = bootstrap(aj1, 10, keepy=false);\naj1\n\n\naj1.R\naj2.R\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M, Int64}} where M<:KMSurv","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrap methods for Kaplan-Meier survival curve estimator\n\nReturns:\n\nIf using bootstrap(fit): a single bootstrap draw\nIf using bootstrap(fit, 10) (e.g.): 10 bootstrap draws of the survival probability at the end of follow up\n\nusing LSurvival\nusing Random\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nwts = rand(length(d))\n\nkm1 = kaplan_meier(int, outt, d, id=ID.(id), wts=wts)\nkm2 = bootstrap(km1, keepy=false)\nkm3 = bootstrap(km1, 10, keepy=false)\nkm1\n\nkm1.R\nkm2.R\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M<:AJSurv","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrap methods for Aalen-Johansen cumulative risk estimator\n\nReturns:\n\nIf using bootstrap(fit): a single bootstrap draw\nIf using bootstrap(fit, 10) (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up\n\nusing LSurvival\nusing Random\n\nz, x, t, d, event, wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 100)\nid = 1:length(x)\nenter = zeros(length(t))\n\naj1 = aalen_johansen(enter, t, event, id=ID.(id), wts=wt)\naj2 = bootstrap(aj1, keepy=false);\najboot = bootstrap(aj1, 10, keepy=false);\naj1\n\n\naj1.R\naj2.R\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M<:KMSurv","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrap methods for Kaplan-Meier survival curve estimator\n\nReturns:\n\nIf using bootstrap(fit): a single bootstrap draw\nIf using bootstrap(fit, 10) (e.g.): 10 bootstrap draws of the survival probability at the end of follow up\n\nusing LSurvival\nusing Random\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nwts = rand(length(d))\n\nkm1 = kaplan_meier(int, outt, d, id=ID.(id), wts=wts)\nkm2 = bootstrap(km1, keepy=false)\nkm3 = bootstrap(km1, 10, keepy=false)\nkm1\n\nkm1.R\nkm2.R\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T<:LSurvCompResp","page":"Home","title":"LSurvival.bootstrap","text":"z,x,t,d,event,weights =\nLSurvival.dgm_comprisk(MersenneTwister(1212), 300)\nenter = zeros(length(event))\n\n# survival outcome:\nR = LSurvCompResp(enter, t, event, weights, ID.(collect(1:length(t))))    # specification with ID only\nbootstrap(R) # note that entire observations/clusters identified by id are kept\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T<:LSurvResp","page":"Home","title":"LSurvival.bootstrap","text":"id, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nweights = rand(length(d))\n\n# survival outcome:\nR = LSurvResp(int, outt, d, ID.(id))    # specification with ID only\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.ci_from_coxmodels-Tuple{Any}","page":"Home","title":"LSurvival.ci_from_coxmodels","text":"Deprecated function   Estimating cumulative incidence from two or more cause-specific Cox models\n\nz,x,outt,d,event,weights = LSurvival.dgm_comprisk(120)   X = hcat(z,x)   int = zeros(120)   d1  = d .* Int.(event.== 1)   d2  = d .* Int.(event.== 2)   sum(d)/length(d)\n\nlnhr1, ll1, g1, h1, bh1 = coxmodel(int, outt, d1, X, method=\"efron\");   lnhr2, ll2, g2, h2, bh2 = coxmodel(int, outt, d2, X, method=\"efron\");   bhlist = [bh1, bh2]   coeflist = [lnhr1, lnhr2]   covarmat = sum(X, dims=1) ./ size(X,1)   ci, surv = cifromcoxmodels(bhlist;eventtypes=[1,2], coeflist=coeflist, covarmat=covarmat)   ci, surv = cifromcoxmodels(bhlist;eventtypes=[1,2])\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.coxmodel-Tuple{Vector{<:Real}, Vector{<:Real}, Vector{<:Real}, Matrix{<:Real}}","page":"Home","title":"LSurvival.coxmodel","text":"Deprecated function\n\nEstimate parameters of an extended Cox model\n\nUsing: Newton raphson algorithm with modified/adaptive step sizes\n\nKeyword inputs: method=\"efron\",  inits=nothing , # initial parameter values, set to zero if this is nothing tol=10e-9,      #  convergence tolerance based on log likelihod: likrat = abs(lastLL/LL[1]), absdiff = abs(lastLL-LL[1]), reldiff = max(likrat, inv(likrat)) -1.0 maxiter=500    # maximum number of iterations for Newton Raphson algorithm (set to zero to calculate likelihood, gradient, Hessian at the initial parameter values)\n\nOutputs: beta: coefficients  ll: log partial likelihood history (all iterations), with final value being the (log) maximum partial likelihood (log-MPL) g: gradient vector (first derivative of log partial likelihood) at log-MPL h: hessian matrix (second derivative of log partial likelihood) at log-MPL basehaz: Matrix: baseline hazard at referent level of all covariates, weighted risk set size, weighted # of cases, time\n\nExamples: \n\n  using LSurvival\n  # simulating discrete survival data for 20 individuals at 10 time points\n  id, int, outt, data = LSurvival.dgm(20, 5;afun=LSurvival.int_0);\n  \n  d,X = data[:,4], data[:,1:3]\n  \n  # getting raw values of output\n  args = (int, outt, d, X)\n  beta, ll, g, h, basehaz = coxmodel(args..., method=\"efron\")\n  beta2, ll2, g2, h2, basehaz2 = coxmodel(args..., method=\"breslow\")\n\n\n  # nicer summary of results\n  args = (int, outt, d, X)\n  res = coxmodel(args..., method=\"efron\");\n  coxsum = cox_summary(res, alpha=0.05, verbose=true);\n    \n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.coxph-Tuple{Any, Any, Any, Any, Vararg{Any}}","page":"Home","title":"LSurvival.coxph","text":"fit for AbstractPH objects\n\n fit(::Type{M},\n X::AbstractMatrix,#{<:FP},\n enter::AbstractVector{<:Real},\n exit::AbstractVector{<:Real},\n y::Union{AbstractVector{<:Real},BitVector}\n ;\n ties =\"breslow\",\n wts::AbstractVector{<:Real}      = similar(y, 0),\n offset::AbstractVector{<:Real}   = similar(y, 0),\n fitargs...) where {M<:AbstractPH}\n ```\n\n ```{julia}\n using LSurvival\n using Random\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n X = hcat(x,rand(length(x)));\n  #R = LSurvResp(enter, t, Int.(d), wt)\n  #P = PHParms(X,\"efron\")\n  #mod = PHModel(R,P, true)\n  #_fit!(mod)\n m = fit(PHModel, X, enter, t, d, ties=\"efron\")\n m2 = fit(PHModel, X, enter, t, d, ties=\"breslow\")\n coeftable(m)\n ```\n\n ```{julia}\n using Random, LSurvival\n    id, int, outt, dat =\n        LSurvival.dgm(MersenneTwister(123123), 100, 100; afun = LSurvival.int_0)\n    data = (\n            int = int,\n            outt = outt,\n            d = dat[:,4] .== 1,\n            x = dat[:,1],\n            z = dat[:,2]\n    )\n\n    f = @formula(Surv(int, outt,d)~x+z)\n    coxph(f, data)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.coxph-Tuple{FormulaTerm, Any}","page":"Home","title":"LSurvival.coxph","text":"\n\n\n\n","category":"method"},{"location":"#LSurvival.dgm-Tuple{Any, Any, Any}","page":"Home","title":"LSurvival.dgm","text":"Generating discrete survival data without competing risks\n\nUsage: dgm(rng, n, maxT;afun=int0, yfun=yprob, lfun=lprob) dgm(n, maxT;afun=int0, yfun=yprob, lfun=lprob)\n\nWhere afun, yfun, and lfun are all functions that take arguments v,l,a and output time-specific values of a, y, and l respectively Example:\n\n\nexpit(mu) =  inv(1.0+exp(-mu))\n\nfunction aprob(v,l,a)\nexpit(-1.0 + 3*v + 2*l)\nend\n  \nfunction lprob(v,l,a)\nexpit(-3 + 2*v + 0*l + 0*a)\nend\n  \nfunction yprob(v,l,a)\nexpit(-3 + 2*v + 0*l + 2*a)\nend\n  # 10 individuals followed for up to 5 times\nLSurvival.dgm(10, 5;afun=aprob, yfun=yprob, lfun=lprob)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.dgm_comprisk-Tuple{Any, Any}","page":"Home","title":"LSurvival.dgm_comprisk","text":"Generating continuous survival data with competing risks\n\nUsage: dgmcomprisk(rng, n) dgmcomprisk(n)\n\n    - rng = random number generator    \n    - n = sample size\n\nExample:\n\nusing LSurvival\n    # 100 individuals with two competing events\nz,x,t,d,event,weights = LSurvival.dgm_comprisk(100)\n    \n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.e_yearsoflifelost-Tuple{Any, Any}","page":"Home","title":"LSurvival.e_yearsoflifelost","text":"Deprecated function\n\nExpected number of years of life lost due to cause k\n\nusing Distributions, Plots, Random\nplotly()\nz,x,t,d, event,weights = dgm_comprisk(n=200, rng=MersenneTwister(1232));\n  \ntimes_sd, cumhaz, ci_sd = subdistribution_hazard_cuminc(zeros(length(t)), t, event, dvalues=[1.0, 2.0]);\ntimes_aj, S, ajest, riskset, events = aalen_johansen(zeros(length(t)), t, event, dvalues=[1.0, 2.0]);\ntime0, eyll0 = e_yearsoflifelost(times_aj, 1.0 .- S)  \ntime2, eyll1 = e_yearsoflifelost(times_aj, ajest[:,1])  \ntime1, eyll2 = e_yearsoflifelost(times_sd, ci_sd)  \n  # CI estimates\nplot(times_aj, ajest[:,1], label=\"AJ\", st=:step);\nplot!(times_sd, ci_sd, label=\"SD\", st=:step)  \n  # expected years of life lost by time k, given a specific cause or overall\nplot(time0, eyll0, label=\"Overall\", st=:step);\nplot!(time1, eyll1, label=\"AJ\", st=:step);\nplot!(time2, eyll2, label=\"SD\", st=:step) \n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.kaplan_meier-Tuple{Any, Any, Any, Vararg{Any}}","page":"Home","title":"LSurvival.kaplan_meier","text":"fit for KMSurv objects\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\nm = fit(KMSurv, enter, t, d)\nmw = fit(KMSurv, enter, t, d, wts=wt)\n\nor, equivalently:\n\nkaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; <keyword arguments>)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.km-Tuple{Any, Any, Any}","page":"Home","title":"LSurvival.km","text":"Deprecated function\n\nKaplan Meier with late entry, possibly multiple observations per unit (simple function)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.km-Tuple{Any, Any}","page":"Home","title":"LSurvival.km","text":"Deprecated function\n\nKaplan Meier for one observation per unit and no late entry   (simple function)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lgh!-NTuple{12, Any}","page":"Home","title":"LSurvival.lgh!","text":"Deprecated function\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lgh_breslow!-NTuple{12, Any}","page":"Home","title":"LSurvival.lgh_breslow!","text":"Deprecated function\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lgh_breslow!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M<:AbstractPH","page":"Home","title":"LSurvival.lgh_breslow!","text":"lgh_breslow!(_den, _LL, _grad, _hess, j, p, Xcases, Xriskset, _rcases, _rriskset, _wtcases, _wtriskset)\n\nfor a given risk set\n\n#compute log-likelihood, gradient vector and hessian matrix of cox model given individual level contriubtions\n\nXcases=X[caseidx,:]\nXriskset=X[risksetidx,:]\n _rcases = _r[caseidx]\n _rriskset = _r[risksetidx]\n \n _wtcases=_wt[caseidx]\n _wtriskset=_wt[risksetidx]\np = size(X,2)\nj = 1\n _LL = [0.0]\n _grad = zeros(p)\n _hess = zeros(p,p)\n _den = zeros(j)\nlgh_breslow!(_den, _LL, _grad, _hess, j, p, Xcases, Xriskset, _rcases, _rriskset, _wtcases, _wtriskset)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lgh_efron!-NTuple{13, Any}","page":"Home","title":"LSurvival.lgh_efron!","text":"Deprecated function\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lgh_efron!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M<:AbstractPH","page":"Home","title":"LSurvival.lgh_efron!","text":"lgh_efron!(_den, _LL, _grad, _hess, j, p, Xcases, X, _rcases, _r, _wtcases, _wt, caseidx, risksetidx)\n\n# for a given risk set\n#compute log-likelihood, gradient vector and hessian matrix of cox model given individual level contriubtions\nXcases=X[caseidx,:]\nXriskset=X[risksetidx,:]\n_rcases = _r[caseidx]\n_rriskset = _r[risksetidx]\n\n_wtcases=_wt[caseidx]\n_wtriskset=_wt[risksetidx]\np = size(X,2)\nj = 1\n_LL = [0.0]\n_grad = zeros(p)\n_hess = zeros(p,p)\n_den = zeros(j)\nlgh_efron!(_den, _LL, _grad, _hess, j, p, Xcases, X, _rcases, _r, _wtcases, _wt, caseidx, risksetidx)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.risk_from_coxphmodels-Union{Tuple{T}, Tuple{Array{T}, Vararg{Any}}} where T<:PHModel","page":"Home","title":"LSurvival.risk_from_coxphmodels","text":"Survival curve estimation using multiple cox models (sometimes referred to as a multi-state model)\n\nFunction signatures\n\nrisk_from_coxphmodels(fitlist::Array{T}, args...; kwargs...) where {T<:PHModel}\n\nfit(::Type{M}, fitlist::Vector{<:T}, ; fitargs...) where {M<:PHSurv,T<:PHModel}\n\nOptional keywords\n\ncoef_vectors = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]\npredprofile = nothing(default) or vector of specific predictor values of the same length as the coefvectors[1]\n\n \n using LSurvival\n using Random\n # event variable is coded 0[referent],1,2\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n\n ft1 = coxph(hcat(x,z), enter, t, (event .== 1))\n nidx = findall(event .!= 1)\n ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))\n\n # risk at referent levels of `x` and `z`\n risk_from_coxphmodels([ft1,ft2])\n\n # risk at average levels of `x` and `z`\n mnx = sum(x)/length(x)\n mnz = sum(z)/length(z)\n risk_from_coxphmodels([ft1,ft2], coef_vectors=[coef(ft1), coef(ft2)], pred_profile=[mnx,mnz])\n\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.subdistribution_hazard_cuminc-Tuple{Any, Any, Any}","page":"Home","title":"LSurvival.subdistribution_hazard_cuminc","text":"Deprecated function\n\nNon-parametric sub-distribution hazard estimator   estimating cumulative incidence via the subdistribution hazard function\n\nUsage: subdistributionhazardcuminc(in,out,d;dvalues=[1.0, 2.0], weights=nothing, eps = 0.00000001)\n\nin = time at entry (numeric vector)\nout = time at exit (numeric vector)\nd = event indicator (numeric or boolean vector)\n\nkeywords:\n\ndvalues = (default = [1.0, 2.0]) a vector of the unique values of 'd' that indicate event types. By default, d is expected to take on values 0.0,1.0,2.0 for 3 event types (censored, event type 1, event type 2)\nweights = vector of observation weights, or nothing (default)\neps = (default = 0.00000001) very small numeric value that helps in case of tied times that become misordered due to floating point errors\n\nOutput: tuple with entries\n\ntimes: unique event times\ncumhaz: cumulative subdistrution hazard for each event type\nci: Subdistrution hazard estimators of cumulative incidence for each event type. 1-sum of the CI for all event types is equal to overall survival.\nevents: number of events of each type used in calculating survival and cumulative incidence at each event time\nnames: vector of symbols [:times, :cumhaz, :ci] used as a mnemonic for the function output\n\nNote:    For time specific subdistribution hazard given by 'sdhaz(t)', the cumulative incidence for a specific event type calculated over time is \n\n1.0 .- exp.(.-cumsum(sdhaz(t)))\n\nExamples: \n\n  using LSurvival, Random\n\n  z,x,t,d, event,weights = LSurvival.dgm_comprisk(1000);\n  \n  # compare these two approaches, where Aalen-Johansen method requires having cause specific hazards for every event type\n  times_sd, cumhaz, ci_sd = subdistribution_hazard_cuminc(zeros(length(t)), t, event, dvalues=[1.0, 2.0]);\n  times_aj, surv, ajest, riskset, events = aalen_johansen(zeros(length(t)), t, event, dvalues=[1.0, 2.0]);\n  \n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.confint-Tuple{AJSurv}","page":"Home","title":"StatsAPI.confint","text":"Greenwood's formula for variance and confidence intervals of a Aalen-Johansen risk function\n\nres = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)\nint = zeros(length(d)) # no late entry\nm = fit(AJSurv, int, outt, event)\nstderror(m)\nconfint(m, level=0.95)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.confint-Tuple{KMSurv}","page":"Home","title":"StatsAPI.confint","text":"Greenwood's formula for variance and confidence intervals of a Kaplan-Meier survival curve\n\nStatsBase.stderror(m::KMSurv)\n\nStatsBase.confint(m:KMSurv; level=0.95, method=\"normal\")\n\nmethod:\n\n\"normal\" normality-based confidence intervals\n\"lognlog\" log(-log(S(t))) based confidence intervals\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\nm = fit(KMSurv, enter, t, d)\nmw = fit(KMSurv, enter, t, d, wts=wt)\nstderror(m)\nconfint(m, method=\"normal\")\nconfint(m, method=\"lognlog\") # log-log transformation\n\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit!-Tuple{T} where T<:AbstractNPSurv","page":"Home","title":"StatsAPI.fit!","text":"fit for KMSurv objects\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\nm = fit(KMSurv, enter, t, d)\nmw = fit(KMSurv, enter, t, d, wts=wt)\n\nor, equivalently:\n\nkaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; <keyword arguments>)\n\nAalen-Johansen estimator for cumulative risk\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\n   # event variable is coded 0[referent],1,2\nm = fit(AJSurv, enter, t, event)\nmw = fit(AJSurv, enter, t, event, wts=wt)\n\nor, equivalently:\n\naalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; <keyword arguments>)\n\nSurvival curve estimation using multiple cox models (sometimes referred to as a multi-state model)\n\nFunction signatures\n\nrisk_from_coxphmodels(fitlist::Array{T}, args...; kwargs...) where {T<:PHModel}\n\nfit(::Type{M}, fitlist::Vector{<:T}, ; fitargs...) where {M<:PHSurv,T<:PHModel}\n\nOptional keywords\n\ncoef_vectors = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]\npredprofile = nothing(default) or vector of specific predictor values of the same length as the coefvectors[1]\n\n \n using LSurvival\n using Random\n # event variable is coded 0[referent],1,2\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n\n ft1 = coxph(hcat(x,z), enter, t, (event .== 1))\n nidx = findall(event .!= 1)\n ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))\n\n # risk at referent levels of `x` and `z`\n risk_from_coxphmodels([ft1,ft2])\n\n # risk at average levels of `x` and `z`\n mnx = sum(x)/length(x)\n mnz = sum(z)/length(z)\n risk_from_coxphmodels([ft1,ft2], coef_vectors=[coef(ft1), coef(ft2)], pred_profile=[mnx,mnz])\n\n\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{T}, Tuple{M}, Tuple{Type{M}, Vector{<:T}}} where {M<:PHSurv, T<:PHModel}","page":"Home","title":"StatsAPI.fit","text":"Survival curve estimation using multiple cox models (sometimes referred to as a multi-state model)\n\nFunction signatures\n\nrisk_from_coxphmodels(fitlist::Array{T}, args...; kwargs...) where {T<:PHModel}\n\nfit(::Type{M}, fitlist::Vector{<:T}, ; fitargs...) where {M<:PHSurv,T<:PHModel}\n\nOptional keywords\n\ncoef_vectors = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]\npredprofile = nothing(default) or vector of specific predictor values of the same length as the coefvectors[1]\n\n \n using LSurvival\n using Random\n # event variable is coded 0[referent],1,2\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n\n ft1 = coxph(hcat(x,z), enter, t, (event .== 1))\n nidx = findall(event .!= 1)\n ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))\n\n # risk at referent levels of `x` and `z`\n risk_from_coxphmodels([ft1,ft2])\n\n # risk at average levels of `x` and `z`\n mnx = sum(x)/length(x)\n mnz = sum(z)/length(z)\n risk_from_coxphmodels([ft1,ft2], coef_vectors=[coef(ft1), coef(ft2)], pred_profile=[mnx,mnz])\n\n\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Matrix{<:Real}, Vector{<:Real}, Vector{<:Real}, Y}} where {M<:AbstractPH, Y<:Union{BitVector, Vector{<:Real}}}","page":"Home","title":"StatsAPI.fit","text":"fit for AbstractPH objects\n\n fit(::Type{M},\n X::AbstractMatrix,#{<:FP},\n enter::AbstractVector{<:Real},\n exit::AbstractVector{<:Real},\n y::Union{AbstractVector{<:Real},BitVector}\n ;\n ties =\"breslow\",\n wts::AbstractVector{<:Real}      = similar(y, 0),\n offset::AbstractVector{<:Real}   = similar(y, 0),\n fitargs...) where {M<:AbstractPH}\n ```\n\n ```{julia}\n using LSurvival\n using Random\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n X = hcat(x,rand(length(x)));\n  #R = LSurvResp(enter, t, Int.(d), wt)\n  #P = PHParms(X,\"efron\")\n  #mod = PHModel(R,P, true)\n  #_fit!(mod)\n m = fit(PHModel, X, enter, t, d, ties=\"efron\")\n m2 = fit(PHModel, X, enter, t, d, ties=\"breslow\")\n coeftable(m)\n ```\n\n ```{julia}\n using Random, LSurvival\n    id, int, outt, dat =\n        LSurvival.dgm(MersenneTwister(123123), 100, 100; afun = LSurvival.int_0)\n    data = (\n            int = int,\n            outt = outt,\n            d = dat[:,4] .== 1,\n            x = dat[:,1],\n            z = dat[:,2]\n    )\n\n    f = @formula(Surv(int, outt,d)~x+z)\n    coxph(f, data)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{<:Real}, Vector{<:Real}, Y}} where {M<:AJSurv, Y<:Union{BitVector, Vector{<:Real}}}","page":"Home","title":"StatsAPI.fit","text":"Aalen-Johansen estimator for cumulative risk\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\n   # event variable is coded 0[referent],1,2\nm = fit(AJSurv, enter, t, event)\nmw = fit(AJSurv, enter, t, event, wts=wt)\n\nor, equivalently:\n\naalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; <keyword arguments>)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{<:Real}, Vector{<:Real}, Y}} where {M<:KMSurv, Y<:Union{BitVector, Vector{<:Real}}}","page":"Home","title":"StatsAPI.fit","text":"fit for KMSurv objects\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\nm = fit(KMSurv, enter, t, d)\nmw = fit(KMSurv, enter, t, d, wts=wt)\n\nor, equivalently:\n\nkaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; <keyword arguments>)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.stderror-Tuple{AJSurv}","page":"Home","title":"StatsAPI.stderror","text":"Greenwood's formula for variance and confidence intervals of a Aalen-Johansen risk function\n\nres = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)\nint = zeros(length(d)) # no late entry\nm = fit(AJSurv, int, outt, event)\nstderror(m)\nconfint(m, level=0.95)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.stderror-Tuple{KMSurv}","page":"Home","title":"StatsAPI.stderror","text":"Greenwood's formula for variance and confidence intervals of a Kaplan-Meier survival curve\n\nStatsBase.stderror(m::KMSurv)\n\nStatsBase.confint(m:KMSurv; level=0.95, method=\"normal\")\n\nmethod:\n\n\"normal\" normality-based confidence intervals\n\"lognlog\" log(-log(S(t))) based confidence intervals\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\nm = fit(KMSurv, enter, t, d)\nmw = fit(KMSurv, enter, t, d, wts=wt)\nstderror(m)\nconfint(m, method=\"normal\")\nconfint(m, method=\"lognlog\") # log-log transformation\n\n\n\n\n\n\n","category":"method"}]
}
