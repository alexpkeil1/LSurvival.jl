var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = LSurvival=","category":"page"},{"location":"#[LSurvival](https://github.com/alexpkeil1/LSurvival.jl)","page":"Home","title":"LSurvival","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Survival analysis functions in Julia for time-to-event outcomes that can include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Loss-to-follow-up/right censoring\nLate entry/left truncation (not available in Survival.jl)\n\"Person-period\" data structures (not available in Survival.jl)\nObservation weights (not available in Survival.jl)\nCompeting risks (not available in Survival.jl)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Capabilities include estimators for","category":"page"},{"location":"","page":"Home","title":"Home","text":"Kaplan-Meier non-parametric conditional risk functions\nAalen-Johansen non-parametric cause-specific unconditional risk functions\nCox proportional hazards model (Efron's or Breslow's methods for ties)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Convenience functions enable:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Non-parametric bootstrapping, cluster-bootstrapping\nEstimating baseline hazards from a Cox Model\nEstimating cause-specific risk from an exhaustive set of Cox models for competing risk outcomes\nSimple simulation of competing and non-competing survival events\nCluster robust variance estimation (without bootstrapping)\nMartingale, score, Schoenfeld, and dfbeta residuals\nCluster robust variance estimation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Plans to include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Parametric survival models\nStratification in Cox models","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package has been tuned to follow the \"survival\" package from R in terms of specific estimators/results.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Report issues here","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(url = \"https://github.com/alexpkeil1/LSurvival.jl\")","category":"page"},{"location":"#Quick-examples","page":"Home","title":"Quick examples","text":"","category":"section"},{"location":"#Single-event-type:-Cox-model-and-Kaplan-Meier-curve","page":"Home","title":"Single event type: Cox model and Kaplan-Meier curve","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Random, LSurvival, Distributions, LinearAlgebra\n\n# generate some data under a discrete hazards model\nexpit(mu) = inv(1.0 + exp(-mu))\n\nfunction dgm(rng, n, maxT; regimefun = int_0)\n    V = rand(rng, n)\n    LAY = Array{Float64,2}(undef, n * maxT, 4)\n    keep = ones(Bool, n * maxT)\n    id = sort(reduce(vcat, fill(collect(1:n), maxT)))\n    time = (reduce(vcat, fill(collect(1:maxT), n)))\n    for i = 1:n\n        v = V[i]\n        l = 0\n        a = 0\n        lkeep = true\n        for t = 1:maxT\n            currIDX = (i - 1) * maxT + t\n            l = expit(-3 + 2 * v + 0 * l + 0 * a) > rand(rng) ? 1 : 0\n            a = 0.1 > rand(rng) ? 1 : 0\n            y = expit(-3 + 2 * v + 0 * l + 2 * a) > rand(rng) ? 1 : 0\n            LAY[currIDX, :] .= [v, l, a, y]\n            keep[currIDX] = lkeep\n            lkeep = (!lkeep || (y == 1)) ? false : true\n        end\n    end\n    id[findall(keep)], time[findall(keep)] .- 1, time[findall(keep)], LAY[findall(keep), :]\nend\n\nid, int, outt, data = dgm(MersenneTwister(), 1000, 10; regimefun = int_0)\ndata[:, 1] = round.(data[:, 1], digits = 3)\nd, X = data[:, 4], data[:, 1:3]\nwt = rand(length(d)) # random weights just to demonstrate usage\n\n# Cox model\n# Breslow's partial likelihood\nm = fit(PHModel, X, int, outt, d, ties = \"breslow\", wts = wt)\n\n# Efron's partial likelihood\nm2 = fit(PHModel, X, int, outt, d, ties = \"efron\", wts = wt)\n\n#equivalent way to specify \n# using `coxph` function\nm2b = coxph(X, int, outt, d, ties = \"efron\", wts = wt)\n\n# using `coxph` function with `Tables.jl` and `StatsAPI.@formula` interface (similar to GLM.jl)\ntab = ( in = int, out = out, d=d, x=X[:,1], z1=X[:,2], z2=X[:,3]) # can also be a DataFrame from DataFrames.jl\nm2b = coxph(@formula(Surv(in, out, d)~x+z1+z2), ties = \"efron\", wts = wt)\n\n# can also be done if there is no late entry\nm2b = coxph(@formula(Surv(out, d)~x+z1+z2), ties = \"efron\", wts = wt)\n# can also be done if there is no late entry and no right censoring (i.e. all times are failure times)\nm2b = coxph(@formula(Surv(out)~x+z1+z2), ties = \"efron\", wts = wt)\n\n\n\n# Kaplan-Meier estimator of the cumulative risk/survival\nres = kaplan_meier(int, outt, d)","category":"page"},{"location":"#Competing-event-analysis:-Aalen-Johansen-and-Cox-model-based-estimators-of-the-cumulative-risk/survival","page":"Home","title":"Competing event analysis: Aalen-Johansen and Cox-model-based estimators of the cumulative risk/survival","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Random, LSurvival, Distributions, LinearAlgebra\n\n# simulate some data\nfunction dgm_comprisk(; n = 100, rng = MersenneTwister())\n    z = rand(rng, n) .* 5\n    x = rand(rng, n) .* 5\n    dt1 = Weibull.(fill(0.75, n), inv.(exp.(-x .- z)))\n    dt2 = Weibull.(fill(0.75, n), inv.(exp.(-x .- z)))\n    t01 = rand.(rng, dt1)\n    t02 = rand.(rng, dt2)\n    t0 = min.(t01, t02)\n    t = Array{Float64,1}(undef, n)\n    for i = 1:n\n        t[i] = t0[i] > 1.0 ? 1.0 : t0[i]\n    end\n    d = (t .== t0)\n    event = (t .== t01) .+ 2.0 .* (t .== t02)\n    wtu = rand(rng, n) .* 5.0\n    wt = wtu ./ mean(wtu)\n    reshape(round.(z, digits = 4), (n, 1)),\n    reshape(round.(x, digits = 4), (n, 1)),\n    round.(t, digits = 4),\n    d,\n    event,\n    round.(wt, digits = 4)\nend\n\nz, x, t, d, event, wt = dgm_comprisk(; n = 100, rng = MersenneTwister(12))\nX = hcat(x,z)\nenter = t .* rand(length(d))*0.02 # create some fake entry times\n\n# Aalen-Johansen estimator: marginal cause-specific risks\nres_aj = aalen_johansen(enter, t, event; wts = wt);\nres_aj\n\n# Cox-model estimator: cause-specific risks at given levels of covariates\nfit1 = fit(PHModel, X, enter, t, (event .== 1), ties = \"efron\",  wts = wt)\n#n2idx = findall(event .!= 1)\nn2idx = findall(event .> -1)\nfit2 = fit(PHModel, X[n2idx,:], enter[n2idx], t[n2idx], (event[n2idx] .== 2), ties = \"breslow\",  wts = wt[n2idx])\n\n# risk at referent levels of `x` and `z` (can be very extreme if referent levels are unlikely/unobservable)\nres_cph_ref = risk_from_coxphmodels([fit1,fit2])\n\n# risk at average levels of `x` and `z`\nmnx = sum(x)/length(x)\nmnz = sum(z)/length(z)\nres_cph = risk_from_coxphmodels([fit1,fit2], coef_vectors=[coef(ft1), coef(ft2)], pred_profile=mean(X, dims=1))\n# compare to Aalen-Johansen fit\nres_aj\n\n\n# this approach operates on left censored outcomes (which operate in the background in model fitting)\nLSurvivalResp(enter, t, d, origintime=0)\nLSurvivalCompResp(enter, t, event) # automatically infers origin\n\n\n# can use the ID type to refer to units with multiple observations\nid, int, outt, data = dgm(MersenneTwister(), 1000, 10; regimefun = int_0)\nLSurvivalResp(int, outt, data[:,4], ID.(id))","category":"page"},{"location":"#Index-of-functions","page":"Home","title":"Index of functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Function-help","page":"Home","title":"Function help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [LSurvival]","category":"page"},{"location":"#LSurvival.AbstractLSurvivalParms","page":"Home","title":"LSurvival.AbstractLSurvivalParms","text":"AbstractLsurvParms\n\nAbstract type representing a model predictors and coefficient parameters\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractLSurvivalResp","page":"Home","title":"LSurvival.AbstractLSurvivalResp","text":"AbstractLsurvResp\n\nAbstract type representing a model response vector\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractNPSurv","page":"Home","title":"LSurvival.AbstractNPSurv","text":"Abstract type for non-parametric survival models, including Kaplan-Meier, Aalen Johansen, and Cox-model based estimates of survival using an Aalen-Johansen-like estimator\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractPH","page":"Home","title":"LSurvival.AbstractPH","text":"Abstract type for proportional hazards models\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.ID","page":"Home","title":"LSurvival.ID","text":"Type for identifying individuals in survival outcomes.\n\nUsed for the id argument in \n\nOutcome types: LSurvivalResp, LSurvivalCompResp \nModel types: PHModel, KMRisk, AJRisk\n\nAccepts any Number or String. There is no significance to having this particular struct, but it enables easier use of multiple dispatch.\n\n [ID(i) for i in 1:10]\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.LSurvivalCompResp","page":"Home","title":"LSurvival.LSurvivalCompResp","text":"Outcome type for competing risk survival outcomes subject to left truncation and right censoring (not generally needed for users)\n\nParameters\n\nenter Time at observation start\nexit Time at observation end\ny event occurrence in observation\nwts observation weights\neventtimes unique event times\norigin origin on the time scale\nid person level identifier (must be wrapped in ID() function)\neventtypes vector of unique event types\neventmatrix matrix of indicators on the observation level\n\nSignatures:\n\n struct LSurvivalCompResp{\n E<:AbstractVector,\n X<:AbstractVector,\n Y<:AbstractVector,\n W<:AbstractVector,\n T<:Real,\n I<:AbstractLSurvivalID,\n V<:AbstractVector,\n M<:AbstractMatrix,\n } <: AbstractLSurvivalResp\n enter::E\n exit::X\n y::Y\n wts::W\n eventtimes::X\n origin::T\n id::Vector{I}\n eventtypes::V\n eventmatrix::M\n end\n\n LSurvivalCompResp(\n enter::E,\n exit::X,\n y::Y,\n wts::W,\n id::Vector{I}\n )\n\n LSurvivalCompResp(\n enter::E,\n exit::X,\n y::Y,\n id::Vector{I}\n )\n\n LSurvivalCompResp(\n enter::E,\n exit::X,\n y::Y,\n wts::W,\n )\n\n LSurvivalCompResp(\n enter::E,\n exit::X,\n y::Y,\n )\n\n LSurvivalCompResp(\n  exit::X,\n  y::Y,\n) where {X<:Vector,Y<:Union{Vector{<:Real},BitVector}}\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.LSurvivalResp","page":"Home","title":"LSurvival.LSurvivalResp","text":"Outcome type for survival outcome subject to left truncation and right censoring. \n\nWill not generally be needed by users\n\nParameters\n\nenter: Time at observation start\nexit: Time at observation end\ny: event occurrence in observation\nwts: observation weights\neventtimes: unique event times\norigin: origin on the time scale\nid: person level identifier (must be wrapped in ID() function)\n\n struct LSurvivalResp{\n E<:AbstractVector,\n X<:AbstractVector,\n Y<:AbstractVector,\n W<:AbstractVector,\n T<:Real,\n I<:AbstractLSurvivalID,\n } <: AbstractLSurvivalResp\n enter::E\n exit::X\n y::Y\n wts::W\n eventtimes::E\n origin::T\n id::Vector{I}\n end\n\n\n LSurvivalResp(\n    enter::E,\n    exit::X,\n    y::Y,\n    wts::W,\n    id::Vector{I},\n) where {\n    E<:Vector,\n    X<:Vector,\n    Y<:Union{Vector{<:Real},BitVector},\n    W<:Vector,\n    I<:AbstractLSurvivalID,\n}\n\n LSurvivalResp(\n enter::E,\n exit::X,\n y::Y,\n id::Vector{I},\n ) \n\n\n LSurvivalResp(\n  y::Vector{Y},\n  wts::W,\n  id::Vector{I},\n) where {Y<:AbstractSurvTime,W<:Vector,I<:AbstractLSurvivalID}\n\n LSurvivalResp(\n  enter::E,\n  exit::X,\n  y::Y,\n) where {E<:Vector,X<:Vector,Y<:Union{Vector{<:Real},BitVector}}\n\n LSurvivalResp(exit::X, y::Y) where {X<:Vector,Y<:Vector}\n\nExamples\n\n# no late entry\nLSurvivalResp([.5, .6], [1,0])\n\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.PHModel","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression (not generally needed for users)\n\nParameters\n\nR Survival response\nP        # parameters\nties String: \"efron\" or \"breslow\"\nfit Bool: logical for whether the model has been fitted\nbh AbstractMatrix: baseline hazard estimates\n\nSignatures\n\n mutable struct PHModel{G<:LSurvivalResp,L<:AbstractLSurvivalParms} <: AbstractPH\n R::G        # Survival response\n P::L        # parameters\n ties::String #\"efron\" or\"breslow\"\n fit::Bool\n bh::AbstractMatrix\n end\n\n PHModel(\n R::G,\n P::L,\n ties::String,\n fit::Bool,\n ) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n PHModel(R::G, P::L, ties::String) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n PHModel(R::G, P::L) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n\nMethods: fit, coef, confint, std_err, show\n\nExample\n\n using LSurvival\n using Random\n import LSurvival: _stepcox!, dgm_comprisk\n\n z,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\n enter = zeros(length(t));\n X = hcat(x,z);\n R = LSurvivalResp(enter, t, Int.(d), wt)\n P = PHParms(X)\n mf = PHModel(R,P)\n  LSurvival._fit!(mf)\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L, String}} where {G<:LSurvivalResp, L<:AbstractLSurvivalParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression (not generally needed for users)\n\nParameters\n\nR Survival response\nP        # parameters\nties String: \"efron\" or \"breslow\"\nfit Bool: logical for whether the model has been fitted\nbh AbstractMatrix: baseline hazard estimates\n\nSignatures\n\n mutable struct PHModel{G<:LSurvivalResp,L<:AbstractLSurvivalParms} <: AbstractPH\n R::G        # Survival response\n P::L        # parameters\n ties::String #\"efron\" or\"breslow\"\n fit::Bool\n bh::AbstractMatrix\n end\n\n PHModel(\n R::G,\n P::L,\n ties::String,\n fit::Bool,\n ) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n PHModel(R::G, P::L, ties::String) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n PHModel(R::G, P::L) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n\nMethods: fit, coef, confint, std_err, show\n\nExample\n\n using LSurvival\n using Random\n import LSurvival: _stepcox!, dgm_comprisk\n\n z,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\n enter = zeros(length(t));\n X = hcat(x,z);\n R = LSurvivalResp(enter, t, Int.(d), wt)\n P = PHParms(X)\n mf = PHModel(R,P)\n  LSurvival._fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L, Union{Nothing, FormulaTerm}, String, Bool, Matrix{Float64}}} where {G<:LSurvivalResp, L<:AbstractLSurvivalParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression (not generally needed for users)\n\nParameters\n\nR Survival response\nP        # parameters\nties String: \"efron\" or \"breslow\"\nfit Bool: logical for whether the model has been fitted\nbh AbstractMatrix: baseline hazard estimates\n\nSignatures\n\n mutable struct PHModel{G<:LSurvivalResp,L<:AbstractLSurvivalParms} <: AbstractPH\n R::G        # Survival response\n P::L        # parameters\n ties::String #\"efron\" or\"breslow\"\n fit::Bool\n bh::AbstractMatrix\n end\n\n PHModel(\n R::G,\n P::L,\n ties::String,\n fit::Bool,\n ) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n PHModel(R::G, P::L, ties::String) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n PHModel(R::G, P::L) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n\nMethods: fit, coef, confint, std_err, show\n\nExample\n\n using LSurvival\n using Random\n import LSurvival: _stepcox!, dgm_comprisk\n\n z,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\n enter = zeros(length(t));\n X = hcat(x,z);\n R = LSurvivalResp(enter, t, Int.(d), wt)\n P = PHParms(X)\n mf = PHModel(R,P)\n  LSurvival._fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L, Union{Nothing, FormulaTerm}, String, Bool}} where {G<:LSurvivalResp, L<:AbstractLSurvivalParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression (not generally needed for users)\n\nParameters\n\nR Survival response\nP        # parameters\nties String: \"efron\" or \"breslow\"\nfit Bool: logical for whether the model has been fitted\nbh AbstractMatrix: baseline hazard estimates\n\nSignatures\n\n mutable struct PHModel{G<:LSurvivalResp,L<:AbstractLSurvivalParms} <: AbstractPH\n R::G        # Survival response\n P::L        # parameters\n ties::String #\"efron\" or\"breslow\"\n fit::Bool\n bh::AbstractMatrix\n end\n\n PHModel(\n R::G,\n P::L,\n ties::String,\n fit::Bool,\n ) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n PHModel(R::G, P::L, ties::String) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n PHModel(R::G, P::L) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n\nMethods: fit, coef, confint, std_err, show\n\nExample\n\n using LSurvival\n using Random\n import LSurvival: _stepcox!, dgm_comprisk\n\n z,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\n enter = zeros(length(t));\n X = hcat(x,z);\n R = LSurvivalResp(enter, t, Int.(d), wt)\n P = PHParms(X)\n mf = PHModel(R,P)\n  LSurvival._fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L, Union{Nothing, FormulaTerm}, String}} where {G<:LSurvivalResp, L<:AbstractLSurvivalParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression (not generally needed for users)\n\nParameters\n\nR Survival response\nP        # parameters\nties String: \"efron\" or \"breslow\"\nfit Bool: logical for whether the model has been fitted\nbh AbstractMatrix: baseline hazard estimates\n\nSignatures\n\n mutable struct PHModel{G<:LSurvivalResp,L<:AbstractLSurvivalParms} <: AbstractPH\n R::G        # Survival response\n P::L        # parameters\n ties::String #\"efron\" or\"breslow\"\n fit::Bool\n bh::AbstractMatrix\n end\n\n PHModel(\n R::G,\n P::L,\n ties::String,\n fit::Bool,\n ) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n PHModel(R::G, P::L, ties::String) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n PHModel(R::G, P::L) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n\nMethods: fit, coef, confint, std_err, show\n\nExample\n\n using LSurvival\n using Random\n import LSurvival: _stepcox!, dgm_comprisk\n\n z,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\n enter = zeros(length(t));\n X = hcat(x,z);\n R = LSurvivalResp(enter, t, Int.(d), wt)\n P = PHParms(X)\n mf = PHModel(R,P)\n  LSurvival._fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L, Union{Nothing, FormulaTerm}}} where {G<:LSurvivalResp, L<:AbstractLSurvivalParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression (not generally needed for users)\n\nParameters\n\nR Survival response\nP        # parameters\nties String: \"efron\" or \"breslow\"\nfit Bool: logical for whether the model has been fitted\nbh AbstractMatrix: baseline hazard estimates\n\nSignatures\n\n mutable struct PHModel{G<:LSurvivalResp,L<:AbstractLSurvivalParms} <: AbstractPH\n R::G        # Survival response\n P::L        # parameters\n ties::String #\"efron\" or\"breslow\"\n fit::Bool\n bh::AbstractMatrix\n end\n\n PHModel(\n R::G,\n P::L,\n ties::String,\n fit::Bool,\n ) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n PHModel(R::G, P::L, ties::String) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n PHModel(R::G, P::L) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n\nMethods: fit, coef, confint, std_err, show\n\nExample\n\n using LSurvival\n using Random\n import LSurvival: _stepcox!, dgm_comprisk\n\n z,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\n enter = zeros(length(t));\n X = hcat(x,z);\n R = LSurvivalResp(enter, t, Int.(d), wt)\n P = PHParms(X)\n mf = PHModel(R,P)\n  LSurvival._fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHModel-Union{Tuple{L}, Tuple{G}, Tuple{Union{Nothing, G}, L}} where {G<:LSurvivalResp, L<:AbstractLSurvivalParms}","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression (not generally needed for users)\n\nParameters\n\nR Survival response\nP        # parameters\nties String: \"efron\" or \"breslow\"\nfit Bool: logical for whether the model has been fitted\nbh AbstractMatrix: baseline hazard estimates\n\nSignatures\n\n mutable struct PHModel{G<:LSurvivalResp,L<:AbstractLSurvivalParms} <: AbstractPH\n R::G        # Survival response\n P::L        # parameters\n ties::String #\"efron\" or\"breslow\"\n fit::Bool\n bh::AbstractMatrix\n end\n\n PHModel(\n R::G,\n P::L,\n ties::String,\n fit::Bool,\n ) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n PHModel(R::G, P::L, ties::String) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n PHModel(R::G, P::L) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n\nMethods: fit, coef, confint, std_err, show\n\nExample\n\n using LSurvival\n using Random\n import LSurvival: _stepcox!, dgm_comprisk\n\n z,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\n enter = zeros(length(t));\n X = hcat(x,z);\n R = LSurvivalResp(enter, t, Int.(d), wt)\n P = PHParms(X)\n mf = PHModel(R,P)\n  LSurvival._fit!(mf)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHSurv","page":"Home","title":"LSurvival.PHSurv","text":"Mutable type for proportional hazards models (not generally needed by users)\n\nPHSsurv: Object type for proportional hazards regression\n\nsurv::Vector{Float64}  risk::Matrix{Float64}  basehaz::Vector{Float64}  event::Vector{Float64}\n\nfitlist: vector of PHSurv objects (Cox model fits)\neventtypes: vector of unique event types\ntimes: unique event times\nsurv: Overall survival at each time\nrisk: Cause-specific risk  at each time (1 for each outcome type)\nbasehaz: baseline hazard for a specific event type\nevent: value of event type that occurred at each time\n\nMethods: fit, show\n\n mutable struct PHSurv{G<:Array{T} where {T<:PHModel}} <: AbstractNPSurv\n fitlist::G        \n eventtypes::AbstractVector\n times::AbstractVector\n surv::Vector{Float64}\n risk::Matrix{Float64}\n basehaz::Vector{Float64}\n event::Vector{Float64}\n end\n\n PHSurv(fitlist::Array{T}, eventtypes) where {T<:PHModel}\n PHSurv(fitlist::Array{T}) where {T<:PHModel}\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.PHSurv-Union{Tuple{Array{T}}, Tuple{T}} where T<:PHModel","page":"Home","title":"LSurvival.PHSurv","text":"Mutable type for proportional hazards models (not generally needed by users)\n\nPHSsurv: Object type for proportional hazards regression\n\nsurv::Vector{Float64}  risk::Matrix{Float64}  basehaz::Vector{Float64}  event::Vector{Float64}\n\nfitlist: vector of PHSurv objects (Cox model fits)\neventtypes: vector of unique event types\ntimes: unique event times\nsurv: Overall survival at each time\nrisk: Cause-specific risk  at each time (1 for each outcome type)\nbasehaz: baseline hazard for a specific event type\nevent: value of event type that occurred at each time\n\nMethods: fit, show\n\n mutable struct PHSurv{G<:Array{T} where {T<:PHModel}} <: AbstractNPSurv\n fitlist::G        \n eventtypes::AbstractVector\n times::AbstractVector\n surv::Vector{Float64}\n risk::Matrix{Float64}\n basehaz::Vector{Float64}\n event::Vector{Float64}\n end\n\n PHSurv(fitlist::Array{T}, eventtypes) where {T<:PHModel}\n PHSurv(fitlist::Array{T}) where {T<:PHModel}\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.PHSurv-Union{Tuple{T}, Tuple{Array{T}, Any}} where T<:PHModel","page":"Home","title":"LSurvival.PHSurv","text":"Mutable type for proportional hazards models (not generally needed by users)\n\nPHSsurv: Object type for proportional hazards regression\n\nsurv::Vector{Float64}  risk::Matrix{Float64}  basehaz::Vector{Float64}  event::Vector{Float64}\n\nfitlist: vector of PHSurv objects (Cox model fits)\neventtypes: vector of unique event types\ntimes: unique event times\nsurv: Overall survival at each time\nrisk: Cause-specific risk  at each time (1 for each outcome type)\nbasehaz: baseline hazard for a specific event type\nevent: value of event type that occurred at each time\n\nMethods: fit, show\n\n mutable struct PHSurv{G<:Array{T} where {T<:PHModel}} <: AbstractNPSurv\n fitlist::G        \n eventtypes::AbstractVector\n times::AbstractVector\n surv::Vector{Float64}\n risk::Matrix{Float64}\n basehaz::Vector{Float64}\n event::Vector{Float64}\n end\n\n PHSurv(fitlist::Array{T}, eventtypes) where {T<:PHModel}\n PHSurv(fitlist::Array{T}) where {T<:PHModel}\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.Strata","page":"Home","title":"LSurvival.Strata","text":"Type for identifying individuals in survival outcomes.  Used for the strata argument in PHModel (not yet implemented)\n\nAccepts any Number or String. There is no significance to having this particular struct, but it enables easier use of multiple dispatch.\n\n [Strata(i) for i in 1:10]\n\n\n\n\n\n","category":"type"},{"location":"#Base.popat!-Union{Tuple{T}, Tuple{T, Any, Any}} where T<:PHParms","page":"Home","title":"Base.popat!","text":"id, int, outt, data = LSurvival.dgm(MersenneTwister(112), 100, 10; afun = LSurvival.int_0) data[:, 1] = round.(data[:, 1], digits = 3) d, X = data[:, 4], data[:, 1:3] wt = rand(length(d)) wt ./= (sum(wt) / length(wt))\n\nP = PHParms(X) R = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only Ri, Rj, idxi, idxj = pop(R); Pi = popat!(P, idxi, idxj)\n\n\n\n\n\n","category":"method"},{"location":"#Base.push!-Union{Tuple{T}, Tuple{T, T}} where T<:PHParms","page":"Home","title":"Base.push!","text":"Insert an observation into the front of an PHParms object\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival._update_PHParms!-Union{Tuple{T}, Tuple{I}, Tuple{M}, Tuple{M, I, Array{Vector{T}, 1}, Array{Vector{T}, 1}}} where {M<:AbstractPH, I<:Int64, T<:Int64}","page":"Home","title":"LSurvival._update_PHParms!","text":"Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).\n\nUses Breslow's or Efron's partial likelihood.\n\nUpdates over all observations\n\n function _update_PHParms!(\n  m::M,\n  # big indexes\n  ne::I,\n  caseidxs::Vector{Vector{T}},\n  risksetidxs::Vector{Vector{T}},\n) where {M<:AbstractPH,I<:Int,T<:Int}\n\nupdatePHParms!(m, risksetidxs, caseidxs, ne, den)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.aalen_johansen-Tuple{Any, Any, Any}","page":"Home","title":"LSurvival.aalen_johansen","text":"Aalen-Johansen estimator for cumulative cause-specific risk (in the presence of competing events)\n\nSignatures\n\n  StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n \n  aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n    ; <keyword arguments>)\n \n\n using LSurvival\n using Random\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n    # event variable is coded 0[referent],1,2\n m = fit(AJSurv, enter, t, event)\n mw = fit(AJSurv, enter, t, event, wts=wt)\n\nor, equivalently:\n\n aalen_johansen(enter, t, event, wts=wt)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Tuple{MersenneTwister, PHModel, Int64}","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrapping coefficients of a proportional hazards model\n\nSignatures\n\n # single bootstrap draw, keeping the entire object\n bootstrap(rng::MersenneTwister, m::PHModel)\n bootstrap(m::PHModel)\n # muliple bootstrap draws, keeping only coefficient estimates\n bootstrap(rng::MersenneTwister, m::PHModel, iter::Int; kwargs...)\n bootstrap(m::PHModel, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up\n\n using LSurvival, Random\n\n id, int, outt, data =\n LSurvival.dgm(MersenneTwister(1212), 500, 5; afun = LSurvival.int_0)\n\n d, X = data[:, 4], data[:, 1:3]\n weights = rand(length(d))\n\n # survival outcome:\n R = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only\n P = PHParms(X)\n\n Mod = PHModel(R, P)\n LSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)\n\n\n # careful propogation of bootstrap sampling\n idx, R2 = bootstrap(R)\n P2 = bootstrap(idx, P)\n Modb = PHModel(R2, P2)\n LSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)\n\n # convenience function for bootstrapping a model\n Modc = bootstrap(Mod)\n LSurvival._fit!(Modc, start=Modc.P._B);\n Modc\n Modc.P.X == nothing\n Modc.R == nothing\n\n\nBootstrap Cox model coefficients\n\n LSurvival._fit!(mb, keepx=true, keepy=true, start=[0.0, 0.0])\n\n using LSurvival, Random\n res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 200)\n int = zeros(length(d)) # no late entry\n X = hcat(z, x)\n\n mainfit = fit(PHModel, X, int, outt, d .* (event .== 1), keepx=true, keepy=true)\n\n function stddev_finite(x)\n  n = length(x)\n  mnx = sum(x)/n\n  ret = sum((x .- mnx) .^ 2)\n  ret /= n-1\n  sqrt(ret)\n end\n\n # bootstrap standard error versus asymptotic\n mb = bootstrap(MersenneTwister(123123), mainfit, 200)\n ## bootstrap standard error\n [stddev_finite(mb[:,i]) for i in 1:2]\n ## asymptotic standard error\n stderror(mainfit)\n \n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Tuple{MersenneTwister, PHModel}","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrapping coefficients of a proportional hazards model\n\nSignatures\n\n # single bootstrap draw, keeping the entire object\n bootstrap(rng::MersenneTwister, m::PHModel)\n bootstrap(m::PHModel)\n # muliple bootstrap draws, keeping only coefficient estimates\n bootstrap(rng::MersenneTwister, m::PHModel, iter::Int; kwargs...)\n bootstrap(m::PHModel, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up\n\n using LSurvival, Random\n\n id, int, outt, data =\n LSurvival.dgm(MersenneTwister(1212), 500, 5; afun = LSurvival.int_0)\n\n d, X = data[:, 4], data[:, 1:3]\n weights = rand(length(d))\n\n # survival outcome:\n R = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only\n P = PHParms(X)\n\n Mod = PHModel(R, P)\n LSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)\n\n\n # careful propogation of bootstrap sampling\n idx, R2 = bootstrap(R)\n P2 = bootstrap(idx, P)\n Modb = PHModel(R2, P2)\n LSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)\n\n # convenience function for bootstrapping a model\n Modc = bootstrap(Mod)\n LSurvival._fit!(Modc, start=Modc.P._B);\n Modc\n Modc.P.X == nothing\n Modc.R == nothing\n\n\nBootstrap Cox model coefficients\n\n LSurvival._fit!(mb, keepx=true, keepy=true, start=[0.0, 0.0])\n\n using LSurvival, Random\n res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 200)\n int = zeros(length(d)) # no late entry\n X = hcat(z, x)\n\n mainfit = fit(PHModel, X, int, outt, d .* (event .== 1), keepx=true, keepy=true)\n\n function stddev_finite(x)\n  n = length(x)\n  mnx = sum(x)/n\n  ret = sum((x .- mnx) .^ 2)\n  ret /= n-1\n  sqrt(ret)\n end\n\n # bootstrap standard error versus asymptotic\n mb = bootstrap(MersenneTwister(123123), mainfit, 200)\n ## bootstrap standard error\n [stddev_finite(mb[:,i]) for i in 1:2]\n ## asymptotic standard error\n stderror(mainfit)\n \n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Tuple{Vector{Int64}, PHParms}","page":"Home","title":"LSurvival.bootstrap","text":"using LSurvival, Random\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nweights = rand(length(d))\n\n# survival outcome:\nR = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only\nP = PHParms(X)\nidx, R2 = bootstrap(R)\nP2 = bootstrap(idx, P)\n\nMod = PHModel(R2, P2)\nLSurvival._fit!(Mod, start=Mod.P._B)\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M, Int64}} where M<:AJSurv","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrap methods for Aalen-Johansen cumulative risk estimator\n\nSignatures\n\n  # single bootstrap draw, keeping the entire object\n  bootstrap(rng::MersenneTwister, m::AJSurv)\n  bootstrap(m::AJSurv)\n  # muliple bootstrap draws, keeping only coefficient estimates\n  bootstrap(rng::MersenneTwister, m::AJSurv, iter::Int; kwargs...)\n  bootstrap(m::AJSurv, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up\n\n using LSurvival\n using Random\n\n z, x, t, d, event, wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 100)\n id = 1:length(x)\n enter = zeros(length(t))\n\n aj1 = aalen_johansen(enter, t, event, id=ID.(id), wts=wt)\n aj2 = bootstrap(aj1, keepy=false);\n ajboot = bootstrap(aj1, 10, keepy=false);\n aj1\n\n\n aj1.R\n aj2.R\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M, Int64}} where M<:KMSurv","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrap methods for Kaplan-Meier survival curve estimator\n\nSignatures\n\n  # single bootstrap draw, keeping the entire object\n  bootstrap(rng::MersenneTwister, m::KMSurv)\n  bootstrap(m::KMSurv)\n  # muliple bootstrap draws, keeping only coefficient estimates\n  bootstrap(rng::MersenneTwister, m::KMSurv, iter::Int; kwargs...)\n  bootstrap(m::KMSurv, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the survival probability at the end of follow up\n\n using LSurvival\n using Random\n\n id, int, outt, data =\n LSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\n d, X = data[:, 4], data[:, 1:3]\n wts = rand(length(d))\n\n km1 = kaplan_meier(int, outt, d, id=ID.(id), wts=wts)\n km2 = bootstrap(km1, keepy=false)\n km3 = bootstrap(km1, 10, keepy=false)\n km1\n\n km1.R\n km2.R\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M<:AJSurv","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrap methods for Aalen-Johansen cumulative risk estimator\n\nSignatures\n\n  # single bootstrap draw, keeping the entire object\n  bootstrap(rng::MersenneTwister, m::AJSurv)\n  bootstrap(m::AJSurv)\n  # muliple bootstrap draws, keeping only coefficient estimates\n  bootstrap(rng::MersenneTwister, m::AJSurv, iter::Int; kwargs...)\n  bootstrap(m::AJSurv, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up\n\n using LSurvival\n using Random\n\n z, x, t, d, event, wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 100)\n id = 1:length(x)\n enter = zeros(length(t))\n\n aj1 = aalen_johansen(enter, t, event, id=ID.(id), wts=wt)\n aj2 = bootstrap(aj1, keepy=false);\n ajboot = bootstrap(aj1, 10, keepy=false);\n aj1\n\n\n aj1.R\n aj2.R\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M<:KMSurv","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrap methods for Kaplan-Meier survival curve estimator\n\nSignatures\n\n  # single bootstrap draw, keeping the entire object\n  bootstrap(rng::MersenneTwister, m::KMSurv)\n  bootstrap(m::KMSurv)\n  # muliple bootstrap draws, keeping only coefficient estimates\n  bootstrap(rng::MersenneTwister, m::KMSurv, iter::Int; kwargs...)\n  bootstrap(m::KMSurv, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the survival probability at the end of follow up\n\n using LSurvival\n using Random\n\n id, int, outt, data =\n LSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\n d, X = data[:, 4], data[:, 1:3]\n wts = rand(length(d))\n\n km1 = kaplan_meier(int, outt, d, id=ID.(id), wts=wts)\n km2 = bootstrap(km1, keepy=false)\n km3 = bootstrap(km1, 10, keepy=false)\n km1\n\n km1.R\n km2.R\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T<:LSurvivalCompResp","page":"Home","title":"LSurvival.bootstrap","text":"z,x,t,d,event,weights =\nLSurvival.dgm_comprisk(MersenneTwister(1212), 300)\nenter = zeros(length(event))\n\n# survival outcome:\nR = LSurvivalCompResp(enter, t, event, weights, ID.(collect(1:length(t))))    # specification with ID only\nbootstrap(R) # note that entire observations/clusters identified by id are kept\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T<:LSurvivalResp","page":"Home","title":"LSurvival.bootstrap","text":"id, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nweights = rand(length(d))\n\n# survival outcome:\nR = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.coxph-Tuple{Any, Any, Any, Any, Vararg{Any}}","page":"Home","title":"LSurvival.coxph","text":"Fit method for AbstractPH objects (Cox models)\n\nKeyword arguments (used here, and passed on to internal structs)\n\nties \"breslow\" or \"efron\" (default)\nwts observation weights\nties \"breslow\" or \"efron\" (default)\noffset not currently used at all\nfitargs arguments passed to other structs, which include\nid cluster or individual level ID (defaults to a unique value for each row of data) see note below on ID\ncontrasts StatsModel style contrasts (dicts) that can be used for variable transformations/indicator variable creation (e.g. https://juliastats.org/StatsModels.jl/stable/contrasts/)\n\n  fit(::Type{M},\n  X::AbstractMatrix,#{<:FP},\n  enter::AbstractVector{<:Real},\n  exit::AbstractVector{<:Real},\n  y::Union{AbstractVector{<:Real},BitVector}\n  ;\n  ties =\"breslow\",\n  wts::AbstractVector{<:Real}      = similar(y, 0),\n  offset::AbstractVector{<:Real}   = similar(y, 0),\n  fitargs...) where {M<:AbstractPH}\n ```\n\n ```\n coxph(f::FormulaTerm, data; kwargs...)\n\ncoxph(X, enter, exit, y, args...; kwargs...)\n\njulia    using LSurvival, Random    z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);    enter = zeros(length(t));    X = hcat(x,rand(length(x)));     m = fit(PHModel, X, enter, t, d, ties=\"efron\")    m2 = fit(PHModel, X, enter, t, d, ties=\"breslow\")    coeftable(m)\n\nNote on use of id keyword\n\nid is not needed in person-period structure data for standard estimates or confidence intervals  ```@example   using Random, LSurvival      id, int, outt, dat =          LSurvival.dgm(MersenneTwister(123123), 100, 100; afun = LSurvival.int_0)      data = (              int = int,              outt = outt,              d = dat[:,4] .== 1,              x = dat[:,1],              z = dat[:,2]      )\n\n f = @formula(Surv(int, outt,d)~x+z)\n coxph(f, data)\n\n```\n\nBUT, you must specify id to get appropriate robust variance and some other statistics.\n\nHere is an example where the same data are presented in two different ways, which should yield identical statistics when used in Cox model.  ```@example  dat1 = (     time = [1,1,6,6,8,9],     status = [1,0,1,1,0,1],     x = [1,1,1,0,0,0] ) ft = coxph(@formula(Surv(time,status)~x),dat1) bic(ft) nobs(ft) dof_residual(ft)\n\nlrtest is another one\n\nstderror(ft)                     # model based stderror(ft, type=\"robust\")   # robust standard error, based on dfbeta residuals ft\n\nnow using \"clustered\" data with multiple observations per individual\n\ndat1clust= (      id = [1,2,3,3,4,4,5,5,6,6],      enter = [0,0,0,1,0,1,0,1,0,1],      exit = [1,1,1,6,1,6,1,8,1,9],      status = [1,0,0,1,0,1,0,0,0,1],      x = [1,1,1,1,0,0,0,0,0,0]  )\n\nuse the id parameter with the ID struct\n\nft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id))  bic(ft2)                       # CORRECT          nobs(ft2)                      # CORRECT  dof_residual(ft2)              # CORRECT\n\nstderror(ft2)                  # model based (CORRECT)  stderror(ft2, type=\"robust\")   # robust standard error, based on id level dfbeta residuals (CORRECT)\n\nonce robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics\n\nft2   # CORRECT (compare to ft object)  ```\n\nNOTE THE FOLLOWING IS INCORRECT because the id keyword is omitted\n\n```@example  ft2w = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust)  bic(ft2w)                          # INCORRECT   nobs(ft2w)                         # INCORRECT  dof_residual(ft2w)                 # INCORRECT\n\nstderror(ft2w)                     # model based (CORRECT)  stderror(ft2w, type=\"robust\")      # robust variance (INCORRECT)\n\nft2w # the coefficient table now shows incorrect confidence intervals and test statistics\n\n```\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.dgm-Tuple{Any, Any, Any}","page":"Home","title":"LSurvival.dgm","text":"Generating discrete survival data without competing risks\n\nUsage: dgm(rng, n, maxT;afun=int0, yfun=yprob, lfun=lprob)  dgm(n, maxT;afun=int0, yfun=yprob, lfun=lprob)\n\nWhere afun, yfun, and lfun are all functions that take arguments v,l,a and output time-specific values of a, y, and l respectively  Example:\n\n\n expit(mu) =  inv(1.0+exp(-mu))\n\n function aprob(v,l,a)\n expit(-1.0 + 3*v + 2*l)\n end\n   \n function lprob(v,l,a)\n expit(-3 + 2*v + 0*l + 0*a)\n end\n   \n function yprob(v,l,a)\n expit(-3 + 2*v + 0*l + 2*a)\n end\n   # 10 individuals followed for up to 5 times\n LSurvival.dgm(10, 5;afun=aprob, yfun=yprob, lfun=lprob)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.dgm_comprisk-Tuple{Any, Any}","page":"Home","title":"LSurvival.dgm_comprisk","text":"Generating continuous survival data with competing risks\n\nUsage: dgmcomprisk(rng, n)  dgmcomprisk(n)\n\n     - rng = random number generator    \n     - n = sample size\n\nExample:\n\n using LSurvival\n     # 100 individuals with two competing events\n z,x,t,d,event,weights = LSurvival.dgm_comprisk(100)\n     \n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.jackknife-Tuple{M} where M<:PHModel","page":"Home","title":"LSurvival.jackknife","text":"id, int, outt, data = LSurvival.dgm(MersenneTwister(112), 100, 10; afun = LSurvival.int_0) data[:, 1] = round.(data[:, 1], digits = 3) d, X = data[:, 4], data[:, 1:3] wt = rand(length(d)) wt ./= (sum(wt) / length(wt)) m = coxph(X,int, outt,d, wts=wt, id=ID.(id))\n\njk = jackknife(m); bs = bootstrap(MersenneTwister(12321), m, 1000); N = nobs(m) #comparing estimate with jackknife estimate with bootstrap mean hcat(coef(m), mean(jk, dims=1)[1,:], mean(bs, dims=1)[1,:]) semb = stderror(m) sebs = std(bs, dims=1) sejk = std(jk, dims=1, corrected=false) .* sqrt(N-1) sero = stderror(m, type=\"robust\")\n\njackknifevcov(m) LSurvival.robustvcov(m)\n\nhcat(semb, sebs[1,:], sejk[1,:], sero)\n\ndat1 = (time = [1, 1, 6, 6, 8, 9], status = [1, 0, 1, 1, 0, 1], x = [1, 1, 1, 0, 0, 0]) dat1clust = (     id = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6],     enter = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1],     exit = [1, 1, 1, 6, 1, 6, 1, 8, 1, 9],     status = [1, 0, 0, 1, 0, 1, 0, 0, 0, 1],     x = [1, 1, 1, 1, 0, 0, 0, 0, 0, 0], )\n\nm = coxph(@formula(Surv(time, status)~x),dat1) mc = coxph(@formula(Surv(enter, exit, status)~x),dat1clust, id=ID.(dat1clust.id)) jk = jackknife(m); jkc = jackknife(mc); bs = bootstrap(mc, 100); std(bs[:,1]) std(jkc[:,1]) stderror(mc) @assert jk == jkc\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.kaplan_meier-Tuple{Any, Any, Any}","page":"Home","title":"LSurvival.kaplan_meier","text":"Kaplan-Meier estimator for cumulative conditional risk\n\nSignatures\n\n```julia   StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\nkaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,      ; <keyword arguments>)  ```\n\n@example   using LSurvival   using Random   z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);   enter = zeros(length(t));   m = fit(KMSurv, enter, t, d)   mw = fit(KMSurv, enter, t, d, wts=wt)   or, equivalently:\n\njulia   kaplan_meier(enter, t, d, wts=wt)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lgh_breslow!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M<:AbstractPH","page":"Home","title":"LSurvival.lgh_breslow!","text":"Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).\n\nUses Breslow's partial likelihood.\n\nUpdates over all observations\n\nSignature\n\n lgh_breslow!(m::M, j, caseidx, risksetidx) where {M<:AbstractPH}\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lgh_efron!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M<:AbstractPH","page":"Home","title":"LSurvival.lgh_efron!","text":"Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).\n\nUses Efron's partial likelihood.\n\nUpdates over all observations\n\nSignature\n\n lgh_efron!(m::M, j, caseidx, risksetidx) where {M<:AbstractPH}\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.pop-Tuple{T} where T<:LSurvivalResp","page":"Home","title":"LSurvival.pop","text":"Remove the last element from an LSurvivalResp object\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(112), 100, 10; afun = LSurvival.int_0)\ndata[:, 1] = round.(data[:, 1], digits = 3)\nd, X = data[:, 4], data[:, 1:3]\nwt = rand(length(d))\nwt ./= (sum(wt) / length(wt))\n\nR = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only\nRi, Rj, idxi, idxj = pop(R);\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.push-Union{Tuple{T}, Tuple{T, T}} where T<:LSurvivalResp","page":"Home","title":"LSurvival.push","text":"Insert an observation into the front of an LSurvivalResp object\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(112), 100, 10; afun = LSurvival.int_0)\ndata[:, 1] = round.(data[:, 1], digits = 3)\nd, X = data[:, 4], data[:, 1:3]\nwt = rand(length(d))\nwt ./= (sum(wt) / length(wt))\n\nR = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only\nRi, Rj, idxi, idxj = pop(R);\nR = push(Ri, Rj)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.risk_from_coxphmodels-Union{Tuple{T}, Tuple{Array{T}, Vararg{Any}}} where T<:PHModel","page":"Home","title":"LSurvival.risk_from_coxphmodels","text":"Survival curve estimation using multiple cox models\n\nFunction Signatures\n\nrisk_from_coxphmodels(fitlist::Array{T}, args...; kwargs...) where {T<:PHModel}\n\nfit(::Type{M}, fitlist::Vector{<:T}, ; fitargs...) where {M<:PHSurv,T<:PHModel}\n\nOptional keywords\n\ncoef_vectors = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]\npred_profile = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]\n\n using LSurvival\n using Random\n # event variable is coded 0[referent],1,2\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n\n ft1 = coxph(hcat(x,z), enter, t, (event .== 1))\n nidx = findall(event .!= 1)\n ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))\n\n # risk at referent levels of `x` and `z`\n risk_from_coxphmodels([ft1,ft2])\n\n # risk at average levels of `x` and `z`\n mnx = sum(x)/length(x)\n mnz = sum(z)/length(z)\n risk_from_coxphmodels([ft1,ft2], pred_profile=[mnx,mnz])\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.robust_vcov-Tuple{M} where M<:PHModel","page":"Home","title":"LSurvival.robust_vcov","text":"using LSurvival\ndat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n)\nft = coxph(@formula(Surv(time,status)~x),dat1, id=ID.(collect(1:6)))\n\nvcov(ft)                   # model based\nvcov(ft, type=\"robust\")    # robust variance, based on dfbeta residuals\n# once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics\nft\n\ncluster robust standard errors using the id keyword argument\n\ndat1clust= (\n    id = [1,2,3,3,4,4,5,5,6,6],\n    enter = [0,0,0,1,0,1,0,1,0,1],\n    exit = [1,1,1,6,1,6,1,8,1,9],\n    status = [1,0,0,1,0,1,0,0,0,1],\n    x = [1,1,1,1,0,0,0,0,0,0]\n)\n\nft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id))\n\nvcov(ft2)                     # model based\nvcov(ft2, type=\"robust\")       # robust variance, based on dfbeta residuals\nstderror(ft2, type=\"robust\")   # robust variance, based on dfbeta residuals\nconfint(ft2, type=\"robust\")    # robust variance, based on dfbeta residuals\nnobs(ft2)                     # id argument yields correct value of number of independent observations\n# once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics\nft2 \n\nNOTE THE FOLLOWING IS INCORRECT because the id keyword is omitted\n\nft2w = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust)\n\nvcov(ft2w)                   # model based (CORRECT)\nvcov(ft2w, type=\"robust\")    # robust variance (INCORRECT)\nnobs(ft2w)\n\nft2w\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.confint-Tuple{AJSurv}","page":"Home","title":"StatsAPI.confint","text":"Greenwood's formula for variance and confidence intervals of a Aalen-Johansen risk function\n\n res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)\n int = zeros(length(d)) # no late entry\n m = fit(AJSurv, int, outt, event)\n stderror(m)\n confint(m, level=0.95)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.confint-Tuple{KMSurv}","page":"Home","title":"StatsAPI.confint","text":"Greenwood's formula for variance and confidence intervals of a Kaplan-Meier survival curve\n\nSignatures:\n\n StatsBase.stderror(m::KMSurv)\n\n StatsBase.confint(m:KMSurv; level=0.95, method=\"normal\")\n\nmethod:\n\n\"normal\" normality-based confidence intervals\n\"lognlog\" log(-log(S(t))) based confidence intervals\n\n using LSurvival\n using Random\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n m = fit(KMSurv, enter, t, d)\n mw = fit(KMSurv, enter, t, d, wts=wt)\n stderror(m)\n confint(m, method=\"normal\")\n confint(m, method=\"lognlog\") # log-log transformation\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.confint-Tuple{M} where M<:AbstractPH","page":"Home","title":"StatsAPI.confint","text":"```julia using LSurvival  dat1= (      time = [1,1,6,6,8,9],      status = [1,0,1,1,0,1],      x = [1,1,1,0,0,0]  )\n\nft = coxph(@formula(Surv(time, status) ~ x),dat1, keepx=true)\n\nmodel-based variance\n\nconfint(ft)\n\nrobust variance\n\nconfint(ft, type=\"robust\")  ```\n\nfor cluster confidence intervals\n\n```julia  dat1clust= (      id = [1,2,3,3,4,4,5,5,6,6],      enter = [0,0,0,1,0,1,0,1,0,1],      exit = [1,1,1,6,1,6,1,8,1,9],      status = [1,0,0,1,0,1,0,0,0,1],      x = [1,1,1,1,0,0,0,0,0,0]  )\n\nft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id), keepx=true)\n\nmodel-based variance\n\nconfint(ft2)\n\nrobust variance\n\nconfint(ft2, type=\"robust\") ````\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit!-Tuple{T} where T<:AbstractNPSurv","page":"Home","title":"StatsAPI.fit!","text":"Kaplan-Meier estimator for cumulative conditional risk\n\nSignatures\n\n  StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\n  kaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n     ; <keyword arguments>)\n ```\n\n  \n ```@example\n  using LSurvival\n  using Random\n  z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n  enter = zeros(length(t));\n  m = fit(KMSurv, enter, t, d)\n  mw = fit(KMSurv, enter, t, d, wts=wt)\n ```\n  or, equivalently:\n\n ```julia\n  kaplan_meier(enter, t, d, wts=wt)\n ```\n \n\n Aalen-Johansen estimator for cumulative cause-specific risk (in the presence of competing events)\n\n Signatures\n\n ```julia\n  StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n \n  aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n    ; <keyword arguments>)\n \n\n using LSurvival\n using Random\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n    # event variable is coded 0[referent],1,2\n m = fit(AJSurv, enter, t, event)\n mw = fit(AJSurv, enter, t, event, wts=wt)\n\nor, equivalently:\n\n aalen_johansen(enter, t, event, wts=wt)\n\nSurvival curve estimation using multiple cox models\n\nFunction Signatures\n\nrisk_from_coxphmodels(fitlist::Array{T}, args...; kwargs...) where {T<:PHModel}\n\nfit(::Type{M}, fitlist::Vector{<:T}, ; fitargs...) where {M<:PHSurv,T<:PHModel}\n\nOptional keywords\n\ncoef_vectors = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]\npred_profile = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]\n\n using LSurvival\n using Random\n # event variable is coded 0[referent],1,2\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n\n ft1 = coxph(hcat(x,z), enter, t, (event .== 1))\n nidx = findall(event .!= 1)\n ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))\n\n # risk at referent levels of `x` and `z`\n risk_from_coxphmodels([ft1,ft2])\n\n # risk at average levels of `x` and `z`\n mnx = sum(x)/length(x)\n mnz = sum(z)/length(z)\n risk_from_coxphmodels([ft1,ft2], pred_profile=[mnx,mnz])\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{T}, Tuple{M}, Tuple{Type{M}, Vector{<:T}}} where {M<:PHSurv, T<:PHModel}","page":"Home","title":"StatsAPI.fit","text":"Survival curve estimation using multiple cox models\n\nFunction Signatures\n\nrisk_from_coxphmodels(fitlist::Array{T}, args...; kwargs...) where {T<:PHModel}\n\nfit(::Type{M}, fitlist::Vector{<:T}, ; fitargs...) where {M<:PHSurv,T<:PHModel}\n\nOptional keywords\n\ncoef_vectors = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]\npred_profile = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]\n\n using LSurvival\n using Random\n # event variable is coded 0[referent],1,2\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n\n ft1 = coxph(hcat(x,z), enter, t, (event .== 1))\n nidx = findall(event .!= 1)\n ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))\n\n # risk at referent levels of `x` and `z`\n risk_from_coxphmodels([ft1,ft2])\n\n # risk at average levels of `x` and `z`\n mnx = sum(x)/length(x)\n mnz = sum(z)/length(z)\n risk_from_coxphmodels([ft1,ft2], pred_profile=[mnx,mnz])\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Matrix{<:Real}, Vector{<:Real}, Vector{<:Real}, Y}} where {M<:AbstractPH, Y<:Union{BitVector, Vector{<:Real}}}","page":"Home","title":"StatsAPI.fit","text":"Fit method for AbstractPH objects (Cox models)\n\nKeyword arguments (used here, and passed on to internal structs)\n\nties \"breslow\" or \"efron\" (default)\nwts observation weights\nties \"breslow\" or \"efron\" (default)\noffset not currently used at all\nfitargs arguments passed to other structs, which include\nid cluster or individual level ID (defaults to a unique value for each row of data) see note below on ID\ncontrasts StatsModel style contrasts (dicts) that can be used for variable transformations/indicator variable creation (e.g. https://juliastats.org/StatsModels.jl/stable/contrasts/)\n\n  fit(::Type{M},\n  X::AbstractMatrix,#{<:FP},\n  enter::AbstractVector{<:Real},\n  exit::AbstractVector{<:Real},\n  y::Union{AbstractVector{<:Real},BitVector}\n  ;\n  ties =\"breslow\",\n  wts::AbstractVector{<:Real}      = similar(y, 0),\n  offset::AbstractVector{<:Real}   = similar(y, 0),\n  fitargs...) where {M<:AbstractPH}\n ```\n\n ```\n coxph(f::FormulaTerm, data; kwargs...)\n\ncoxph(X, enter, exit, y, args...; kwargs...)\n\njulia    using LSurvival, Random    z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);    enter = zeros(length(t));    X = hcat(x,rand(length(x)));     m = fit(PHModel, X, enter, t, d, ties=\"efron\")    m2 = fit(PHModel, X, enter, t, d, ties=\"breslow\")    coeftable(m)\n\nNote on use of id keyword\n\nid is not needed in person-period structure data for standard estimates or confidence intervals  ```@example   using Random, LSurvival      id, int, outt, dat =          LSurvival.dgm(MersenneTwister(123123), 100, 100; afun = LSurvival.int_0)      data = (              int = int,              outt = outt,              d = dat[:,4] .== 1,              x = dat[:,1],              z = dat[:,2]      )\n\n f = @formula(Surv(int, outt,d)~x+z)\n coxph(f, data)\n\n```\n\nBUT, you must specify id to get appropriate robust variance and some other statistics.\n\nHere is an example where the same data are presented in two different ways, which should yield identical statistics when used in Cox model.  ```@example  dat1 = (     time = [1,1,6,6,8,9],     status = [1,0,1,1,0,1],     x = [1,1,1,0,0,0] ) ft = coxph(@formula(Surv(time,status)~x),dat1) bic(ft) nobs(ft) dof_residual(ft)\n\nlrtest is another one\n\nstderror(ft)                     # model based stderror(ft, type=\"robust\")   # robust standard error, based on dfbeta residuals ft\n\nnow using \"clustered\" data with multiple observations per individual\n\ndat1clust= (      id = [1,2,3,3,4,4,5,5,6,6],      enter = [0,0,0,1,0,1,0,1,0,1],      exit = [1,1,1,6,1,6,1,8,1,9],      status = [1,0,0,1,0,1,0,0,0,1],      x = [1,1,1,1,0,0,0,0,0,0]  )\n\nuse the id parameter with the ID struct\n\nft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id))  bic(ft2)                       # CORRECT          nobs(ft2)                      # CORRECT  dof_residual(ft2)              # CORRECT\n\nstderror(ft2)                  # model based (CORRECT)  stderror(ft2, type=\"robust\")   # robust standard error, based on id level dfbeta residuals (CORRECT)\n\nonce robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics\n\nft2   # CORRECT (compare to ft object)  ```\n\nNOTE THE FOLLOWING IS INCORRECT because the id keyword is omitted\n\n```@example  ft2w = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust)  bic(ft2w)                          # INCORRECT   nobs(ft2w)                         # INCORRECT  dof_residual(ft2w)                 # INCORRECT\n\nstderror(ft2w)                     # model based (CORRECT)  stderror(ft2w, type=\"robust\")      # robust variance (INCORRECT)\n\nft2w # the coefficient table now shows incorrect confidence intervals and test statistics\n\n```\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{<:Real}, Vector{<:Real}, Y}} where {M<:AJSurv, Y<:Union{BitVector, Vector{<:Real}}}","page":"Home","title":"StatsAPI.fit","text":"Aalen-Johansen estimator for cumulative cause-specific risk (in the presence of competing events)\n\nSignatures\n\n  StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n \n  aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n    ; <keyword arguments>)\n \n\n using LSurvival\n using Random\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n    # event variable is coded 0[referent],1,2\n m = fit(AJSurv, enter, t, event)\n mw = fit(AJSurv, enter, t, event, wts=wt)\n\nor, equivalently:\n\n aalen_johansen(enter, t, event, wts=wt)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{<:Real}, Vector{<:Real}, Y}} where {M<:KMSurv, Y<:Union{BitVector, Vector{<:Real}}}","page":"Home","title":"StatsAPI.fit","text":"Kaplan-Meier estimator for cumulative conditional risk\n\nSignatures\n\n```julia   StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\nkaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,      ; <keyword arguments>)  ```\n\n@example   using LSurvival   using Random   z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);   enter = zeros(length(t));   m = fit(KMSurv, enter, t, d)   mw = fit(KMSurv, enter, t, d, wts=wt)   or, equivalently:\n\njulia   kaplan_meier(enter, t, d, wts=wt)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.loglikelihood-Tuple{M} where M<:AbstractPH","page":"Home","title":"StatsAPI.loglikelihood","text":"Maximum log partial likelihood for a fitted AbstractPH model Efron or Breslow (depending on the ties` parameter)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.nullloglikelihood-Tuple{M} where M<:AbstractPH","page":"Home","title":"StatsAPI.nullloglikelihood","text":"Null log-partial likelihood for a fitted AbstractPH model Efron or Breslow (depending on the ties` parameter)\n\nNote: this is just the log partial likelihood at the initial values of the model, which default to 0. If initial values are non-null, then this function no longer validly returns the null log-partial likelihood.\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.residuals-Tuple{M} where M<:PHModel","page":"Home","title":"StatsAPI.residuals","text":"#################################################################### Cox proportional hazards model residuals:\n\nSignature\n\nresiduals(m::M; type = \"martingale\") where {M<:PHModel}\n\nwhere type is one of \n\nmartingale\nschoenfeld\nscore\ndfbeta\nscaled_schoenfeld\n\nResiduals from the residuals function are designed to exactly emulate those from the survival package in R. Currently, they are validated for single observation data (e.g. one data row per individual).\n\n####################################################################\n\nMartingale residuals: Observed versus expected\n\n# example from https://cran.r-project.org/web/packages/survival/vignettes/validate.pdf\n# by Terry Therneau\n\ndat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n)\n\n# Nelson-Aalen type estimator for Breslow partial likelihood\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"breslow\")\nresiduals(ft, type=\"martingale\")\n\ndat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n)\n\n# Fleming-Harrington type estimator for Efron partial likelihood\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"efron\")\nresiduals(ft, type=\"martingale\")\n\n\n####################################################################\n\nScore residuals: Per observation contribution to score function\n\nusing LSurvival\ndat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n)\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"breslow\")\nS = residuals(ft, type=\"score\")[:]\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"efron\", maxiter=0)\nS = residuals(ft, type=\"score\")[:]\n\n####################################################################\n\nSchoenfeld residuals: Per time contribution to score function\n\nusing LSurvival\ndat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n)\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"breslow\", maxiter=0)\n\n\nX = ft.P.X\nM = residuals(ft, type=\"martingale\")\nS = residuals(ft, type=\"schoenfeld\")[:]\n\n####################################################################\n\ndfbeta residuals: influence of individual observations on each parameter\n\nusing LSurvival\ndat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n)\n\nft = coxph(@formula(Surv(time,status)~x),dat1, ties=\"breslow\")\nresiduals(ft, type=\"dfbeta\")\n\n# can also calculate from score residuals and Hessian matrix\nL = residuals(ft, type=\"score\") # n X p\nH = ft.P._hess   # p X p\ndfbeta = L*inv(H)\nrobVar = dfbeta'dfbeta\nsqrt(robVar)\n\n\nusing the id keyword argument\n\nsee help for LSurvival.vcov for what happens when id keyword is not used\n\ndat1clust= (\n    id = [1,2,3,3,4,4,5,5,6,6],\n    enter = [0,0,0,1,0,1,0,1,0,1],\n    exit = [1,1,1,6,1,6,1,8,1,9],\n    status = [1,0,0,1,0,1,0,0,0,1],\n    x = [1,1,1,1,0,0,0,0,0,0]\n)\n\nft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id), ties=\"breslow\")\n\n# note these are still on the observation level (not the id level)! \nresiduals(ft2, type=\"dfbeta\")\n\n# getting id level dfbeta residuals\ndfbeta = residuals(ft2, type=\"dfbeta\")\nid = values(ft2.R.id)\nD = reduce(vcat, [sum(dfbeta[findall(id .== i),:], dims=1) for i in unique(id)])\nD'D\nvcov(ft, type=\"robust\")\nvcov(ft2, type=\"robust\")\n\n####################################################################\n\njackknife residuals: influence of individual observations on each parameter\n\nusing LSurvival\ndat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n)\n\nft = coxph(@formula(Surv(time,status)~x),dat1, ties=\"breslow\")\njackknife(ft)\nresiduals(ft, type=\"jackknife\")\n\n\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.stderror-Tuple{AJSurv}","page":"Home","title":"StatsAPI.stderror","text":"Greenwood's formula for variance and confidence intervals of a Aalen-Johansen risk function\n\n res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)\n int = zeros(length(d)) # no late entry\n m = fit(AJSurv, int, outt, event)\n stderror(m)\n confint(m, level=0.95)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.stderror-Tuple{KMSurv}","page":"Home","title":"StatsAPI.stderror","text":"Greenwood's formula for variance and confidence intervals of a Kaplan-Meier survival curve\n\nSignatures:\n\n StatsBase.stderror(m::KMSurv)\n\n StatsBase.confint(m:KMSurv; level=0.95, method=\"normal\")\n\nmethod:\n\n\"normal\" normality-based confidence intervals\n\"lognlog\" log(-log(S(t))) based confidence intervals\n\n using LSurvival\n using Random\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n m = fit(KMSurv, enter, t, d)\n mw = fit(KMSurv, enter, t, d, wts=wt)\n stderror(m)\n confint(m, method=\"normal\")\n confint(m, method=\"lognlog\") # log-log transformation\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.vcov-Tuple{M} where M<:AbstractPH","page":"Home","title":"StatsAPI.vcov","text":"Covariance matrix for Cox proportional hazards models  \n\nKeyword arguments\n\ntype nothing or \"robust\": determines whether model based or robust (dfbeta based) variance is returned.\n\nSee ?residuals for info on dfbeta residuals\n\nusing LSurvival\ndat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n)\nft = coxph(@formula(Surv(time,status)~x),dat1, id=ID.(collect(1:6)))\n\nvcov(ft)                   # model based\nvcov(ft, type=\"robust\")    # robust variance, based on dfbeta residuals\n# once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics\nft\n\ncluster robust standard errors using the id keyword argument\n\ndat1clust= (\n    id = [1,2,3,3,4,4,5,5,6,6],\n    enter = [0,0,0,1,0,1,0,1,0,1],\n    exit = [1,1,1,6,1,6,1,8,1,9],\n    status = [1,0,0,1,0,1,0,0,0,1],\n    x = [1,1,1,1,0,0,0,0,0,0]\n)\n\nft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id))\n\nvcov(ft2)                     # model based\nvcov(ft2, type=\"robust\")       # robust variance, based on dfbeta residuals\nstderror(ft2, type=\"robust\")   # robust variance, based on dfbeta residuals\nconfint(ft2, type=\"robust\")    # robust variance, based on dfbeta residuals\nnobs(ft2)                     # id argument yields correct value of number of independent observations\n# once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics\nft2 \n\nNOTE THE FOLLOWING IS INCORRECT because the id keyword is omitted\n\nft2w = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust)\n\nvcov(ft2w)                   # model based (CORRECT)\nvcov(ft2w, type=\"robust\")    # robust variance (INCORRECT)\nnobs(ft2w)\n\nft2w\n\n\n\n\n\n","category":"method"}]
}
