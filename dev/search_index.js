var documenterSearchIndex = {"docs":
[{"location":"","page":"Help","title":"Help","text":"CurrentModule = LSurvival=","category":"page"},{"location":"#[LSurvival](https://github.com/alexpkeil1/LSurvival.jl)","page":"Help","title":"LSurvival","text":"","category":"section"},{"location":"","page":"Help","title":"Help","text":"Survival analysis functions in Julia for time-to-event outcomes that can include:","category":"page"},{"location":"","page":"Help","title":"Help","text":"Loss-to-follow-up/right censoring\nLate entry/left truncation (not available in Survival.jl)\n\"Person-period\" data structures (not available in Survival.jl)\nObservation weights (not available in Survival.jl)\nCompeting risks (not available in Survival.jl)","category":"page"},{"location":"","page":"Help","title":"Help","text":"Capabilities include estimators for","category":"page"},{"location":"","page":"Help","title":"Help","text":"Kaplan-Meier non-parametric conditional risk functions\nAalen-Johansen non-parametric cause-specific unconditional risk functions\nCox proportional hazards model (Efron's or Breslow's methods for ties)","category":"page"},{"location":"","page":"Help","title":"Help","text":"Convenience functions enable:","category":"page"},{"location":"","page":"Help","title":"Help","text":"Non-parametric bootstrapping, cluster-bootstrapping\nEstimating baseline hazards from a Cox Model\nEstimating cause-specific risk from an exhaustive set of Cox models for competing risk outcomes\nSimple simulation of competing and non-competing survival events\nCluster robust variance estimation (without bootstrapping)\nMartingale, score, Schoenfeld, and dfbeta residuals\nCluster robust variance estimation","category":"page"},{"location":"","page":"Help","title":"Help","text":"Plans to include:","category":"page"},{"location":"","page":"Help","title":"Help","text":"Parametric survival models\nStratification in Cox models","category":"page"},{"location":"","page":"Help","title":"Help","text":"The package has been tuned to follow the \"survival\" package from R in terms of specific estimators/results.","category":"page"},{"location":"","page":"Help","title":"Help","text":"Report issues here","category":"page"},{"location":"#Installation","page":"Help","title":"Installation","text":"","category":"section"},{"location":"","page":"Help","title":"Help","text":"using Pkg; Pkg.add(url = \"https://github.com/alexpkeil1/LSurvival.jl\")","category":"page"},{"location":"#Quick-examples","page":"Help","title":"Quick examples","text":"","category":"section"},{"location":"#Single-event-type:-Cox-model-and-Kaplan-Meier-curve","page":"Help","title":"Single event type: Cox model and Kaplan-Meier curve","text":"","category":"section"},{"location":"","page":"Help","title":"Help","text":"using Random, LSurvival, Distributions, LinearAlgebra\n\n# generate some data under a discrete hazards model\nexpit(mu) = inv(1.0 + exp(-mu))\n\nfunction dgm(rng, n, maxT; regimefun = int_0)\n    V = rand(rng, n)\n    LAY = Array{Float64,2}(undef, n * maxT, 4)\n    keep = ones(Bool, n * maxT)\n    id = sort(reduce(vcat, fill(collect(1:n), maxT)))\n    time = (reduce(vcat, fill(collect(1:maxT), n)))\n    for i = 1:n\n        v = V[i]\n        l = 0\n        a = 0\n        lkeep = true\n        for t = 1:maxT\n            currIDX = (i - 1) * maxT + t\n            l = expit(-3 + 2 * v + 0 * l + 0 * a) > rand(rng) ? 1 : 0\n            a = 0.1 > rand(rng) ? 1 : 0\n            y = expit(-3 + 2 * v + 0 * l + 2 * a) > rand(rng) ? 1 : 0\n            LAY[currIDX, :] .= [v, l, a, y]\n            keep[currIDX] = lkeep\n            lkeep = (!lkeep || (y == 1)) ? false : true\n        end\n    end\n    id[findall(keep)], time[findall(keep)] .- 1, time[findall(keep)], LAY[findall(keep), :]\nend\n\nid, int, outt, data = dgm(MersenneTwister(), 1000, 10; regimefun = int_0)\ndata[:, 1] = round.(data[:, 1], digits = 3)\nd, X = data[:, 4], data[:, 1:3]\nwt = rand(length(d)) # random weights just to demonstrate usage\n\n# Cox model\n# Breslow's partial likelihood\nm = fit(PHModel, X, int, outt, d, ties = \"breslow\", wts = wt)\n\n# Efron's partial likelihood\nm2 = fit(PHModel, X, int, outt, d, ties = \"efron\", wts = wt)\n\n#equivalent way to specify \n# using `coxph` function\nm2b = coxph(X, int, outt, d, ties = \"efron\", wts = wt)\n\n# using `coxph` function with `Tables.jl` and `StatsAPI.@formula` interface (similar to GLM.jl)\ntab = ( in = int, out = out, d=d, x=X[:,1], z1=X[:,2], z2=X[:,3]) # can also be a DataFrame from DataFrames.jl\nm2b = coxph(@formula(Surv(in, out, d)~x+z1+z2), ties = \"efron\", wts = wt)\n\n# can also be done if there is no late entry\nm2b = coxph(@formula(Surv(out, d)~x+z1+z2), ties = \"efron\", wts = wt)\n# can also be done if there is no late entry and no right censoring (i.e. all times are failure times)\nm2b = coxph(@formula(Surv(out)~x+z1+z2), ties = \"efron\", wts = wt)\n\n\n\n# Kaplan-Meier estimator of the cumulative risk/survival\nres = kaplan_meier(int, outt, d)","category":"page"},{"location":"#Competing-event-analysis:-Aalen-Johansen-and-Cox-model-based-estimators-of-the-cumulative-risk/survival","page":"Help","title":"Competing event analysis: Aalen-Johansen and Cox-model-based estimators of the cumulative risk/survival","text":"","category":"section"},{"location":"","page":"Help","title":"Help","text":"using Random, LSurvival, Distributions, LinearAlgebra\n\n# simulate some data\nfunction dgm_comprisk(; n = 100, rng = MersenneTwister())\n    z = rand(rng, n) .* 5\n    x = rand(rng, n) .* 5\n    dt1 = Weibull.(fill(0.75, n), inv.(exp.(-x .- z)))\n    dt2 = Weibull.(fill(0.75, n), inv.(exp.(-x .- z)))\n    t01 = rand.(rng, dt1)\n    t02 = rand.(rng, dt2)\n    t0 = min.(t01, t02)\n    t = Array{Float64,1}(undef, n)\n    for i = 1:n\n        t[i] = t0[i] > 1.0 ? 1.0 : t0[i]\n    end\n    d = (t .== t0)\n    event = (t .== t01) .+ 2.0 .* (t .== t02)\n    wtu = rand(rng, n) .* 5.0\n    wt = wtu ./ mean(wtu)\n    reshape(round.(z, digits = 4), (n, 1)),\n    reshape(round.(x, digits = 4), (n, 1)),\n    round.(t, digits = 4),\n    d,\n    event,\n    round.(wt, digits = 4)\nend\n\nz, x, t, d, event, wt = dgm_comprisk(; n = 100, rng = MersenneTwister(12))\nX = hcat(x,z)\nenter = t .* rand(length(d))*0.02 # create some fake entry times\n\n# Aalen-Johansen estimator: marginal cause-specific risks\nres_aj = aalen_johansen(enter, t, event; wts = wt);\nres_aj\n\n# Cox-model estimator: cause-specific risks at given levels of covariates\nfit1 = fit(PHModel, X, enter, t, (event .== 1), ties = \"efron\",  wts = wt)\n#n2idx = findall(event .!= 1)\nn2idx = findall(event .> -1)\nfit2 = fit(PHModel, X[n2idx,:], enter[n2idx], t[n2idx], (event[n2idx] .== 2), ties = \"breslow\",  wts = wt[n2idx])\n\n# risk at referent levels of `x` and `z` (can be very extreme if referent levels are unlikely/unobservable)\nres_cph_ref = risk_from_coxphmodels([fit1,fit2])\n\n# risk at average levels of `x` and `z`\nmnx = sum(x)/length(x)\nmnz = sum(z)/length(z)\nres_cph = risk_from_coxphmodels([fit1,fit2], coef_vectors=[coef(ft1), coef(ft2)], pred_profile=mean(X, dims=1))\n# compare to Aalen-Johansen fit\nres_aj\n\n\n# this approach operates on left censored outcomes (which operate in the background in model fitting)\nLSurvivalResp(enter, t, d, origintime=0)\nLSurvivalCompResp(enter, t, event) # automatically infers origin\n\n\n# can use the ID type to refer to units with multiple observations\nid, int, outt, data = dgm(MersenneTwister(), 1000, 10; regimefun = int_0)\nLSurvivalResp(int, outt, data[:,4], ID.(id))","category":"page"},{"location":"#Index-of-functions","page":"Help","title":"Index of functions","text":"","category":"section"},{"location":"","page":"Help","title":"Help","text":"","category":"page"},{"location":"#Function-help","page":"Help","title":"Function help","text":"","category":"section"},{"location":"","page":"Help","title":"Help","text":"Modules = [LSurvival]","category":"page"},{"location":"#LSurvival.AbstractLSurvivalParms","page":"Help","title":"LSurvival.AbstractLSurvivalParms","text":"AbstractLsurvParms\n\nAbstract type representing a model predictors and coefficient parameters\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractLSurvivalResp","page":"Help","title":"LSurvival.AbstractLSurvivalResp","text":"AbstractLsurvResp\n\nAbstract type representing a model response vector\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractNPSurv","page":"Help","title":"LSurvival.AbstractNPSurv","text":"Abstract type for non-parametric survival models, including Kaplan-Meier, Aalen Johansen, and Cox-model based estimates of survival using an Aalen-Johansen-like estimator\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractPH","page":"Help","title":"LSurvival.AbstractPH","text":"Abstract type for proportional hazards models\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractPSModel","page":"Help","title":"LSurvival.AbstractPSModel","text":"AbstractPS\n\nAbstract type for parametric survival models\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractSurvDist","page":"Help","title":"LSurvival.AbstractSurvDist","text":"AbstractSurvDist\n\nAbstract type for parametric survival distributions\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.ID","page":"Help","title":"LSurvival.ID","text":"Type for identifying individuals in survival outcomes.\n\nUsed for the id argument in \n\nOutcome types: LSurvivalResp, LSurvivalCompResp \nModel types: PHModel, KMRisk, AJRisk\n\nAccepts any Number or String. There is no significance to having this particular struct, but it enables easier use of multiple dispatch.\n\n[ID(i) for i in 1:10]\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.LSurvivalCompResp","page":"Help","title":"LSurvival.LSurvivalCompResp","text":"Outcome type for competing risk survival outcomes subject to left truncation and right censoring (not generally needed for users)\n\nParameters\n\nenter Time at observation start\nexit Time at observation end\ny event occurrence in observation\nwts observation weights\neventtimes unique event times\norigin origin on the time scale\nid person level identifier (must be wrapped in ID() function)\neventtypes vector of unique event types\neventmatrix matrix of indicators on the observation level\nSignatures:\n\n struct LSurvivalCompResp{\n E<:AbstractVector,\n X<:AbstractVector,\n Y<:AbstractVector,\n W<:AbstractVector,\n T<:Real,\n I<:AbstractLSurvivalID,\n V<:AbstractVector,\n M<:AbstractMatrix,\n } <: AbstractLSurvivalResp\n enter::E\n exit::X\n y::Y\n wts::W\n eventtimes::X\n origin::T\n id::Vector{I}\n eventtypes::V\n eventmatrix::M\n end\n\n LSurvivalCompResp(\n enter::E,\n exit::X,\n y::Y,\n wts::W,\n id::Vector{I}\n )\n\n LSurvivalCompResp(\n enter::E,\n exit::X,\n y::Y,\n id::Vector{I}\n )\n\n LSurvivalCompResp(\n enter::E,\n exit::X,\n y::Y,\n wts::W,\n )\n\n LSurvivalCompResp(\n enter::E,\n exit::X,\n y::Y,\n )\n\n LSurvivalCompResp(\n  exit::X,\n  y::Y,\n  ) where {X<:Vector,Y<:Union{Vector{<:Real},BitVector}}\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.LSurvivalResp","page":"Help","title":"LSurvival.LSurvivalResp","text":"Outcome type for survival outcome subject to left truncation and right censoring. \n\nWill not generally be needed by users\n\nParameters\n\nenter: Time at observation start\nexit: Time at observation end\ny: event occurrence in observation\nwts: observation weights\neventtimes: unique event times\norigin: origin on the time scale\nid: person level identifier (must be wrapped in ID() function)\n\n struct LSurvivalResp{\n E<:AbstractVector,\n X<:AbstractVector,\n Y<:AbstractVector,\n W<:AbstractVector,\n T<:Real,\n I<:AbstractLSurvivalID,\n } <: AbstractLSurvivalResp\n enter::E\n exit::X\n y::Y\n wts::W\n eventtimes::E\n origin::T\n id::Vector{I}\n end\n\n\n LSurvivalResp(\n    enter::E,\n    exit::X,\n    y::Y,\n    wts::W,\n    id::Vector{I},\n  ) where {\n    E<:Vector,\n    X<:Vector,\n    Y<:Union{Vector{<:Real},BitVector},\n    W<:Vector,\n    I<:AbstractLSurvivalID,\n}\n\n LSurvivalResp(\n enter::E,\n exit::X,\n y::Y,\n id::Vector{I},\n ) \n\n\n LSurvivalResp(\n  y::Vector{Y},\n  wts::W,\n  id::Vector{I},\n  ) where {Y<:AbstractSurvTime,W<:Vector,I<:AbstractLSurvivalID}\n\n LSurvivalResp(\n  enter::E,\n  exit::X,\n  y::Y,\n  ) where {E<:Vector,X<:Vector,Y<:Union{Vector{<:Real},BitVector}}\n\n LSurvivalResp(exit::X, y::Y) where {X<:Vector,Y<:Vector}\n\nExamples\n\n  # no late entry\n  LSurvivalResp([.5, .6], [1,0])\n\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.PHModel","page":"Help","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression (not generally needed for users)\n\nParameters\n\nR Survival response\nP        # parameters\nties String: \"efron\" or \"breslow\"\nfit Bool: logical for whether the model has been fitted\nbh AbstractMatrix: baseline hazard estimates\nSignatures\n\n mutable struct PHModel{G<:LSurvivalResp,L<:AbstractLSurvivalParms} <: AbstractPH\n R::G        # Survival response\n P::L        # parameters\n ties::String #\"efron\" or\"breslow\"\n fit::Bool\n bh::AbstractMatrix\n end\n\n PHModel(\n R::G,\n P::L,\n ties::String,\n fit::Bool,\n ) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n PHModel(R::G, P::L, ties::String) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n PHModel(R::G, P::L) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}\n\nMethods: fit, coef, confint, std_err, show\n\nExample\n\n using LSurvival\n using Random\n import LSurvival: _stepcox!, dgm_comprisk\n\n z,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);\n enter = zeros(length(t));\n X = hcat(x,z);\n R = LSurvivalResp(enter, t, Int.(d), wt)\n P = PHParms(X)\n mf = PHModel(R,P)\n  LSurvival._fit!(mf)\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.PHSurv","page":"Help","title":"LSurvival.PHSurv","text":"Mutable type for proportional hazards models (not generally needed by users)\n\nPHSsurv: Object type for proportional hazards regression\n\nsurv::Vector{Float64} risk::Matrix{Float64} basehaz::Vector{Float64} event::Vector{Float64}\n\nfitlist: vector of PHSurv objects (Cox model fits)\neventtypes: vector of unique event types\ntimes: unique event times\nsurv: Overall survival at each time\nrisk: Cause-specific risk  at each time (1 for each outcome type)\nbasehaz: baseline hazard for a specific event type\nevent: value of event type that occurred at each time\n\nMethods: fit, show\n\nmutable struct PHSurv{G<:Array{T} where {T<:PHModel}} <: AbstractNPSurv\nfitlist::G        \neventtypes::AbstractVector\ntimes::AbstractVector\nsurv::Vector{Float64}\nrisk::Matrix{Float64}\nbasehaz::Vector{Float64}\nevent::Vector{Float64}\nend\n\nPHSurv(fitlist::Array{T}, eventtypes) where {T<:PHModel}\nPHSurv(fitlist::Array{T}) where {T<:PHModel}\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.Strata","page":"Help","title":"LSurvival.Strata","text":"Type for identifying individuals in survival outcomes. Used for the strata argument in PHModel (not yet implemented)\n\nAccepts any Number or String. There is no significance to having this particular struct, but it enables easier use of multiple dispatch.\n\n[Strata(i) for i in 1:10]\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival._update_PHParms!-Union{Tuple{T}, Tuple{I}, Tuple{M}, Tuple{M, I, Array{Vector{T}, 1}, Array{Vector{T}, 1}}} where {M<:AbstractPH, I<:Int64, T<:Int64}","page":"Help","title":"LSurvival._update_PHParms!","text":"Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).\n\nUses Breslow's or Efron's partial likelihood.\n\nUpdates over all observations\n\nSignature\n\n_update_PHParms!(\n m::M,\n # big indexes\n ne::I,\n caseidxs::Vector{Vector{T}},\n risksetidxs::Vector{Vector{T}},\n ) where {M<:AbstractPH,I<:Int,T<:Int}\n\nupdatePHParms!(m, risksetidxs, caseidxs, ne, den)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.aalen_johansen-Tuple{Any, Any, Any}","page":"Help","title":"LSurvival.aalen_johansen","text":"Aalen-Johansen estimator for cumulative cause-specific risk (in the presence of competing events)\n\nSignatures\n\n StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\n aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; kwargs...)\n\n\nKeyword arguments\n\nwts::Vector{<:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation\nid::Vector{<:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)\natol = 0.00000001; absolute tolerance for defining tied event times\nkeepy = true; keep the outcome vector after fitting (may save memory with large datasets)\neps = 0.00000001; deprecated (replaced by atol)\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\n   # event variable is coded 0[referent],1,2\nm = fit(AJSurv, enter, t, event)\nmw = fit(AJSurv, enter, t, event, wts=wt)\n\nor, equivalently:\n\naalen_johansen(enter, t, event, wts=wt)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Tuple{MersenneTwister, PHModel, Int64}","page":"Help","title":"LSurvival.bootstrap","text":"Bootstrapping coefficients of a proportional hazards model\n\nSignatures\n\n# single bootstrap draw, keeping the entire object\nbootstrap(rng::MersenneTwister, m::PHModel)\nbootstrap(m::PHModel)\n# muliple bootstrap draws, keeping only coefficient estimates\nbootstrap(rng::MersenneTwister, m::PHModel, iter::Int; kwargs...)\nbootstrap(m::PHModel, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up\n\nusing LSurvival, Random\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 500, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nweights = rand(length(d))\n\n# survival outcome:\nR = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only\nP = PHParms(X)\n\nMod = PHModel(R, P)\nLSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)\n\n\n# careful propogation of bootstrap sampling\nidx, R2 = bootstrap(R)\nP2 = bootstrap(idx, P)\nModb = PHModel(R2, P2)\nLSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)\n\n# convenience function for bootstrapping a model\nModc = bootstrap(Mod)\nLSurvival._fit!(Modc, start=Modc.P._B);\nModc\nModc.P.X == nothing\nModc.R == nothing\n\n\nBootstrap Cox model coefficients\n\nLSurvival._fit!(mb, keepx=true, keepy=true, start=[0.0, 0.0])\n\nusing LSurvival, Random\nres = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 200)\nint = zeros(length(d)) # no late entry\nX = hcat(z, x)\n\nmainfit = fit(PHModel, X, int, outt, d .* (event .== 1), keepx=true, keepy=true)\n\nfunction stddev_finite(x)\n n = length(x)\n mnx = sum(x)/n\n ret = sum((x .- mnx) .^ 2)\n ret /= n-1\n sqrt(ret)\nend\n\n# bootstrap standard error versus asymptotic\nmb = bootstrap(MersenneTwister(123123), mainfit, 200)\n## bootstrap standard error\n[stddev_finite(mb[:,i]) for i in 1:2]\n## asymptotic standard error\nstderror(mainfit)\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Tuple{MersenneTwister, PHModel}","page":"Help","title":"LSurvival.bootstrap","text":"Bootstrapping coefficients of a proportional hazards model\n\nSignatures\n\n# single bootstrap draw, keeping the entire object\nbootstrap(rng::MersenneTwister, m::PHModel)\nbootstrap(m::PHModel)\n# muliple bootstrap draws, keeping only coefficient estimates\nbootstrap(rng::MersenneTwister, m::PHModel, iter::Int; kwargs...)\nbootstrap(m::PHModel, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up\n\nusing LSurvival, Random\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 500, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nweights = rand(length(d))\n\n# survival outcome:\nR = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only\nP = PHParms(X)\n\nMod = PHModel(R, P)\nLSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)\n\n\n# careful propogation of bootstrap sampling\nidx, R2 = bootstrap(R)\nP2 = bootstrap(idx, P)\nModb = PHModel(R2, P2)\nLSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)\n\n# convenience function for bootstrapping a model\nModc = bootstrap(Mod)\nLSurvival._fit!(Modc, start=Modc.P._B);\nModc\nModc.P.X == nothing\nModc.R == nothing\n\n\nBootstrap Cox model coefficients\n\nLSurvival._fit!(mb, keepx=true, keepy=true, start=[0.0, 0.0])\n\nusing LSurvival, Random\nres = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 200)\nint = zeros(length(d)) # no late entry\nX = hcat(z, x)\n\nmainfit = fit(PHModel, X, int, outt, d .* (event .== 1), keepx=true, keepy=true)\n\nfunction stddev_finite(x)\n n = length(x)\n mnx = sum(x)/n\n ret = sum((x .- mnx) .^ 2)\n ret /= n-1\n sqrt(ret)\nend\n\n# bootstrap standard error versus asymptotic\nmb = bootstrap(MersenneTwister(123123), mainfit, 200)\n## bootstrap standard error\n[stddev_finite(mb[:,i]) for i in 1:2]\n## asymptotic standard error\nstderror(mainfit)\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Tuple{Vector{Int64}, PHParms}","page":"Help","title":"LSurvival.bootstrap","text":"Bootstrap sampling of a proportional hazards predictor object\n\nusing LSurvival, Random\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nweights = rand(length(d))\n\n# survival outcome:\nR = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only\nP = PHParms(X)\nidx, R2 = bootstrap(R)\nP2 = bootstrap(idx, P)\n\nMod = PHModel(R2, P2)\nLSurvival._fit!(Mod, start=Mod.P._B)\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M<:AJSurv","page":"Help","title":"LSurvival.bootstrap","text":"Bootstrap methods for Aalen-Johansen cumulative risk estimator\n\nSignatures\n\n # single bootstrap draw, keeping the entire object\n bootstrap(rng::MersenneTwister, m::AJSurv)\n bootstrap(m::AJSurv)\n\n # muliple bootstrap draws, keeping only coefficient estimates\n bootstrap(rng::MersenneTwister, m::AJSurv, iter::Int; kwargs...)\n bootstrap(m::AJSurv, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up\n\nusing LSurvival\nusing Random\n\nz, x, t, d, event, wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 100)\nid = 1:length(x)\nenter = zeros(length(t))\n\naj1 = aalen_johansen(enter, t, event, id=ID.(id), wts=wt)\naj2 = bootstrap(aj1, keepy=false);\najboot = bootstrap(aj1, 10, keepy=false);\naj1\n\n\naj1.R\naj2.R\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M<:KMSurv","page":"Help","title":"LSurvival.bootstrap","text":"Bootstrap methods for Kaplan-Meier survival curve estimator\n\nSignatures\n\n # single bootstrap draw, keeping the entire object\n bootstrap(rng::MersenneTwister, m::KMSurv)\n bootstrap(m::KMSurv)\n\n # muliple bootstrap draws, keeping only coefficient estimates\n bootstrap(rng::MersenneTwister, m::KMSurv, iter::Int; kwargs...)\n bootstrap(m::KMSurv, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the survival probability at the end of follow up\n\nusing LSurvival\nusing Random\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nwts = rand(length(d))\n\nkm1 = kaplan_meier(int, outt, d, id=ID.(id), wts=wts)\nkm2 = bootstrap(km1, keepy=false)\nkm3 = bootstrap(km1, 10, keepy=false)\nkm1\n\nkm1.R\nkm2.R\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T<:LSurvivalCompResp","page":"Help","title":"LSurvival.bootstrap","text":"Bootstrapping sampling of a competing risk survival response\n\nSignatures\n\nbootstrap(rng::MersenneTwister, R::T) where {T<:LSurvivalCompResp}\nbootstrap(R::T) where {T<:LSurvivalCompResp}\n\nz,x,t,d,event,weights =\nLSurvival.dgm_comprisk(MersenneTwister(1212), 300)\nenter = zeros(length(event))\n\n# survival outcome:\nR = LSurvivalCompResp(enter, t, event, weights, ID.(collect(1:length(t))))    # specification with ID only\nbootstrap(R) # note that entire observations/clusters identified by id are kept\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T<:LSurvivalResp","page":"Help","title":"LSurvival.bootstrap","text":"Bootstrapping sampling of a survival response\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nweights = rand(length(d))\n\n# survival outcome:\nR = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.calcp-Tuple{Any}","page":"Help","title":"LSurvival.calcp","text":"p-value for a (null) standard normal distribution     depends on SpecialFunctions     https://en.wikipedia.org/wiki/Normal_distribution\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.cdfchisq-Tuple{Any, Any}","page":"Help","title":"LSurvival.cdfchisq","text":"quantile function for a chi-squared distribution     depends on SpecialFunctions     https://en.wikipedia.org/wiki/Chi-squared_distribution\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.cdfnorm-Tuple{Any}","page":"Help","title":"LSurvival.cdfnorm","text":"quantile function for a standard normal distribution     depends on SpecialFunctions     https://en.wikipedia.org/wiki/Normal_distribution\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.coxph-Tuple{Any, Any, Any, Any, Vararg{Any}}","page":"Help","title":"LSurvival.coxph","text":"Fit method for AbstractPH objects (Cox models)\n\nKeyword arguments (used here, and passed on to internal structs)\n\nties \"breslow\" or \"efron\" (default)\nwts observation weights\nties \"breslow\" or \"efron\" (default)\noffset not currently used at all\nfitargs arguments passed to other structs, which include\nid cluster or individual level ID (defaults to a unique value for each row of data) see note below on ID\ncontrasts StatsModel style contrasts (dicts) that can be used for variable transformations/indicator variable creation (e.g. https://juliastats.org/StatsModels.jl/stable/contrasts/)\nSignatures\n\n  fit(::Type{M},\n  X::AbstractMatrix,#{<:FP},\n  enter::AbstractVector{<:Real},\n  exit::AbstractVector{<:Real},\n  y::Union{AbstractVector{<:Real},BitVector}\n  ;\n  ties =\"breslow\",\n  wts::AbstractVector{<:Real}      = similar(y, 0),\n  offset::AbstractVector{<:Real}   = similar(y, 0),\n  fitargs...) where {M<:AbstractPH}\n\n coxph(f::FormulaTerm, data; kwargs...)\n\n  coxph(X, enter, exit, y, args...; kwargs...)\n\n   using LSurvival, Random\n   z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n   enter = zeros(length(t));\n   X = hcat(x,rand(length(x)));\n    m = fit(PHModel, X, enter, t, d, ties=\"efron\")\n   m2 = fit(PHModel, X, enter, t, d, ties=\"breslow\")\n   coeftable(m)\n\nNote on use of id keyword\n\nid is not needed in person-period structure data for standard estimates or confidence intervals\n\n  using Random, LSurvival\n     id, int, outt, dat =\n         LSurvival.dgm(MersenneTwister(123123), 100, 100; afun = LSurvival.int_0)\n     data = (\n             int = int,\n             outt = outt,\n             d = dat[:,4] .== 1,\n             x = dat[:,1],\n             z = dat[:,2]\n     )\n\n     f = @formula(Surv(int, outt,d)~x+z)\n     coxph(f, data)\n\nBUT, you must specify id to get appropriate robust variance and some other statistics.\n\nHere is an example where the same data are presented in two different ways, which should yield identical statistics when used in Cox model.\n\n dat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n  )\n  ft = coxph(@formula(Surv(time,status)~x),dat1)\n  bic(ft)\n  nobs(ft)\n  dof_residual(ft)\n  # lrtest is another one\n\n  stderror(ft)                     # model based\n  stderror(ft, type=\"robust\")   # robust standard error, based on dfbeta residuals\n  ft\n\n  # now using \"clustered\" data with multiple observations per individual\n dat1clust= (\n     id = [1,2,3,3,4,4,5,5,6,6],\n     enter = [0,0,0,1,0,1,0,1,0,1],\n     exit = [1,1,1,6,1,6,1,8,1,9],\n     status = [1,0,0,1,0,1,0,0,0,1],\n     x = [1,1,1,1,0,0,0,0,0,0]\n )\n \n # use the `id` parameter with the ID struct\n ft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id))\n bic(ft2)                       # CORRECT        \n nobs(ft2)                      # CORRECT\n dof_residual(ft2)              # CORRECT\n  \n stderror(ft2)                  # model based (CORRECT)\n stderror(ft2, type=\"robust\")   # robust standard error, based on `id` level dfbeta residuals (CORRECT)\n # once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics\n ft2   # CORRECT (compare to `ft` object)\n\nNOTE THE FOLLOWING IS INCORRECT because the id keyword is omitted\n\n ft2w = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust)\n bic(ft2w)                          # INCORRECT \n nobs(ft2w)                         # INCORRECT\n dof_residual(ft2w)                 # INCORRECT\n\n stderror(ft2w)                     # model based (CORRECT)\n stderror(ft2w, type=\"robust\")      # robust variance (INCORRECT)\n \n ft2w # the coefficient table now shows incorrect confidence intervals and test statistics\n  \n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.ddloglik!-Union{Tuple{D}, Tuple{Any, D, Vararg{Any, 6}}} where D<:AbstractSurvDist","page":"Help","title":"LSurvival.ddloglik!","text":"Hessian contribution for an observation in a parametric survival model\n\n    d = m.d\n    i = 1\n    enter = m.R.enter[i]\n    exit = m.R.exit[i]\n    y = m.R.y[i]\n    wts = m.R.wts[i]\n    x = m.P.X[i,:]\n    θ=[1,0,.4]\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.dgm-Tuple{MersenneTwister, Int64, Int64}","page":"Help","title":"LSurvival.dgm","text":"Generating discrete survival data without competing risks\n\nSignatures\n\ndgm(rng::MersenneTwister, n::Int, maxT:Int; afun = int_0, yfun = yprob, lfun = lprob)\n\ndgm(n::Int, maxT::Int; kwargs...)\n\nUsage: dgm(rng, n, maxT;afun=int0, yfun=yprob, lfun=lprob) dgm(n, maxT;afun=int0, yfun=yprob, lfun=lprob)\n\nWhere afun, yfun, and lfun are all functions that take arguments v,l,a and output time-specific values of a, y, and l respectively Example:\n\n\nexpit(mu) =  inv(1.0+exp(-mu))\n\nfunction aprob(v,l,a)\nexpit(-1.0 + 3*v + 2*l)\nend\n  \nfunction lprob(v,l,a)\nexpit(-3 + 2*v + 0*l + 0*a)\nend\n  \nfunction yprob(v,l,a)\nexpit(-3 + 2*v + 0*l + 2*a)\nend\n  # 10 individuals followed for up to 5 times\nLSurvival.dgm(10, 5;afun=aprob, yfun=yprob, lfun=lprob)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.dgm_comprisk-Tuple{MersenneTwister, Int64}","page":"Help","title":"LSurvival.dgm_comprisk","text":"Generating continuous survival data with competing risks\n\nSignatures\n\ndgm_comprisk(rng::MersenneTwister, n::Int)\n\ndgm_comprisk(n::Int)\n\n    - rng = random number generator    \n    - n = sample size\n\nExample:\n\nusing LSurvival\n# 100 individuals with two competing events\nz,x,t,d,event,weights = LSurvival.dgm_comprisk(100)\n    \n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.dloglik!-Union{Tuple{D}, Tuple{Any, D, Vararg{Any, 6}}} where D<:AbstractSurvDist","page":"Help","title":"LSurvival.dloglik!","text":"Gradient contribution for an observation in a parametric survival model\n\n    d = m.d\n    i = 1\n    enter = m.R.enter[i]\n    exit = m.R.exit[i]\n    y = m.R.y[i]\n    wts = m.R.wts[i]\n    x = m.P.X[i,:]\n    θ=[1,0,.4]\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.jackknife-Tuple{M} where M<:AJSurv","page":"Help","title":"LSurvival.jackknife","text":"Obtain jackknife (leave-one-out) estimates from a Aalen-Johansen risk curve (risk at end of follow-up) by refitting the model n times\n\nSignatures\n\njackknife(m::M;kwargs...) where {M<:AJSurv}\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.jackknife-Tuple{M} where M<:KMSurv","page":"Help","title":"LSurvival.jackknife","text":"Obtain jackknife (leave-one-out) estimates from a Kaplan-Meier survival curve (survival at end of follow-up) by refitting the model n times\n\nSignatures\n\njackknife(m::M;kwargs...) where {M<:KMSurv}\n\nusing LSurvival, Random, StatsBase\n\ndat1 = (time = [1, 1, 6, 6, 8, 9], status = [1, 0, 1, 1, 0, 1], x = [1, 1, 1, 0, 0, 0])\n\ndat1clust = (\n  id = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6],\n  enter = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1],\n  exit = [1, 1, 1, 6, 1, 6, 1, 8, 1, 9],\n  status = [1, 0, 0, 1, 0, 1, 0, 0, 0, 1],\n  x = [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],\n)\n\nm = kaplan_meier(dat1.time, dat1.status)\na = aalen_johansen(dat1.time, dat1.status)\nmc = kaplan_meier(dat1clust.enter, dat1clust.exit, dat1clust.status, id=ID.(dat1clust.id))\nac = aalen_johansen(dat1clust.enter, dat1clust.exit, dat1clust.status, id=ID.(dat1clust.id))\njk = jackknife(m);\njkc = jackknife(mc);\njka = jackknife(a);\nbs = bootstrap(mc, 100);\nstd(bs[:,1])\nstderror(m, type=\"jackknife\")\nstderror(mc, type=\"jackknife\")\n@assert jk == jkc\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.jackknife-Tuple{M} where M<:PHModel","page":"Help","title":"LSurvival.jackknife","text":"Obtain jackknife (leave-one-out) estimates from a Cox model by refitting the model n times\n\nusing LSurvival, Random, StatsBase\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(112), 100, 10; afun = LSurvival.int_0)\ndata[:, 1] = round.(data[:, 1], digits = 3)\nd, X = data[:, 4], data[:, 1:3]\nwt = rand(length(d))\nwt ./= (sum(wt) / length(wt))\nm = coxph(X,int, outt,d, wts=wt, id=ID.(id))\n\njk = jackknife(m);\nbs = bootstrap(MersenneTwister(12321), m, 1000);\nN = nobs(m)\n#comparing estimate with jackknife estimate with bootstrap mean\nhcat(coef(m), mean(jk, dims=1)[1,:], mean(bs, dims=1)[1,:])\nsemb = stderror(m)\nsebs = std(bs, dims=1)\nsero = stderror(m, type=\"robust\")\nsejk = stderror(m, type=\"jackknife\")\nsejk_manual = std(jk, dims=1, corrected=false) .* sqrt(N-1)\n\nsqrt.(diag(LSurvival.jackknife_vcov(m)))\n\nhcat(semb, sebs[1,:], sejk, sejk_manual[1,:], sero)\n\ndat1 = (time = [1, 1, 6, 6, 8, 9], status = [1, 0, 1, 1, 0, 1], x = [1, 1, 1, 0, 0, 0])\ndat1clust = (\n  id = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6],\n  enter = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1],\n  exit = [1, 1, 1, 6, 1, 6, 1, 8, 1, 9],\n  status = [1, 0, 0, 1, 0, 1, 0, 0, 0, 1],\n  x = [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],\n)\n\nm = coxph(@formula(Surv(time, status)~x),dat1)\nmc = coxph(@formula(Surv(enter, exit, status)~x),dat1clust, id=ID.(dat1clust.id))\njk = jackknife(m);\njkc = jackknife(mc);\nbs = bootstrap(mc, 100);\nstd(bs[:,1])\nstderror(m, type=\"jackknife\")\nstderror(mc, type=\"jackknife\")\n@assert jk == jkc\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.kaplan_meier-Tuple{Any, Any, Any}","page":"Help","title":"LSurvival.kaplan_meier","text":"Kaplan-Meier estimator for cumulative conditional risk\n\nSignatures\n\nStatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\nkaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; kwargs...)\n\nKeyword arguments\n\nwts::Vector{<:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation\nid::Vector{<:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)\natol = 0.00000001; absolute tolerance for defining tied event times\ncensval = 0;  value of the outcome to be considered a censored event\nkeepy = true; keep the outcome vector after fitting (may save memory with large datasets)\neps = 0.00000001; deprecated (replaced by atol)\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\nm = fit(KMSurv, enter, t, d)\nmw = fit(KMSurv, enter, t, d, wts=wt)\n\nor, equivalently:\n\nkaplan_meier(enter, t, d, wts=wt)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lgh!-Union{Tuple{M}, Tuple{M, Any}} where M<:PSModel","page":"Help","title":"LSurvival.lgh!","text":"dat1 = (time = [1, 1, 6, 6, 8, 9], status = [1, 0, 1, 1, 0, 1], x = [1, 1, 1, 0, 0, 0]) enter = zeros(length(dat1.time)) t = dat1.time d = dat1.status X = hcat(ones(length(dat1.x)), dat1.x) wt = ones(length(t))\n\ndist = Exponential() P = PSParms(X[:,1:1], extraparms=length(dist)-1) P = PSParms(X, extraparms=length(dist)-1) P.B P.grad R = LSurvivalResp(dat1.time, dat1.status)    # specification with ID only m = PSModel(R,P,dist)\n\nλ=1 θ = rand(2) lgh!(m, θ) θ .+= inv(-m.P.hess) * m.P.grad * λ\n\nlgh!(m, θ .+ [-.00, 0, 0]) lgh!(m, θ .+ [-.01, 0.05, 0.05])\n\nm.P._LL\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lgh_breslow!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M<:AbstractPH","page":"Help","title":"LSurvival.lgh_breslow!","text":"Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).\n\nUses Breslow's partial likelihood.\n\nUpdates over all observations\n\nSignature\n\nlgh_breslow!(m::M, j, caseidx, risksetidx) where {M<:AbstractPH}\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lgh_efron!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M<:AbstractPH","page":"Help","title":"LSurvival.lgh_efron!","text":"Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).\n\nUses Efron's partial likelihood.\n\nUpdates over all observations\n\nSignature\n\nlgh_efron!(m::M, j, caseidx, risksetidx) where {M<:AbstractPH}\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.loglik-Union{Tuple{D}, Tuple{D, Vararg{Any, 6}}} where D<:AbstractSurvDist","page":"Help","title":"LSurvival.loglik","text":"Log likelihood contribution for an observation in a parametric survival model\n\n    d = m.d\n    i = 1\n    enter = m.R.enter[i]\n    exit = m.R.exit[i]\n    y = m.R.y[i]\n    wts = m.R.wts[i]\n    x = m.P.X[i,:]\n    θ=[1,0,.4]\n    \n    m.P._B\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lpdf-Tuple{LSurvival.Exponential, Any, Any, Any}","page":"Help","title":"LSurvival.lpdf","text":"Log-likelihood calculation for Exponential regression: PDF\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Exponential()\nlpdf_gradient(d, θ, t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lpdf-Tuple{LSurvival.Exponential, Any}","page":"Help","title":"LSurvival.lpdf","text":"Log probability distribution function: Exponential distribution\n\n```julia\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Exponential()\nlpdf(d, t)\n```\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lpdf-Tuple{LSurvival.Lognormal, Any, Any, Any}","page":"Help","title":"LSurvival.lpdf","text":"Log likelihood calculation for Lognormal regression: PDF\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Lognormal()\nlpdf(d, vcat(θ,ρ), t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lpdf-Tuple{LSurvival.Lognormal, Any}","page":"Help","title":"LSurvival.lpdf","text":"log probability distribution function: Weibull distribution\n\nLocation scale representation (Klein Moeschberger ch 12)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lpdf-Tuple{LSurvival.Weibull, Any, Any, Any}","page":"Help","title":"LSurvival.lpdf","text":"Log-likelihood calculation for weibull regression: PDF\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Weibull()\nlpdf(d, vcat(θ,ρ), t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lpdf-Tuple{LSurvival.Weibull, Any}","page":"Help","title":"LSurvival.lpdf","text":"Log probability distribution function: Weibull distribution\n\nlocation scale representation (Klein Moeschberger ch 12)\n\nα=0.1   # location\nρ=-1.2  # log(scale)\ntime=2\nlpdf(Weibull(α, ρ), time)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lpdf_gradient-Tuple{LSurvival.Exponential, Any, Any, Any}","page":"Help","title":"LSurvival.lpdf_gradient","text":"Gradient calculation for Exponential regression: PDF\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Exponential()\nlpdf_gradient(d, θ, t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lpdf_gradient-Tuple{LSurvival.Lognormal, Any, Any, Any}","page":"Help","title":"LSurvival.lpdf_gradient","text":"Gradient calculation for Lognormal regression: PDF\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Lognormal()\nlpdf_gradient(d, vcat(θ,ρ), t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lpdf_gradient-Tuple{LSurvival.Weibull, Any, Any, Any}","page":"Help","title":"LSurvival.lpdf_gradient","text":"Gradient calculation for weibull regression: PDF\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\n#α = dot(β,x)\nd = Weibull()\nlpdf_gradient(d, vcat(θ,ρ), t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lpdf_hessian-Tuple{LSurvival.Exponential, Any, Any, Any}","page":"Help","title":"LSurvival.lpdf_hessian","text":"Hessian calculation for Exponential regression: PDF\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Exponential()\nlpdf_hessian(d, θ, t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lpdf_hessian-Tuple{LSurvival.Exponential, Any}","page":"Help","title":"LSurvival.lpdf_hessian","text":"Hessian calculation for Weibull distribution: PDF\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Exponential(α)\nlpdf_hessian(d, t)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lpdf_hessian-Tuple{LSurvival.Lognormal, Any, Any, Any}","page":"Help","title":"LSurvival.lpdf_hessian","text":"Hessian calculation for Log-normal regression: PDF\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Lognormal()\nlpdf_hessian(d, vcat(θ,ρ), t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lpdf_hessian-Tuple{LSurvival.Lognormal, Any}","page":"Help","title":"LSurvival.lpdf_hessian","text":"Hessian calculation for Log-normal distribution: PDF\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Lognormal(α, ρ)\nlpdf_hessian(d, t)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lpdf_hessian-Tuple{LSurvival.Weibull, Any, Any, Any}","page":"Help","title":"LSurvival.lpdf_hessian","text":"Hessian calculation for weibull regression: PDF\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Weibull()\nlpdf_hessian(d, vcat(θ,ρ), t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lsurv-Tuple{LSurvival.Exponential, Any, Any, Any}","page":"Help","title":"LSurvival.lsurv","text":"Log-likelihood calculation for Exponential regression: Survival\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Exponential()\nlsurv(d, θ, t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lsurv-Tuple{LSurvival.Exponential, Any}","page":"Help","title":"LSurvival.lsurv","text":"Log survival function: Exponential distribution\n\n```julia\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Exponential()\nlsurv(d, t)\n```\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lsurv-Tuple{LSurvival.Lognormal, Any, Any, Any}","page":"Help","title":"LSurvival.lsurv","text":"Log likelihood calculation for Log-normal regression: Survival\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Lognormal()\nlsurv(d, vcat(θ,ρ), t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lsurv-Tuple{LSurvival.Lognormal, Any}","page":"Help","title":"LSurvival.lsurv","text":"log probability distribution function: Weibull distribution\n\nLocation scale representation (Klein Moeschberger ch 12)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lsurv-Tuple{LSurvival.Weibull, Any, Any, Any}","page":"Help","title":"LSurvival.lsurv","text":"Log-likelihood calculation for weibull regression: Survival\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Weibull()\nlsurv(d, vcat(θ,ρ), t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lsurv-Tuple{LSurvival.Weibull, Any}","page":"Help","title":"LSurvival.lsurv","text":"Log survival distribution function: Weibull distribution\n\nlocation, log(scale) representation (Klein Moeschberger ch 12)\n\nα=0.1   # location\nρ=-1.2  # log(scale)\ntime=2\nlsurv(Weibull(α, ρ), time)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lsurv_gradient-Tuple{LSurvival.Exponential, Any, Any, Any}","page":"Help","title":"LSurvival.lsurv_gradient","text":"Gradient calculation for Exponential regression: Survival\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Exponential()\nlsurv_gradient(d, θ, t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lsurv_gradient-Tuple{LSurvival.Lognormal, Any, Any, Any}","page":"Help","title":"LSurvival.lsurv_gradient","text":"Gradient calculation for Log-normal regression: Survival\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Lognormal()\nlsurv_gradient(d, vcat(θ,ρ), t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lsurv_gradient-Tuple{LSurvival.Weibull, Any, Any, Any}","page":"Help","title":"LSurvival.lsurv_gradient","text":"Gradient calculation for weibull regression: Survival\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Weibull()\nlsurv_gradient(d, vcat(θ,ρ), t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lsurv_hessian-Tuple{LSurvival.Exponential, Any, Any, Any}","page":"Help","title":"LSurvival.lsurv_hessian","text":"Hessian calculation for Exponential regression: Survival\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Exponential()\nlsurv_hessian(d, θ, t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lsurv_hessian-Tuple{LSurvival.Exponential, Any}","page":"Help","title":"LSurvival.lsurv_hessian","text":"Hessian calculation for Exponential distribution: Survival\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Exponential(α)\nlsurv_hessian(d, t)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lsurv_hessian-Tuple{LSurvival.Lognormal, Any, Any, Any}","page":"Help","title":"LSurvival.lsurv_hessian","text":"Hessian calculation for Log-normal regression: Survival\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Lognormal()\nlsurv_hessian(d, vcat(θ,ρ), t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lsurv_hessian-Tuple{LSurvival.Lognormal, Any}","page":"Help","title":"LSurvival.lsurv_hessian","text":"Hessian calculation for Log-normal distribution: Survival\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Lognormal(α, ρ)\nlsurv_hessian(d, t)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lsurv_hessian-Tuple{LSurvival.Weibull, Any, Any, Any}","page":"Help","title":"LSurvival.lsurv_hessian","text":"Hessian calculation for weibull regression: Survival\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Weibull()\nlsurv_hessian(d, vcat(θ,ρ), t, x)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lsurv_hessian-Tuple{LSurvival.Weibull, Any}","page":"Help","title":"LSurvival.lsurv_hessian","text":"Hessian calculation for Weibull distribution: Survival\n\nβ = [-2, 1.2]\nx = [2,.1]\nρ = -0.5\nt = 3.0\nα = dot(β,x)\nd = Weibull(α, ρ)\nlsurv_hessian(d, t)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.qstdnorm-Tuple{Any}","page":"Help","title":"LSurvival.qstdnorm","text":"quantile function for a standard normal distribution     depends on SpecialFunctions     https://en.wikipedia.org/wiki/Normal_distribution\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.qweibull-Tuple{Any, Any, Any}","page":"Help","title":"LSurvival.qweibull","text":"Quantile function for the Weibull distribution\n\nlightweight function used for simulation\n\n    Note that there is no checking that parameters α,ρ are positively bound, and p ∈ (0,1), and errors will be given if this is not the case\n\nSignature:\n\nqweibull(p::Real,α::Real,ρ::Real)\n\nquantile(Weibull(.75, 1.1), .3) # cross reference the approach in the Distributions package\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.randweibull-Tuple{Any, Any, Any}","page":"Help","title":"LSurvival.randweibull","text":"Random draw from Weibull distribution\n\nlightweight function used for simulation\n\nNote that there is no checking that parameters α,ρ are positively bound, and errors will be given if this is not the case\n\nSignatures:\n\nrandweibull(rng::MersenneTwister,α::Real,ρ::Real)\nrandweibull(α::Real,ρ::Real)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.risk_from_coxphmodels-Union{Tuple{T}, Tuple{Vector{T}, Vararg{Any}}} where T<:PHModel","page":"Help","title":"LSurvival.risk_from_coxphmodels","text":"Survival curve estimation using multiple cox models\n\nSignatures\n\n  risk_from_coxphmodels(fitlist::Vector{T}, args...; kwargs...) where {T<:PHModel}\n\n  fit(::Type{M}, fitlist::Vector{T}, ; fitargs...) where {M<:PHSurv,T<:PHModel}\n\nOptional keywords\n\ncoef_vectors = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]\npred_profile = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]\n\n using LSurvival\n using Random\n # event variable is coded 0[referent],1,2\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n\n ft1 = coxph(hcat(x,z), enter, t, (event .== 1))\n nidx = findall(event .!= 1)\n ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))\n\n # risk at referent levels of `x` and `z`\n risk_from_coxphmodels([ft1,ft2])\n\n # risk at average levels of `x` and `z`\n mnx = sum(x)/length(x)\n mnz = sum(z)/length(z)\n # equivalent\n fit(PHSurv, [ft1,ft2], pred_profile=[mnx,mnz])\n risk_from_coxphmodels([ft1,ft2], pred_profile=[mnx,mnz])\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.survivaldata-Tuple","page":"Help","title":"LSurvival.survivaldata","text":"Loading example survival analysis datasets\n\nusing LSurvival, Plots # note Plots does not install by default\nheartdata = survivaldata(\"heart\")\nft = coxph(@formula(Surv(start, stop, event)~surgery), heartdata);\n# plot baseline cumulative hazard\nbasehazplot(ft)\n# plot Schoenfeld residuals\ncoxdx(ft)  \n\n\n\n\n\n","category":"method"},{"location":"#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, AJSurv}","page":"Help","title":"RecipesBase.apply_recipe","text":"Recipe for aalen-johansen risk curve\n\n    using Plots, LSurvival\n    res = z, x, outt, d, event, weights = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)\n    int = zeros(length(d)) # no late entry\n    \n        c = fit(AJSurv, int, outt, event)\n        #risk2 = aalen_johansen(int, outt, event)\n        plot(c)\n\n\n\n\n\n","category":"method"},{"location":"#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, KMSurv}","page":"Help","title":"RecipesBase.apply_recipe","text":"Plotting a kaplan meier curve\n\n    using Plots, LSurvival\ndat4 = (\n    id = [1, 1, 2, 2, 2, 3, 4, 5, 5, 6],\n    enter = [1, 2, 5, 4, 6, 7, 3, 6, 8, 0],\n    exit = [2, 5, 6, 7, 8, 9, 6, 8, 14, 9],\n    status = [0, 1, 0, 0, 1, 0, 1, 0, 0, 1],\n    x = [0.1, 0.1, 1.5, 1.5, 1.5, 0, 0, 0, 0, 3],\n    z = [1, 1, 0, 0, 0, 0, 0, 1, 1, 0],\n    w = [0, 0, 0, 0, 0, 1, 1, 1, 1, 0],\n)\nR = LSurvivalResp(dat4.enter, dat4.exit, dat4.status)\n    k = kaplan_meier(dat4.enter, dat4.exit, dat4.status)\n    plot(k)\n\n\n\n\n\n","category":"method"},{"location":"#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.BaseHazPlot}","page":"Help","title":"RecipesBase.apply_recipe","text":"Plotting baseline hazard for a Cox model\n\nusing Plots, LSurvival\ndat2 = (\n    enter = [1, 2, 5, 2, 1, 7, 3, 4, 8, 8],\n    exit = [2, 3, 6, 7, 8, 9, 9, 9, 14, 17],\n    status = [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],\n    x = [1, 0, 0, 1, 0, 1, 1, 1, 0, 0],\n)\nfte = coxph(@formula(Surv(enter, exit, status)~x), dat2, maxiter=0)\nftb = coxph(@formula(Surv(enter, exit, status)~x), dat2, ties=\"breslow\", maxiter=0)\n\nplot(fte, label=\"Efron\")\nplot!(ftb, label=\"Breslow\")\n\n\n\n\n\n","category":"method"},{"location":"#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.CoxDX}","page":"Help","title":"RecipesBase.apply_recipe","text":"\nusing Plots, LSurvival\ndat2 = (\n    enter = [1, 2, 5, 2, 1, 7, 3, 4, 8, 8],\n    exit = [2, 3, 6, 7, 8, 9, 9, 9, 14, 17],\n    status = [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],\n    x = [1, 0, 0, 1, 0, 1, 1, 1, 0, 0],\n)\nfte = coxph(@formula(Surv(enter, exit, status)~x), dat2)\n\ncoxdx(fte)\n\n\n\n\n\n\n","category":"method"},{"location":"#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.CoxInfluence}","page":"Help","title":"RecipesBase.apply_recipe","text":"using Plots, LSurvival\ndat2 = (\n    enter = [1, 2, 5, 2, 1, 7, 3, 4, 8, 8],\n    exit = [2, 3, 6, 7, 8, 9, 9, 9, 14, 17],\n    status = [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],\n    x = [1, 0, 0, 1, 0, 1, 1, 1, 0, 0],\n)\nfte = coxph(@formula(Surv(enter, exit, status)~x), dat2)\n\ncoxinfluence(fte, type=\"jackknife\", par=1)\ncoxinfluence!(fte, type=\"dfbeta\", color=:red, par=1)\n\n\n\n\n\n\n","category":"method"},{"location":"#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvivalResp}","page":"Help","title":"RecipesBase.apply_recipe","text":"Plotting LSurvivalResp objects (outcomes in cox models, kaplan meier curves, parametric survival models)\n\nRecipe for plotting time-to-event outcomes\n\nusing Plots, LSurvival\n\ndat4 = (\n    id = [1, 1, 2, 2, 2, 3, 4, 5, 5, 6],\n    enter = [1, 2, 5, 4, 6, 7, 3, 6, 8, 0],\n    exit = [2, 5, 6, 7, 8, 9, 6, 8, 14, 9],\n    status = [0, 1, 0, 0, 1, 0, 1, 0, 0, 1],\n    x = [0.1, 0.1, 1.5, 1.5, 1.5, 0, 0, 0, 0, 3],\n    z = [1, 1, 0, 0, 0, 0, 0, 1, 1, 0],\n    w = [0, 0, 0, 0, 0, 1, 1, 1, 1, 0],\n)\nR = LSurvivalResp(dat4.enter, dat4.exit, dat4.status)\nplot([[R.enter[i], R.exit[i]] for i in eachindex(R.enter)], [[i, i] for i in values(R.id)])\n\n\n\n\n\n","category":"method"},{"location":"#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, PHSurv}","page":"Help","title":"RecipesBase.apply_recipe","text":"Recipe for cox-model based risk curves\n\n    using Plots, LSurvival, Random, StatsBase\n    res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)\n    X = hcat(z, x)\n    int = zeros(length(d)) # no late entry\n    ft1 = fit(PHModel, X, int, outt, d .* (event .== 1), wts=wts)\n    ft2 = fit(PHModel, X, int, outt, d .* (event .== 2), wts=wts)\n    c = risk_from_coxphmodels([ft1, ft2], pred_profile = mean(X, dims=1))\n    \n    plot(c)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.confint-Tuple{AJSurv}","page":"Help","title":"StatsAPI.confint","text":"Greenwood's formula for variance and confidence intervals of a Aalen-Johansen risk function\n\nSignatures:\n\nStatsBase.stderror(m::AJSurv)\n\nStatsBase.confint(m:AJSurv; level=0.95, method=\"normal\")\n\nKeyword arguments\n\nmethod\n\"normal\" normality-based confidence intervals\n\"lognlog\" log(-log(S(t))) based confidence intervals\n\nres = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)\nint = zeros(length(d)) # no late entry\nm = fit(AJSurv, int, outt, event)\nstderror(m)\nconfint(m, level=0.95)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.confint-Tuple{KMSurv}","page":"Help","title":"StatsAPI.confint","text":"Greenwood's formula for variance and confidence intervals of a Kaplan-Meier survival curve\n\nSignatures:\n\nStatsBase.stderror(m::KMSurv)\n\nStatsBase.confint(m:KMSurv; level=0.95, method=\"normal\")\n\nKeyword arguments\n\nmethod:\n\n\"normal\" normality-based confidence intervals\n\"lognlog\" log(-log(S(t))) based confidence intervals\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\nm = fit(KMSurv, enter, t, d)\nmw = fit(KMSurv, enter, t, d, wts=wt)\nstderror(m)\nconfint(m, method=\"normal\")\nconfint(m, method=\"lognlog\") # log-log transformation\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.confint-Tuple{M} where M<:AbstractPH","page":"Help","title":"StatsAPI.confint","text":"using LSurvival\n dat1= (\n   time = [1,1,6,6,8,9],\n   status = [1,0,1,1,0,1],\n   x = [1,1,1,0,0,0]\n )\n\n ft = coxph(@formula(Surv(time, status) ~ x),dat1, keepx=true)\n # model-based variance\n confint(ft)\n\n # robust variance\n confint(ft, type=\"robust\")\n\nfor cluster confidence intervals\n\n dat1clust= (\n   id = [1,2,3,3,4,4,5,5,6,6],\n   enter = [0,0,0,1,0,1,0,1,0,1],\n   exit = [1,1,1,6,1,6,1,8,1,9],\n   status = [1,0,0,1,0,1,0,0,0,1],\n   x = [1,1,1,1,0,0,0,0,0,0]\n )\n\n ft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id), keepx=true)\n # model-based variance\n confint(ft2)\n\n # robust variance\n confint(ft2, type=\"robust\")\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit!-Tuple{T} where T<:AbstractNPSurv","page":"Help","title":"StatsAPI.fit!","text":"Kaplan-Meier estimator for cumulative conditional risk\n\nSignatures\n\nStatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\nkaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; kwargs...)\n\nKeyword arguments\n\nwts::Vector{<:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation\nid::Vector{<:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)\natol = 0.00000001; absolute tolerance for defining tied event times\ncensval = 0;  value of the outcome to be considered a censored event\nkeepy = true; keep the outcome vector after fitting (may save memory with large datasets)\neps = 0.00000001; deprecated (replaced by atol)\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\nm = fit(KMSurv, enter, t, d)\nmw = fit(KMSurv, enter, t, d, wts=wt)\n\nor, equivalently:\n\nkaplan_meier(enter, t, d, wts=wt)\n\nAalen-Johansen estimator for cumulative cause-specific risk (in the presence of competing events)\n\nSignatures\n\n StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\n aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; kwargs...)\n\n\nKeyword arguments\n\nwts::Vector{<:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation\nid::Vector{<:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)\natol = 0.00000001; absolute tolerance for defining tied event times\nkeepy = true; keep the outcome vector after fitting (may save memory with large datasets)\neps = 0.00000001; deprecated (replaced by atol)\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\n   # event variable is coded 0[referent],1,2\nm = fit(AJSurv, enter, t, event)\nmw = fit(AJSurv, enter, t, event, wts=wt)\n\nor, equivalently:\n\naalen_johansen(enter, t, event, wts=wt)\n\nSurvival curve estimation using multiple cox models\n\nSignatures\n\n  risk_from_coxphmodels(fitlist::Vector{T}, args...; kwargs...) where {T<:PHModel}\n\n  fit(::Type{M}, fitlist::Vector{T}, ; fitargs...) where {M<:PHSurv,T<:PHModel}\n\nOptional keywords\n\ncoef_vectors = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]\npred_profile = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]\n\n using LSurvival\n using Random\n # event variable is coded 0[referent],1,2\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n\n ft1 = coxph(hcat(x,z), enter, t, (event .== 1))\n nidx = findall(event .!= 1)\n ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))\n\n # risk at referent levels of `x` and `z`\n risk_from_coxphmodels([ft1,ft2])\n\n # risk at average levels of `x` and `z`\n mnx = sum(x)/length(x)\n mnz = sum(z)/length(z)\n # equivalent\n fit(PHSurv, [ft1,ft2], pred_profile=[mnx,mnz])\n risk_from_coxphmodels([ft1,ft2], pred_profile=[mnx,mnz])\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{T}, Tuple{M}, Tuple{Type{M}, Vector{T}}} where {M<:PHSurv, T<:PHModel}","page":"Help","title":"StatsAPI.fit","text":"Survival curve estimation using multiple cox models\n\nSignatures\n\n  risk_from_coxphmodels(fitlist::Vector{T}, args...; kwargs...) where {T<:PHModel}\n\n  fit(::Type{M}, fitlist::Vector{T}, ; fitargs...) where {M<:PHSurv,T<:PHModel}\n\nOptional keywords\n\ncoef_vectors = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]\npred_profile = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]\n\n using LSurvival\n using Random\n # event variable is coded 0[referent],1,2\n z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n enter = zeros(length(t));\n\n ft1 = coxph(hcat(x,z), enter, t, (event .== 1))\n nidx = findall(event .!= 1)\n ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))\n\n # risk at referent levels of `x` and `z`\n risk_from_coxphmodels([ft1,ft2])\n\n # risk at average levels of `x` and `z`\n mnx = sum(x)/length(x)\n mnz = sum(z)/length(z)\n # equivalent\n fit(PHSurv, [ft1,ft2], pred_profile=[mnx,mnz])\n risk_from_coxphmodels([ft1,ft2], pred_profile=[mnx,mnz])\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Matrix{<:Real}, Vector{<:Real}, Vector{<:Real}, Y}} where {M<:AbstractPH, Y<:Union{BitVector, Vector{<:Real}}}","page":"Help","title":"StatsAPI.fit","text":"Fit method for AbstractPH objects (Cox models)\n\nKeyword arguments (used here, and passed on to internal structs)\n\nties \"breslow\" or \"efron\" (default)\nwts observation weights\nties \"breslow\" or \"efron\" (default)\noffset not currently used at all\nfitargs arguments passed to other structs, which include\nid cluster or individual level ID (defaults to a unique value for each row of data) see note below on ID\ncontrasts StatsModel style contrasts (dicts) that can be used for variable transformations/indicator variable creation (e.g. https://juliastats.org/StatsModels.jl/stable/contrasts/)\nSignatures\n\n  fit(::Type{M},\n  X::AbstractMatrix,#{<:FP},\n  enter::AbstractVector{<:Real},\n  exit::AbstractVector{<:Real},\n  y::Union{AbstractVector{<:Real},BitVector}\n  ;\n  ties =\"breslow\",\n  wts::AbstractVector{<:Real}      = similar(y, 0),\n  offset::AbstractVector{<:Real}   = similar(y, 0),\n  fitargs...) where {M<:AbstractPH}\n\n coxph(f::FormulaTerm, data; kwargs...)\n\n  coxph(X, enter, exit, y, args...; kwargs...)\n\n   using LSurvival, Random\n   z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\n   enter = zeros(length(t));\n   X = hcat(x,rand(length(x)));\n    m = fit(PHModel, X, enter, t, d, ties=\"efron\")\n   m2 = fit(PHModel, X, enter, t, d, ties=\"breslow\")\n   coeftable(m)\n\nNote on use of id keyword\n\nid is not needed in person-period structure data for standard estimates or confidence intervals\n\n  using Random, LSurvival\n     id, int, outt, dat =\n         LSurvival.dgm(MersenneTwister(123123), 100, 100; afun = LSurvival.int_0)\n     data = (\n             int = int,\n             outt = outt,\n             d = dat[:,4] .== 1,\n             x = dat[:,1],\n             z = dat[:,2]\n     )\n\n     f = @formula(Surv(int, outt,d)~x+z)\n     coxph(f, data)\n\nBUT, you must specify id to get appropriate robust variance and some other statistics.\n\nHere is an example where the same data are presented in two different ways, which should yield identical statistics when used in Cox model.\n\n dat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n  )\n  ft = coxph(@formula(Surv(time,status)~x),dat1)\n  bic(ft)\n  nobs(ft)\n  dof_residual(ft)\n  # lrtest is another one\n\n  stderror(ft)                     # model based\n  stderror(ft, type=\"robust\")   # robust standard error, based on dfbeta residuals\n  ft\n\n  # now using \"clustered\" data with multiple observations per individual\n dat1clust= (\n     id = [1,2,3,3,4,4,5,5,6,6],\n     enter = [0,0,0,1,0,1,0,1,0,1],\n     exit = [1,1,1,6,1,6,1,8,1,9],\n     status = [1,0,0,1,0,1,0,0,0,1],\n     x = [1,1,1,1,0,0,0,0,0,0]\n )\n \n # use the `id` parameter with the ID struct\n ft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id))\n bic(ft2)                       # CORRECT        \n nobs(ft2)                      # CORRECT\n dof_residual(ft2)              # CORRECT\n  \n stderror(ft2)                  # model based (CORRECT)\n stderror(ft2, type=\"robust\")   # robust standard error, based on `id` level dfbeta residuals (CORRECT)\n # once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics\n ft2   # CORRECT (compare to `ft` object)\n\nNOTE THE FOLLOWING IS INCORRECT because the id keyword is omitted\n\n ft2w = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust)\n bic(ft2w)                          # INCORRECT \n nobs(ft2w)                         # INCORRECT\n dof_residual(ft2w)                 # INCORRECT\n\n stderror(ft2w)                     # model based (CORRECT)\n stderror(ft2w, type=\"robust\")      # robust variance (INCORRECT)\n \n ft2w # the coefficient table now shows incorrect confidence intervals and test statistics\n  \n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{<:Real}, Vector{<:Real}, Y}} where {M<:AJSurv, Y<:Union{BitVector, Vector{<:Real}}}","page":"Help","title":"StatsAPI.fit","text":"Aalen-Johansen estimator for cumulative cause-specific risk (in the presence of competing events)\n\nSignatures\n\n StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\n aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; kwargs...)\n\n\nKeyword arguments\n\nwts::Vector{<:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation\nid::Vector{<:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)\natol = 0.00000001; absolute tolerance for defining tied event times\nkeepy = true; keep the outcome vector after fitting (may save memory with large datasets)\neps = 0.00000001; deprecated (replaced by atol)\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\n   # event variable is coded 0[referent],1,2\nm = fit(AJSurv, enter, t, event)\nmw = fit(AJSurv, enter, t, event, wts=wt)\n\nor, equivalently:\n\naalen_johansen(enter, t, event, wts=wt)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{<:Real}, Vector{<:Real}, Y}} where {M<:KMSurv, Y<:Union{BitVector, Vector{<:Real}}}","page":"Help","title":"StatsAPI.fit","text":"Kaplan-Meier estimator for cumulative conditional risk\n\nSignatures\n\nStatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\nkaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; kwargs...)\n\nKeyword arguments\n\nwts::Vector{<:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation\nid::Vector{<:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)\natol = 0.00000001; absolute tolerance for defining tied event times\ncensval = 0;  value of the outcome to be considered a censored event\nkeepy = true; keep the outcome vector after fitting (may save memory with large datasets)\neps = 0.00000001; deprecated (replaced by atol)\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\nm = fit(KMSurv, enter, t, d)\nmw = fit(KMSurv, enter, t, d, wts=wt)\n\nor, equivalently:\n\nkaplan_meier(enter, t, d, wts=wt)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.loglikelihood-Tuple{M} where M<:AbstractPH","page":"Help","title":"StatsAPI.loglikelihood","text":"Maximum log partial likelihood for a fitted AbstractPH model Efron or Breslow (depending on the ties` parameter)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.loglikelihood-Tuple{M} where M<:PSModel","page":"Help","title":"StatsAPI.loglikelihood","text":"Maximum log likelihood for a fitted PSModel model\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.nullloglikelihood-Tuple{M} where M<:AbstractPH","page":"Help","title":"StatsAPI.nullloglikelihood","text":"Null log-partial likelihood for a fitted AbstractPH model Efron or Breslow (depending on the ties` parameter)\n\nNote: this is just the log partial likelihood at the initial values of the model, which default to 0. If initial values are non-null, then this function no longer validly returns the null log-partial likelihood.\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.nullloglikelihood-Tuple{M} where M<:PSModel","page":"Help","title":"StatsAPI.nullloglikelihood","text":"Null log-partial likelihood for a fitted PSModel model\n\nNote: this is just the log partial likelihood at the initial values of the model, which default to 0. If initial values are non-null, then this function no longer validly returns the null log-partial likelihood.\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.residuals-Tuple{M} where M<:PHModel","page":"Help","title":"StatsAPI.residuals","text":"####################################################################\n\nCox proportional hazards model residuals:\n\nSignature\n\n  residuals(m::M; type = \"martingale\") where {M<:PHModel}\n\nwhere type is one of \n\nmartingale\nschoenfeld\nscore\ndfbeta\nscaled_schoenfeld\nResiduals from the residuals function are designed to exactly emulate those from the survival package in R. Currently, they are validated for single observation data (e.g. one data row per individual).\n####################################################################\nMartingale residuals: Observed versus expected\n\n  # example from https://cran.r-project.org/web/packages/survival/vignettes/validate.pdf\n  # by Terry Therneau\n\n  dat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n  )\n\n  # Nelson-Aalen type estimator for Breslow partial likelihood\n  ft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"breslow\")\n  residuals(ft, type=\"martingale\")\n\n  dat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n  )\n\n  # Fleming-Harrington type estimator for Efron partial likelihood\n  ft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"efron\")\n  residuals(ft, type=\"martingale\")\n\n\n####################################################################\n\nScore residuals: Per observation contribution to score function\n\n  using LSurvival\n  dat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n  )\n  ft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"breslow\")\n  S = residuals(ft, type=\"score\")[:]\n  ft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"efron\", maxiter=0)\n  S = residuals(ft, type=\"score\")[:]\n\n####################################################################\n\nSchoenfeld residuals: Per time contribution to score function\n\n  using LSurvival\n  dat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n  )\n  ft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"breslow\", maxiter=0)\n\n\n  X = ft.P.X\n  M = residuals(ft, type=\"martingale\")\n  S = residuals(ft, type=\"schoenfeld\")[:]\n\n####################################################################\n\ndfbeta residuals: influence of individual observations on each parameter\n\n  using LSurvival\n  dat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n  )\n\n  ft = coxph(@formula(Surv(time,status)~x),dat1, ties=\"breslow\")\n  residuals(ft, type=\"dfbeta\")\n\n  # can also calculate from score residuals and Hessian matrix\n  L = residuals(ft, type=\"score\") # n X p\n  H = ft.P._hess   # p X p\n  dfbeta = L*inv(H)\n  robVar = dfbeta'dfbeta\n  sqrt(robVar)\n\n\nusing the id keyword argument\n\nsee help for LSurvival.vcov for what happens when id keyword is not used\n\n  dat1clust= (\n    id = [1,2,3,3,4,4,5,5,6,6],\n    enter = [0,0,0,1,0,1,0,1,0,1],\n    exit = [1,1,1,6,1,6,1,8,1,9],\n    status = [1,0,0,1,0,1,0,0,0,1],\n    x = [1,1,1,1,0,0,0,0,0,0]\n  )\n\n  ft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id), ties=\"breslow\")\n\n  # note these are still on the observation level (not the id level)! \n  residuals(ft2, type=\"dfbeta\")\n\n  # getting id level dfbeta residuals\n  dfbeta = residuals(ft2, type=\"dfbeta\")\n  id = values(ft2.R.id)\n  D = reduce(vcat, [sum(dfbeta[findall(id .== i),:], dims=1) for i in unique(id)])\n  D'D\n  vcov(ft, type=\"robust\")\n  vcov(ft2, type=\"robust\")\n\n####################################################################\n\njackknife residuals: influence of individual observations on each parameter using leave-one-out estimates\n\nnote there are other definitions of jackknife residuals  See Chapter 7.1 of \"Extending the Cox Model\" by Therneau and Grambsch for an example of the type of jackknife residuals used here\n\nJackknife residuals r_i for i in 1n are given as the difference between the maximum partial likelihood estimate and the jackknife estimates for each observation\n\nr_i = hatbeta - hatbeta_(-i)\n\nwhere beta_(-i) is the maximum partial likelihood estimate of the log-hazard ratio vector obtained from a dataset in which observations belonging to individual i are removed\n\n  using LSurvival\n  dat1 = (\n    time = [1,1,6,6,8,9],\n    status = [1,0,1,1,0,1],\n    x = [1,1,1,0,0,0]\n  )\n\n  ft = coxph(@formula(Surv(time,status)~x),dat1, ties=\"breslow\")\n  #jackknife(ft)\n  residuals(ft, type=\"jackknife\")\n\n\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.stderror-Tuple{AJSurv}","page":"Help","title":"StatsAPI.stderror","text":"Greenwood's formula for variance and confidence intervals of a Aalen-Johansen risk function\n\nSignatures:\n\nStatsBase.stderror(m::AJSurv)\n\nStatsBase.confint(m:AJSurv; level=0.95, method=\"normal\")\n\nKeyword arguments\n\nmethod\n\"normal\" normality-based confidence intervals\n\"lognlog\" log(-log(S(t))) based confidence intervals\n\nres = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)\nint = zeros(length(d)) # no late entry\nm = fit(AJSurv, int, outt, event)\nstderror(m)\nconfint(m, level=0.95)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.stderror-Tuple{KMSurv}","page":"Help","title":"StatsAPI.stderror","text":"Greenwood's formula for variance and confidence intervals of a Kaplan-Meier survival curve\n\nSignatures:\n\nStatsBase.stderror(m::KMSurv)\n\nStatsBase.confint(m:KMSurv; level=0.95, method=\"normal\")\n\nKeyword arguments\n\nmethod:\n\n\"normal\" normality-based confidence intervals\n\"lognlog\" log(-log(S(t))) based confidence intervals\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\nm = fit(KMSurv, enter, t, d)\nmw = fit(KMSurv, enter, t, d, wts=wt)\nstderror(m)\nconfint(m, method=\"normal\")\nconfint(m, method=\"lognlog\") # log-log transformation\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.vcov-Tuple{M} where M<:AbstractPH","page":"Help","title":"StatsAPI.vcov","text":"Covariance matrix for Cox proportional hazards models  \n\nKeyword arguments\n\ntype nothing or \"robust\": determines whether model based or robust (dfbeta based) variance is returned.\nSee ?residuals for info on dfbeta residuals\n\nusing LSurvival\ndat1 = (\n  time = [1,1,6,6,8,9],\n  status = [1,0,1,1,0,1],\n  x = [1,1,1,0,0,0]\n)\nft = coxph(@formula(Surv(time,status)~x),dat1, id=ID.(collect(1:6)))\n\nvcov(ft)                   # model based\nvcov(ft, type=\"robust\")    # robust variance, based on dfbeta residuals\n# once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics\nft\n\ncluster robust standard errors using the id keyword argument\n\ndat1clust= (\n  id = [1,2,3,3,4,4,5,5,6,6],\n  enter = [0,0,0,1,0,1,0,1,0,1],\n  exit = [1,1,1,6,1,6,1,8,1,9],\n  status = [1,0,0,1,0,1,0,0,0,1],\n  x = [1,1,1,1,0,0,0,0,0,0]\n)\n\nft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id))\n\nvcov(ft2)                     # model based\nvcov(ft2, type=\"robust\")       # robust variance, based on dfbeta residuals\nstderror(ft2, type=\"robust\")   # robust variance, based on dfbeta residuals\nconfint(ft2, type=\"robust\")    # robust variance, based on dfbeta residuals\nnobs(ft2)                     # id argument yields correct value of number of independent observations\n# once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics\nft2 \n\nNOTE THE FOLLOWING IS INCORRECT because the id keyword is omitted\n\nft2w = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust)\n\nvcov(ft2w)                   # model based (CORRECT)\nvcov(ft2w, type=\"robust\")    # robust variance (INCORRECT)\nnobs(ft2w)\n\nft2w\n\n\n\n\n\n","category":"method"},{"location":"","page":"Help","title":"Help","text":"Pages = [\"Likelihood.md\"]","category":"page"},{"location":"Likelihood/#Likelihood-functions-for-time-to-event-observations-subject-to-left-truncation-and-right-censoring","page":"Parametric likelihood functions","title":"Likelihood functions for time-to-event observations subject to left-truncation and right censoring","text":"","category":"section"},{"location":"Likelihood/#Definitions:","page":"Parametric likelihood functions","title":"Definitions:","text":"","category":"section"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"Random variable E: time at beginning of observation\nRandom variable T: time at end of observation\nRandom variable Y: event indicator (1=yes, 0=no)\nRealization e_i: time at study entry for observation i\nRealization t_i: time at study end for observation i\nRealization y_i: event indicator (1=yes, 0=no) for observation i\nRealization mathbfx_i: covariate vector for observation i\nFunction f(t): probability density function evaluated at T=t\nFunction S(t)=Pr(Tt): survival function evaluated at T=t, where S(0)= 1\nFunction mathscrL equivmathscrL(teytheta): likelihood function for observed data under a parametric distribution with parameters theta","category":"page"},{"location":"Likelihood/#Likelihood-for-survival-data","page":"Parametric likelihood functions","title":"Likelihood for survival data","text":"","category":"section"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"We then have that the likelihood for i.i.d. data decomposes as","category":"page"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"beginaligned\nmathscrL = prod_i mathscrL_i\nmathscrL_i = fracf(t_i)^y_iS(t_i)^(1-y_i)S(e_i)\nendaligned","category":"page"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"With the log-likelihood (lnmathscrL) given as:","category":"page"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"beginaligned\nlnmathscrL = lnbigg(prod_i mathscrL_ibigg)\n   = sum_i lnmathscrL_i\nlnmathscrL_i = y_iln f(t_i) + (1-y_i)ln S(t_i) - ln S(e_i)\nendaligned","category":"page"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"Meaning that the likelihood (and log-likelihood) under a survival model need only have the probability density function and the survival function (or natural log-transformations of those function outputs)","category":"page"},{"location":"Likelihood/#Special-case:-person-period-data","page":"Parametric likelihood functions","title":"Special case: person-period data","text":"","category":"section"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"\"Person period data\" allows us to split data from an individual into multiple observations, so that an individual can be right-censored in their first observation and then left-truncated in their second observation at the same time. In this case, the likelihood contribution for individual i (E_i=e_i T_i=t_i, y_i=1) can be split over two person-periods (jin 12), where the failure occurs in the second period and the first period is right censored since we know the individual survives that period. This likelihood decomposition is given as:","category":"page"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"beginaligned\nmathscrL_i = prod_j mathscrL_ij\n = prod_jfracf(t_ij)^y_ijS(t_ij)^(1-y_ij)S(e_ij) \n = fracf(t_ij)^y_ijS(t_ij)^(1-y_ij)S(e_ij) times fracf(t_ij)^y_ijS(t_ij)^(1-y_ij)S(e_ij)  \n = fracS(t_i1)S(e_ij= e_i) times fracf(t_i2=t_i)^y_i2=y_iS(e_i2=t_i1) =  fracf(t_i)S(e_i)\nendaligned","category":"page"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"Which is exactly the likelihood we would observe if there were only one observation for this individual. Similar derivations can be made for censored individuals. This phenomena allows that, for example, covariates may differ across person-periods (time-varying covariates), and the general approach to likelihoods to survival data can readily accomodate this. The LSurvival module takes this general approach to defining the likelihood (and also the partial likelihood in Cox models) and so allows the estimation of effects of time-varying exposures as well as accomodating left truncation and right censoring. ","category":"page"},{"location":"Likelihood/#Parametric-likelihoods","page":"Parametric likelihood functions","title":"Parametric likelihoods","text":"","category":"section"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"Multiple parametric model forms are available in the LSurvival module. Here, we derive the specific parameterizations used in the module, which uses the location-scale characterization of regression models (also used in the survival package in R).","category":"page"},{"location":"Likelihood/#Weibull-distribution","page":"Parametric likelihood functions","title":"Weibull distribution","text":"","category":"section"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"The Weibull distribution can be parameterized as: (Kalbfleisch and Prentice, sec 2.2) beginaligned  f(t)=lambdagamma(lambda t)^gamma-1exp(-(lambda t)^gamma) \nS(t) = exp(-(lambda t)^gamma) endaligned","category":"page"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"This can be characterized in terms of a 'location-scale' parameterization for modeling of survival times.","category":"page"},{"location":"Likelihood/#Derivation:","page":"Parametric likelihood functions","title":"Derivation:","text":"","category":"section"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"Let gamma = exp(-rho) lambda = exp(-alpha) z=fracln(t)-alphaexp(rho) and using t=exp(ln(t)), we have that beginaligned  f(t)=exp(-alpha)exp(-rho)(exp(-alpha)exp(ln(t)))^exp(-rho)-1exp(-(exp(-alpha) exp(ln(t)))^exp(-rho)) \n=exp(-alpha-rho)exp((ln(t)-alpha)(exp(-rho)-1))exp(-(exp(-alpha) exp(ln(t))exp(-rho))) \n\nln f(t)=  (-alpha-rho) +                   (ln(t)-alpha)(exp(-rho)-1) +                   -exp(ln(t)-alpha)exp(-rho)) \n=  (-alpha-rho) +                   (z-(ln(t)-alpha)) +                   -exp(z) \n=  z -exp(z) -rho -ln(t)  \nendaligned","category":"page"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"And  beginaligned  S(t)=exp(-(exp(-alpha) exp(ln(t)))^exp(-rho)) \n=exp(-(exp((ln(t)-alpha)exp(-rho))^) \n=exp(-exp(z)) \nln S(t)=-exp(z) \nendaligned","category":"page"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"So that the log likelihood can be defined in terms of the natural log of the survival time, allowing the \"location-scale\" parameterization of a parametric survival model:","category":"page"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"beginaligned \nz_i = fracln(t_i)-mathbfx_ibetasigma\nln(t_i) = mathbfx_ibeta + sigma z_i\nz sim D\nendaligned","category":"page"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"Where the location parameter is given as alpha = mathbfxbeta and the scale parmameter sigma=exp(rho) determines the magnitude of the error terms, whose distribution is D (e.g. in the case of the Weibull distribution for t, D is the extreme value distribution). Here, the association between covariates mathbfX and the time-to-event outcome is characterized in terms of linear effects on the location parameter alpha. Further details and interpretive assistance can be found in Kalbfleisch and Prentice.","category":"page"},{"location":"Likelihood/#Exponential-distribution","page":"Parametric likelihood functions","title":"Exponential distribution","text":"","category":"section"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"This is a special case of the Weibull log-likelihood in which gamma=1 (or, equivalently rho=0)","category":"page"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"beginaligned \nf(t)=lambdaexp(-lambda t) \nS(t) = exp(-lambda t)\nendaligned","category":"page"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"Then, again letting lambda = exp(-alpha) and using t=exp(ln(t)), we have that","category":"page"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"beginaligned \nln f(t)=  alpha - exp(ln(t) - alpha) \nln S(t)=-exp(ln(t) - alpha) \nendaligned","category":"page"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"which gives us the model","category":"page"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"beginaligned \nln(t_i) = mathbfx_ibeta + epsilon_i \nepsilon sim D\nendaligned","category":"page"},{"location":"Likelihood/#Log-normal-distribution","page":"Parametric likelihood functions","title":"Log-normal distribution","text":"","category":"section"},{"location":"Likelihood/","page":"Parametric likelihood functions","title":"Parametric likelihood functions","text":"beginaligned \nf(t)=(2pi)^-12gamma t^-1 expbigg(frac-gamma^2(ln(lambda t))^22   bigg) \nS(t) = 1 - Phibig(gamma ln(lambda t)big)\nendaligned","category":"page"}]
}
