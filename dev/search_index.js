var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = LSurvival=","category":"page"},{"location":"#[LSurvival](https://github.com/alexpkeil1/LSurvival.jl)","page":"Home","title":"LSurvival","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Survival analysis functions in Julia for time-to-event outcomes that can include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Loss-to-follow-up/right censoring\nLate entry/left truncation (not available in Survival.jl)\n\"Person-period\" data structures (not available in Survival.jl)\nObservation weights (not available in Survival.jl)\nCompeting risks (not available in Survival.jl)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Capabilities include estimators for","category":"page"},{"location":"","page":"Home","title":"Home","text":"Kaplan-Meier non-parametric conditional risk functions\nAalen-Johansen non-parametric cause-specific unconditional risk functions\nCox proportional hazards model (Efron's or Breslow's methods for ties)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Convenience functions enable:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Non-parametric bootstrapping, cluster-bootstrapping\nEstimating baseline hazards from a Cox Model\nEstimating cause-specific risk from an exhaustive set of Cox models for competing risk outcomes\nSimple simulation of competing and non-competing survival events\nCluster robust variance estimation (without bootstrapping)\nMartingale, score, Schoenfeld, and dfbeta residuals\nCluster robust variance estimation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Plans to include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Parametric survival models\nStratification in Cox models","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package has been tuned to follow the \"survival\" package from R in terms of specific estimators/results.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Report issues here","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(url = \"https://github.com/alexpkeil1/LSurvival.jl\")","category":"page"},{"location":"#Quick-examples","page":"Home","title":"Quick examples","text":"","category":"section"},{"location":"#Single-event-type:-Cox-model-and-Kaplan-Meier-curve","page":"Home","title":"Single event type: Cox model and Kaplan-Meier curve","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Random, LSurvival, Distributions, LinearAlgebra\n\n# generate some data under a discrete hazards model\nexpit(mu) = inv(1.0 + exp(-mu))\n\nfunction dgm(rng, n, maxT; regimefun = int_0)\n    V = rand(rng, n)\n    LAY = Array{Float64,2}(undef, n * maxT, 4)\n    keep = ones(Bool, n * maxT)\n    id = sort(reduce(vcat, fill(collect(1:n), maxT)))\n    time = (reduce(vcat, fill(collect(1:maxT), n)))\n    for i = 1:n\n        v = V[i]\n        l = 0\n        a = 0\n        lkeep = true\n        for t = 1:maxT\n            currIDX = (i - 1) * maxT + t\n            l = expit(-3 + 2 * v + 0 * l + 0 * a) > rand(rng) ? 1 : 0\n            a = 0.1 > rand(rng) ? 1 : 0\n            y = expit(-3 + 2 * v + 0 * l + 2 * a) > rand(rng) ? 1 : 0\n            LAY[currIDX, :] .= [v, l, a, y]\n            keep[currIDX] = lkeep\n            lkeep = (!lkeep || (y == 1)) ? false : true\n        end\n    end\n    id[findall(keep)], time[findall(keep)] .- 1, time[findall(keep)], LAY[findall(keep), :]\nend\n\nid, int, outt, data = dgm(MersenneTwister(), 1000, 10; regimefun = int_0)\ndata[:, 1] = round.(data[:, 1], digits = 3)\nd, X = data[:, 4], data[:, 1:3]\nwt = rand(length(d)) # random weights just to demonstrate usage\n\n# Cox model\n# Breslow's partial likelihood\nm = fit(PHModel, X, int, outt, d, ties = \"breslow\", wts = wt)\n\n# Efron's partial likelihood\nm2 = fit(PHModel, X, int, outt, d, ties = \"efron\", wts = wt)\n\n#equivalent way to specify \n# using `coxph` function\nm2b = coxph(X, int, outt, d, ties = \"efron\", wts = wt)\n\n# using `coxph` function with `Tables.jl` and `StatsAPI.@formula` interface (similar to GLM.jl)\ntab = ( in = int, out = out, d=d, x=X[:,1], z1=X[:,2], z2=X[:,3]) # can also be a DataFrame from DataFrames.jl\nm2b = coxph(@formula(Surv(in, out, d)~x+z1+z2), ties = \"efron\", wts = wt)\n\n# can also be done if there is no late entry\nm2b = coxph(@formula(Surv(out, d)~x+z1+z2), ties = \"efron\", wts = wt)\n# can also be done if there is no late entry and no right censoring (i.e. all times are failure times)\nm2b = coxph(@formula(Surv(out)~x+z1+z2), ties = \"efron\", wts = wt)\n\n\n\n# Kaplan-Meier estimator of the cumulative risk/survival\nres = kaplan_meier(int, outt, d)","category":"page"},{"location":"#Competing-event-analysis:-Aalen-Johansen-and-Cox-model-based-estimators-of-the-cumulative-risk/survival","page":"Home","title":"Competing event analysis: Aalen-Johansen and Cox-model-based estimators of the cumulative risk/survival","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Random, LSurvival, Distributions, LinearAlgebra\n\n# simulate some data\nfunction dgm_comprisk(; n = 100, rng = MersenneTwister())\n    z = rand(rng, n) .* 5\n    x = rand(rng, n) .* 5\n    dt1 = Weibull.(fill(0.75, n), inv.(exp.(-x .- z)))\n    dt2 = Weibull.(fill(0.75, n), inv.(exp.(-x .- z)))\n    t01 = rand.(rng, dt1)\n    t02 = rand.(rng, dt2)\n    t0 = min.(t01, t02)\n    t = Array{Float64,1}(undef, n)\n    for i = 1:n\n        t[i] = t0[i] > 1.0 ? 1.0 : t0[i]\n    end\n    d = (t .== t0)\n    event = (t .== t01) .+ 2.0 .* (t .== t02)\n    wtu = rand(rng, n) .* 5.0\n    wt = wtu ./ mean(wtu)\n    reshape(round.(z, digits = 4), (n, 1)),\n    reshape(round.(x, digits = 4), (n, 1)),\n    round.(t, digits = 4),\n    d,\n    event,\n    round.(wt, digits = 4)\nend\n\nz, x, t, d, event, wt = dgm_comprisk(; n = 100, rng = MersenneTwister(12))\nX = hcat(x,z)\nenter = t .* rand(length(d))*0.02 # create some fake entry times\n\n# Aalen-Johansen estimator: marginal cause-specific risks\nres_aj = aalen_johansen(enter, t, event; wts = wt);\nres_aj\n\n# Cox-model estimator: cause-specific risks at given levels of covariates\nfit1 = fit(PHModel, X, enter, t, (event .== 1), ties = \"efron\",  wts = wt)\n#n2idx = findall(event .!= 1)\nn2idx = findall(event .> -1)\nfit2 = fit(PHModel, X[n2idx,:], enter[n2idx], t[n2idx], (event[n2idx] .== 2), ties = \"breslow\",  wts = wt[n2idx])\n\n# risk at referent levels of `x` and `z` (can be very extreme if referent levels are unlikely/unobservable)\nres_cph_ref = risk_from_coxphmodels([fit1,fit2])\n\n# risk at average levels of `x` and `z`\nmnx = sum(x)/length(x)\nmnz = sum(z)/length(z)\nres_cph = risk_from_coxphmodels([fit1,fit2], coef_vectors=[coef(ft1), coef(ft2)], pred_profile=mean(X, dims=1))\n# compare to Aalen-Johansen fit\nres_aj\n\n\n# this approach operates on left censored outcomes (which operate in the background in model fitting)\nLSurvivalResp(enter, t, d, origintime=0)\nLSurvivalCompResp(enter, t, event) # automatically infers origin\n\n\n# can use the ID type to refer to units with multiple observations\nid, int, outt, data = dgm(MersenneTwister(), 1000, 10; regimefun = int_0)\nLSurvivalResp(int, outt, data[:,4], ID.(id))","category":"page"},{"location":"#Index-of-functions","page":"Home","title":"Index of functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Function-help","page":"Home","title":"Function help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [LSurvival]","category":"page"},{"location":"#LSurvival.AbstractLSurvivalParms","page":"Home","title":"LSurvival.AbstractLSurvivalParms","text":"AbstractLsurvParms\n\nAbstract type representing a model predictors and coefficient parameters\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractLSurvivalResp","page":"Home","title":"LSurvival.AbstractLSurvivalResp","text":"AbstractLsurvResp\n\nAbstract type representing a model response vector\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractNPSurv","page":"Home","title":"LSurvival.AbstractNPSurv","text":"Abstract type for non-parametric survival models, including Kaplan-Meier, Aalen Johansen, and Cox-model based estimates of survival using an Aalen-Johansen-like estimator\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.AbstractPH","page":"Home","title":"LSurvival.AbstractPH","text":"Abstract type for proportional hazards models\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.ID","page":"Home","title":"LSurvival.ID","text":"Type for identifying individuals in survival outcomes.\n\nUsed for the id argument in \n\nOutcome types: LSurvivalResp, LSurvivalCompResp \nModel types: PHModel, KMRisk, AJRisk\n\nAccepts any Number or String. There is no significance to having this particular struct, but it enables easier use of multiple dispatch.\n\n[ID(i) for i in 1:10]\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.LSurvivalCompResp","page":"Home","title":"LSurvival.LSurvivalCompResp","text":"Outcome type for competing risk survival outcomes subject to left truncation and right censoring (not generally needed for users)\n\nParameters\n\nenter Time at observation start\nexit Time at observation end\ny event occurrence in observation\nwts observation weights\neventtimes unique event times\norigin origin on the time scale\nid person level identifier (must be wrapped in ID() function)\neventtypes vector of unique event types\neventmatrix matrix of indicators on the observation level\nSignatures:\n\njulia  struct LSurvivalCompResp{  E<:AbstractVector,  X<:AbstractVector,  Y<:AbstractVector,  W<:AbstractVector,  T<:Real,  I<:AbstractLSurvivalID,  V<:AbstractVector,  M<:AbstractMatrix,  } <: AbstractLSurvivalResp  enter::E  exit::X  y::Y  wts::W  eventtimes::X  origin::T  id::Vector{I}  eventtypes::V  eventmatrix::M  end\n\njulia  LSurvivalCompResp(  enter::E,  exit::X,  y::Y,  wts::W,  id::Vector{I}  )\n\njulia  LSurvivalCompResp(  enter::E,  exit::X,  y::Y,  id::Vector{I}  )\n\njulia  LSurvivalCompResp(  enter::E,  exit::X,  y::Y,  wts::W,  )\n\njulia  LSurvivalCompResp(  enter::E,  exit::X,  y::Y,  )\n\njulia  LSurvivalCompResp(   exit::X,   y::Y,   ) where {X<:Vector,Y<:Union{Vector{<:Real},BitVector}}\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.LSurvivalResp","page":"Home","title":"LSurvival.LSurvivalResp","text":"Outcome type for survival outcome subject to left truncation and right censoring. \n\nWill not generally be needed by users\n\nParameters\n\nenter: Time at observation start\nexit: Time at observation end\ny: event occurrence in observation\nwts: observation weights\neventtimes: unique event times\norigin: origin on the time scale\nid: person level identifier (must be wrapped in ID() function)\n\n```julia  struct LSurvivalResp{  E<:AbstractVector,  X<:AbstractVector,  Y<:AbstractVector,  W<:AbstractVector,  T<:Real,  I<:AbstractLSurvivalID,  } <: AbstractLSurvivalResp  enter::E  exit::X  y::Y  wts::W  eventtimes::E  origin::T  id::Vector{I}  end\n\n```\n\njulia  LSurvivalResp(     enter::E,     exit::X,     y::Y,     wts::W,     id::Vector{I},   ) where {     E<:Vector,     X<:Vector,     Y<:Union{Vector{<:Real},BitVector},     W<:Vector,     I<:AbstractLSurvivalID, }\n\n```julia  LSurvivalResp(  enter::E,  exit::X,  y::Y,  id::Vector{I},  ) \n\n```\n\njulia  LSurvivalResp(   y::Vector{Y},   wts::W,   id::Vector{I},   ) where {Y<:AbstractSurvTime,W<:Vector,I<:AbstractLSurvivalID}\n\njulia  LSurvivalResp(   enter::E,   exit::X,   y::Y,   ) where {E<:Vector,X<:Vector,Y<:Union{Vector{<:Real},BitVector}}\n\njulia  LSurvivalResp(exit::X, y::Y) where {X<:Vector,Y<:Vector}\n\nExamples\n\n```julia\n\nno late entry\n\nLSurvivalResp([.5, .6], [1,0])\n\n```\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.PHModel","page":"Home","title":"LSurvival.PHModel","text":"PHModel: Mutable object type for proportional hazards regression (not generally needed for users)\n\nParameters\n\nR Survival response\nP        # parameters\nties String: \"efron\" or \"breslow\"\nfit Bool: logical for whether the model has been fitted\nbh AbstractMatrix: baseline hazard estimates\nSignatures\n\n```julia  mutable struct PHModel{G<:LSurvivalResp,L<:AbstractLSurvivalParms} <: AbstractPH  R::G        # Survival response  P::L        # parameters  ties::String #\"efron\" or\"breslow\"  fit::Bool  bh::AbstractMatrix  end\n\nPHModel(  R::G,  P::L,  ties::String,  fit::Bool,  ) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}  PHModel(R::G, P::L, ties::String) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}  PHModel(R::G, P::L) where {G<:LSurvivalResp,L<:AbstractLSurvivalParms}  ```  Methods: fit, coef, confint, std_err, show\n\nExample\n\n```@example  using LSurvival  using Random  import LSurvival: stepcox!, dgmcomprisk\n\nz,x,t,d, event,wt = dgmcomprisk(MersenneTwister(1212), 100);  enter = zeros(length(t));  X = hcat(x,z);  R = LSurvivalResp(enter, t, Int.(d), wt)  P = PHParms(X)  mf = PHModel(R,P)   LSurvival.fit!(mf)  ```\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.PHSurv","page":"Home","title":"LSurvival.PHSurv","text":"Mutable type for proportional hazards models (not generally needed by users)\n\nPHSsurv: Object type for proportional hazards regression\n\nsurv::Vector{Float64} risk::Matrix{Float64} basehaz::Vector{Float64} event::Vector{Float64}\n\nfitlist: vector of PHSurv objects (Cox model fits)\neventtypes: vector of unique event types\ntimes: unique event times\nsurv: Overall survival at each time\nrisk: Cause-specific risk  at each time (1 for each outcome type)\nbasehaz: baseline hazard for a specific event type\nevent: value of event type that occurred at each time\n\nMethods: fit, show\n\nmutable struct PHSurv{G<:Array{T} where {T<:PHModel}} <: AbstractNPSurv\nfitlist::G        \neventtypes::AbstractVector\ntimes::AbstractVector\nsurv::Vector{Float64}\nrisk::Matrix{Float64}\nbasehaz::Vector{Float64}\nevent::Vector{Float64}\nend\n\nPHSurv(fitlist::Array{T}, eventtypes) where {T<:PHModel}\nPHSurv(fitlist::Array{T}) where {T<:PHModel}\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival.Strata","page":"Home","title":"LSurvival.Strata","text":"Type for identifying individuals in survival outcomes. Used for the strata argument in PHModel (not yet implemented)\n\nAccepts any Number or String. There is no significance to having this particular struct, but it enables easier use of multiple dispatch.\n\n[Strata(i) for i in 1:10]\n\n\n\n\n\n","category":"type"},{"location":"#LSurvival._update_PHParms!-Union{Tuple{T}, Tuple{I}, Tuple{M}, Tuple{M, I, Array{Vector{T}, 1}, Array{Vector{T}, 1}}} where {M<:AbstractPH, I<:Int64, T<:Int64}","page":"Home","title":"LSurvival._update_PHParms!","text":"Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).\n\nUses Breslow's or Efron's partial likelihood.\n\nUpdates over all observations\n\nSignature\n\n_update_PHParms!(\n m::M,\n # big indexes\n ne::I,\n caseidxs::Vector{Vector{T}},\n risksetidxs::Vector{Vector{T}},\n ) where {M<:AbstractPH,I<:Int,T<:Int}\n\nupdatePHParms!(m, risksetidxs, caseidxs, ne, den)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.aalen_johansen-Tuple{Any, Any, Any}","page":"Home","title":"LSurvival.aalen_johansen","text":"Aalen-Johansen estimator for cumulative cause-specific risk (in the presence of competing events)\n\nSignatures\n\n StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\n aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; kwargs...)\n\n\nKeyword arguments\n\nwts::Vector{<:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation\nid::Vector{<:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)\natol = 0.00000001; absolute tolerance for defining tied event times\nkeepy = true; keep the outcome vector after fitting (may save memory with large datasets)\neps = 0.00000001; deprecated (replaced by atol)\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\n   # event variable is coded 0[referent],1,2\nm = fit(AJSurv, enter, t, event)\nmw = fit(AJSurv, enter, t, event, wts=wt)\n\nor, equivalently:\n\naalen_johansen(enter, t, event, wts=wt)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Tuple{MersenneTwister, PHModel, Int64}","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrapping coefficients of a proportional hazards model\n\nSignatures\n\n# single bootstrap draw, keeping the entire object\nbootstrap(rng::MersenneTwister, m::PHModel)\nbootstrap(m::PHModel)\n# muliple bootstrap draws, keeping only coefficient estimates\nbootstrap(rng::MersenneTwister, m::PHModel, iter::Int; kwargs...)\nbootstrap(m::PHModel, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up\n\nusing LSurvival, Random\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 500, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nweights = rand(length(d))\n\n# survival outcome:\nR = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only\nP = PHParms(X)\n\nMod = PHModel(R, P)\nLSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)\n\n\n# careful propogation of bootstrap sampling\nidx, R2 = bootstrap(R)\nP2 = bootstrap(idx, P)\nModb = PHModel(R2, P2)\nLSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)\n\n# convenience function for bootstrapping a model\nModc = bootstrap(Mod)\nLSurvival._fit!(Modc, start=Modc.P._B);\nModc\nModc.P.X == nothing\nModc.R == nothing\n\n\nBootstrap Cox model coefficients\n\nLSurvival._fit!(mb, keepx=true, keepy=true, start=[0.0, 0.0])\n\nusing LSurvival, Random\nres = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 200)\nint = zeros(length(d)) # no late entry\nX = hcat(z, x)\n\nmainfit = fit(PHModel, X, int, outt, d .* (event .== 1), keepx=true, keepy=true)\n\nfunction stddev_finite(x)\n n = length(x)\n mnx = sum(x)/n\n ret = sum((x .- mnx) .^ 2)\n ret /= n-1\n sqrt(ret)\nend\n\n# bootstrap standard error versus asymptotic\nmb = bootstrap(MersenneTwister(123123), mainfit, 200)\n## bootstrap standard error\n[stddev_finite(mb[:,i]) for i in 1:2]\n## asymptotic standard error\nstderror(mainfit)\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Tuple{MersenneTwister, PHModel}","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrapping coefficients of a proportional hazards model\n\nSignatures\n\n# single bootstrap draw, keeping the entire object\nbootstrap(rng::MersenneTwister, m::PHModel)\nbootstrap(m::PHModel)\n# muliple bootstrap draws, keeping only coefficient estimates\nbootstrap(rng::MersenneTwister, m::PHModel, iter::Int; kwargs...)\nbootstrap(m::PHModel, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up\n\nusing LSurvival, Random\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 500, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nweights = rand(length(d))\n\n# survival outcome:\nR = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only\nP = PHParms(X)\n\nMod = PHModel(R, P)\nLSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)\n\n\n# careful propogation of bootstrap sampling\nidx, R2 = bootstrap(R)\nP2 = bootstrap(idx, P)\nModb = PHModel(R2, P2)\nLSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)\n\n# convenience function for bootstrapping a model\nModc = bootstrap(Mod)\nLSurvival._fit!(Modc, start=Modc.P._B);\nModc\nModc.P.X == nothing\nModc.R == nothing\n\n\nBootstrap Cox model coefficients\n\nLSurvival._fit!(mb, keepx=true, keepy=true, start=[0.0, 0.0])\n\nusing LSurvival, Random\nres = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 200)\nint = zeros(length(d)) # no late entry\nX = hcat(z, x)\n\nmainfit = fit(PHModel, X, int, outt, d .* (event .== 1), keepx=true, keepy=true)\n\nfunction stddev_finite(x)\n n = length(x)\n mnx = sum(x)/n\n ret = sum((x .- mnx) .^ 2)\n ret /= n-1\n sqrt(ret)\nend\n\n# bootstrap standard error versus asymptotic\nmb = bootstrap(MersenneTwister(123123), mainfit, 200)\n## bootstrap standard error\n[stddev_finite(mb[:,i]) for i in 1:2]\n## asymptotic standard error\nstderror(mainfit)\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Tuple{Vector{Int64}, PHParms}","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrap sampling of a proportional hazards predictor object\n\nusing LSurvival, Random\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nweights = rand(length(d))\n\n# survival outcome:\nR = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only\nP = PHParms(X)\nidx, R2 = bootstrap(R)\nP2 = bootstrap(idx, P)\n\nMod = PHModel(R2, P2)\nLSurvival._fit!(Mod, start=Mod.P._B)\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M<:AJSurv","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrap methods for Aalen-Johansen cumulative risk estimator\n\nSignatures\n\n # single bootstrap draw, keeping the entire object\n bootstrap(rng::MersenneTwister, m::AJSurv)\n bootstrap(m::AJSurv)\n\n # muliple bootstrap draws, keeping only coefficient estimates\n bootstrap(rng::MersenneTwister, m::AJSurv, iter::Int; kwargs...)\n bootstrap(m::AJSurv, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up\n\nusing LSurvival\nusing Random\n\nz, x, t, d, event, wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 100)\nid = 1:length(x)\nenter = zeros(length(t))\n\naj1 = aalen_johansen(enter, t, event, id=ID.(id), wts=wt)\naj2 = bootstrap(aj1, keepy=false);\najboot = bootstrap(aj1, 10, keepy=false);\naj1\n\n\naj1.R\naj2.R\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M<:KMSurv","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrap methods for Kaplan-Meier survival curve estimator\n\nSignatures\n\n # single bootstrap draw, keeping the entire object\n bootstrap(rng::MersenneTwister, m::KMSurv)\n bootstrap(m::KMSurv)\n\n # muliple bootstrap draws, keeping only coefficient estimates\n bootstrap(rng::MersenneTwister, m::KMSurv, iter::Int; kwargs...)\n bootstrap(m::KMSurv, iter::Int; kwargs...)\n\nReturns:\n\nIf using bootstrap(m): a single bootstrap draw\nIf using bootstrap(m, 10) (e.g.): 10 bootstrap draws of the survival probability at the end of follow up\n\nusing LSurvival\nusing Random\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nwts = rand(length(d))\n\nkm1 = kaplan_meier(int, outt, d, id=ID.(id), wts=wts)\nkm2 = bootstrap(km1, keepy=false)\nkm3 = bootstrap(km1, 10, keepy=false)\nkm1\n\nkm1.R\nkm2.R\n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T<:LSurvivalCompResp","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrapping sampling of a competing risk survival response\n\nSignatures\n\nbootstrap(rng::MersenneTwister, R::T) where {T<:LSurvivalCompResp}\nbootstrap(R::T) where {T<:LSurvivalCompResp}\n\nz,x,t,d,event,weights =\nLSurvival.dgm_comprisk(MersenneTwister(1212), 300)\nenter = zeros(length(event))\n\n# survival outcome:\nR = LSurvivalCompResp(enter, t, event, weights, ID.(collect(1:length(t))))    # specification with ID only\nbootstrap(R) # note that entire observations/clusters identified by id are kept\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T<:LSurvivalResp","page":"Home","title":"LSurvival.bootstrap","text":"Bootstrapping sampling of a survival response\n\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)\n\nd, X = data[:, 4], data[:, 1:3]\nweights = rand(length(d))\n\n# survival outcome:\nR = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.coxph-Tuple{Any, Any, Any, Any, Vararg{Any}}","page":"Home","title":"LSurvival.coxph","text":"Fit method for AbstractPH objects (Cox models)\n\nKeyword arguments (used here, and passed on to internal structs)\n\nties \"breslow\" or \"efron\" (default)\nwts observation weights\nties \"breslow\" or \"efron\" (default)\noffset not currently used at all\nfitargs arguments passed to other structs, which include\nid cluster or individual level ID (defaults to a unique value for each row of data) see note below on ID\ncontrasts StatsModel style contrasts (dicts) that can be used for variable transformations/indicator variable creation (e.g. https://juliastats.org/StatsModels.jl/stable/contrasts/)\nSignatures\nfit(::Type{M},\nX::AbstractMatrix,#{<:FP},\nenter::AbstractVector{<:Real},\nexit::AbstractVector{<:Real},\ny::Union{AbstractVector{<:Real},BitVector}\n;\nties =\"breslow\",\nwts::AbstractVector{<:Real}      = similar(y, 0),\noffset::AbstractVector{<:Real}   = similar(y, 0),\nfitargs...) where {M<:AbstractPH}\n```\n\ncoxph(f::FormulaTerm, data; kwargs...)   ```\n\ncoxph(X, enter, exit, y, args...; kwargs...)\n\njulia    using LSurvival, Random    z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);    enter = zeros(length(t));    X = hcat(x,rand(length(x)));     m = fit(PHModel, X, enter, t, d, ties=\"efron\")    m2 = fit(PHModel, X, enter, t, d, ties=\"breslow\")    coeftable(m)\n\nNote on use of id keyword\n\nid is not needed in person-period structure data for standard estimates or confidence intervals\n\n```@example   using Random, LSurvival      id, int, outt, dat =          LSurvival.dgm(MersenneTwister(123123), 100, 100; afun = LSurvival.int_0)      data = (              int = int,              outt = outt,              d = dat[:,4] .== 1,              x = dat[:,1],              z = dat[:,2]      )\n\n f = @formula(Surv(int, outt,d)~x+z)\n coxph(f, data)\n\n```\n\nBUT, you must specify id to get appropriate robust variance and some other statistics.\n\nHere is an example where the same data are presented in two different ways, which should yield identical statistics when used in Cox model.   ```@example  dat1 = (     time = [1,1,6,6,8,9],     status = [1,0,1,1,0,1],     x = [1,1,1,0,0,0]   )   ft = coxph(@formula(Surv(time,status)~x),dat1)   bic(ft)   nobs(ft)   dof_residual(ft)\n\nlrtest is another one\n\nstderror(ft)                     # model based   stderror(ft, type=\"robust\")   # robust standard error, based on dfbeta residuals   ft\n\nnow using \"clustered\" data with multiple observations per individual\n\ndat1clust= (      id = [1,2,3,3,4,4,5,5,6,6],      enter = [0,0,0,1,0,1,0,1,0,1],      exit = [1,1,1,6,1,6,1,8,1,9],      status = [1,0,0,1,0,1,0,0,0,1],      x = [1,1,1,1,0,0,0,0,0,0]  )\n\nuse the id parameter with the ID struct\n\nft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id))  bic(ft2)                       # CORRECT          nobs(ft2)                      # CORRECT  dof_residual(ft2)              # CORRECT\n\nstderror(ft2)                  # model based (CORRECT)  stderror(ft2, type=\"robust\")   # robust standard error, based on id level dfbeta residuals (CORRECT)\n\nonce robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics\n\nft2   # CORRECT (compare to ft object)   ```\n\nNOTE THE FOLLOWING IS INCORRECT because the id keyword is omitted\n\n```@example  ft2w = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust)  bic(ft2w)                          # INCORRECT   nobs(ft2w)                         # INCORRECT  dof_residual(ft2w)                 # INCORRECT\n\nstderror(ft2w)                     # model based (CORRECT)  stderror(ft2w, type=\"robust\")      # robust variance (INCORRECT)\n\nft2w # the coefficient table now shows incorrect confidence intervals and test statistics\n\n```\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.dgm-Tuple{MersenneTwister, Int64, Int64}","page":"Home","title":"LSurvival.dgm","text":"Generating discrete survival data without competing risks\n\nSignatures\n\ndgm(rng::MersenneTwister, n::Int, maxT:Int; afun = int_0, yfun = yprob, lfun = lprob)\n\ndgm(n::Int, maxT::Int; kwargs...)\n\nUsage: dgm(rng, n, maxT;afun=int0, yfun=yprob, lfun=lprob) dgm(n, maxT;afun=int0, yfun=yprob, lfun=lprob)\n\nWhere afun, yfun, and lfun are all functions that take arguments v,l,a and output time-specific values of a, y, and l respectively Example:\n\n\nexpit(mu) =  inv(1.0+exp(-mu))\n\nfunction aprob(v,l,a)\nexpit(-1.0 + 3*v + 2*l)\nend\n  \nfunction lprob(v,l,a)\nexpit(-3 + 2*v + 0*l + 0*a)\nend\n  \nfunction yprob(v,l,a)\nexpit(-3 + 2*v + 0*l + 2*a)\nend\n  # 10 individuals followed for up to 5 times\nLSurvival.dgm(10, 5;afun=aprob, yfun=yprob, lfun=lprob)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.dgm_comprisk-Tuple{MersenneTwister, Int64}","page":"Home","title":"LSurvival.dgm_comprisk","text":"Generating continuous survival data with competing risks\n\nSignatures\n\ndgm_comprisk(rng::MersenneTwister, n::Int)\n\ndgm_comprisk(n::Int)\n\n    - rng = random number generator    \n    - n = sample size\n\nExample:\n\nusing LSurvival\n# 100 individuals with two competing events\nz,x,t,d,event,weights = LSurvival.dgm_comprisk(100)\n    \n\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.jackknife-Tuple{M} where M<:AJSurv","page":"Home","title":"LSurvival.jackknife","text":"Obtain jackknife (leave-one-out) estimates from a Aalen-Johansen risk curve (risk at end of follow-up) by refitting the model n times\n\nSignatures\n\njackknife(m::M;kwargs...) where {M<:AJSurv}\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.jackknife-Tuple{M} where M<:KMSurv","page":"Home","title":"LSurvival.jackknife","text":"Obtain jackknife (leave-one-out) estimates from a Kaplan-Meier survival curve (survival at end of follow-up) by refitting the model n times\n\nSignatures\n\njackknife(m::M;kwargs...) where {M<:KMSurv}\n\nusing LSurvival, Random, StatsBase\n\ndat1 = (time = [1, 1, 6, 6, 8, 9], status = [1, 0, 1, 1, 0, 1], x = [1, 1, 1, 0, 0, 0])\n\ndat1clust = (\n  id = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6],\n  enter = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1],\n  exit = [1, 1, 1, 6, 1, 6, 1, 8, 1, 9],\n  status = [1, 0, 0, 1, 0, 1, 0, 0, 0, 1],\n  x = [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],\n)\n\nm = kaplan_meier(dat1.time, dat1.status)\na = aalen_johansen(dat1.time, dat1.status)\nmc = kaplan_meier(dat1clust.enter, dat1clust.exit, dat1clust.status, id=ID.(dat1clust.id))\nac = aalen_johansen(dat1clust.enter, dat1clust.exit, dat1clust.status, id=ID.(dat1clust.id))\njk = jackknife(m);\njkc = jackknife(mc);\njka = jackknife(a);\nbs = bootstrap(mc, 100);\nstd(bs[:,1])\nstderror(m, type=\"jackknife\")\nstderror(mc, type=\"jackknife\")\n@assert jk == jkc\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.jackknife-Tuple{M} where M<:PHModel","page":"Home","title":"LSurvival.jackknife","text":"Obtain jackknife (leave-one-out) estimates from a Cox model by refitting the model n times\n\nusing LSurvival, Random, StatsBase\nid, int, outt, data =\nLSurvival.dgm(MersenneTwister(112), 100, 10; afun = LSurvival.int_0)\ndata[:, 1] = round.(data[:, 1], digits = 3)\nd, X = data[:, 4], data[:, 1:3]\nwt = rand(length(d))\nwt ./= (sum(wt) / length(wt))\nm = coxph(X,int, outt,d, wts=wt, id=ID.(id))\n\njk = jackknife(m);\nbs = bootstrap(MersenneTwister(12321), m, 1000);\nN = nobs(m)\n#comparing estimate with jackknife estimate with bootstrap mean\nhcat(coef(m), mean(jk, dims=1)[1,:], mean(bs, dims=1)[1,:])\nsemb = stderror(m)\nsebs = std(bs, dims=1)\nsero = stderror(m, type=\"robust\")\nsejk = stderror(m, type=\"jackknife\")\nsejk_manual = std(jk, dims=1, corrected=false) .* sqrt(N-1)\n\nsqrt.(diag(LSurvival.jackknife_vcov(m)))\n\nhcat(semb, sebs[1,:], sejk, sejk_manual[1,:], sero)\n\ndat1 = (time = [1, 1, 6, 6, 8, 9], status = [1, 0, 1, 1, 0, 1], x = [1, 1, 1, 0, 0, 0])\ndat1clust = (\n  id = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6],\n  enter = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1],\n  exit = [1, 1, 1, 6, 1, 6, 1, 8, 1, 9],\n  status = [1, 0, 0, 1, 0, 1, 0, 0, 0, 1],\n  x = [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],\n)\n\nm = coxph(@formula(Surv(time, status)~x),dat1)\nmc = coxph(@formula(Surv(enter, exit, status)~x),dat1clust, id=ID.(dat1clust.id))\njk = jackknife(m);\njkc = jackknife(mc);\nbs = bootstrap(mc, 100);\nstd(bs[:,1])\nstderror(m, type=\"jackknife\")\nstderror(mc, type=\"jackknife\")\n@assert jk == jkc\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.kaplan_meier-Tuple{Any, Any, Any}","page":"Home","title":"LSurvival.kaplan_meier","text":"Kaplan-Meier estimator for cumulative conditional risk\n\nSignatures\n\nStatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\nkaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; kwargs...)\n\nKeyword arguments\n\nwts::Vector{<:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation\nid::Vector{<:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)\natol = 0.00000001; absolute tolerance for defining tied event times\ncensval = 0;  value of the outcome to be considered a censored event\nkeepy = true; keep the outcome vector after fitting (may save memory with large datasets)\neps = 0.00000001; deprecated (replaced by atol)\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\nm = fit(KMSurv, enter, t, d)\nmw = fit(KMSurv, enter, t, d, wts=wt)\n\nor, equivalently:\n\nkaplan_meier(enter, t, d, wts=wt)\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lgh_breslow!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M<:AbstractPH","page":"Home","title":"LSurvival.lgh_breslow!","text":"Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).\n\nUses Breslow's partial likelihood.\n\nUpdates over all observations\n\nSignature\n\nlgh_breslow!(m::M, j, caseidx, risksetidx) where {M<:AbstractPH}\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.lgh_efron!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M<:AbstractPH","page":"Home","title":"LSurvival.lgh_efron!","text":"Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).\n\nUses Efron's partial likelihood.\n\nUpdates over all observations\n\nSignature\n\nlgh_efron!(m::M, j, caseidx, risksetidx) where {M<:AbstractPH}\n\n\n\n\n\n","category":"method"},{"location":"#LSurvival.risk_from_coxphmodels-Union{Tuple{T}, Tuple{Vector{T}, Vararg{Any}}} where T<:PHModel","page":"Home","title":"LSurvival.risk_from_coxphmodels","text":"Survival curve estimation using multiple cox models\n\nSignatures\n\n```julia   riskfromcoxphmodels(fitlist::Vector{T}, args...; kwargs...) where {T<:PHModel}\n\nfit(::Type{M}, fitlist::Vector{T}, ; fitargs...) where {M<:PHSurv,T<:PHModel}  ```\n\nOptional keywords\n\ncoef_vectors = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]\npred_profile = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]\n\n```@example  using LSurvival  using Random\n\nevent variable is coded 0[referent],1,2\n\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);  enter = zeros(length(t));\n\nft1 = coxph(hcat(x,z), enter, t, (event .== 1))  nidx = findall(event .!= 1)  ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))\n\nrisk at referent levels of x and z\n\nriskfromcoxphmodels([ft1,ft2])\n\nrisk at average levels of x and z\n\nmnx = sum(x)/length(x)  mnz = sum(z)/length(z)\n\nequivalent\n\nfit(PHSurv, [ft1,ft2], predprofile=[mnx,mnz])  riskfromcoxphmodels([ft1,ft2], predprofile=[mnx,mnz])  ```\n\n\n\n\n\n","category":"method"},{"location":"#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, AJSurv}","page":"Home","title":"RecipesBase.apply_recipe","text":"Recipe for aalen-johansen risk curve\n\n    using Plots, LSurvival\n    res = z, x, outt, d, event, weights = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)\n    int = zeros(length(d)) # no late entry\n    \n        c = fit(AJSurv, int, outt, event)\n        #risk2 = aalen_johansen(int, outt, event)\n        plot(c)\n\n\n\n\n\n","category":"method"},{"location":"#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, KMSurv}","page":"Home","title":"RecipesBase.apply_recipe","text":"Recipe for kaplan meier curve\n\n    using Plots, LSurvival\ndat4 = (\n    id = [1, 1, 2, 2, 2, 3, 4, 5, 5, 6],\n    enter = [1, 2, 5, 4, 6, 7, 3, 6, 8, 0],\n    exit = [2, 5, 6, 7, 8, 9, 6, 8, 14, 9],\n    status = [0, 1, 0, 0, 1, 0, 1, 0, 0, 1],\n    x = [0.1, 0.1, 1.5, 1.5, 1.5, 0, 0, 0, 0, 3],\n    z = [1, 1, 0, 0, 0, 0, 0, 1, 1, 0],\n    w = [0, 0, 0, 0, 0, 1, 1, 1, 1, 0],\n)\nR = LSurvivalResp(dat4.enter, dat4.exit, dat4.status)\n    k = kaplan_meier(dat4.enter, dat4.exit, dat4.status)\n    plot(k)\n\n\n\n\n\n","category":"method"},{"location":"#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.BaseHazPlot}","page":"Home","title":"RecipesBase.apply_recipe","text":"Plotting baseline hazard for a Cox model\n\nusing Plots, LSurvival\ndat2 = (\n    enter = [1, 2, 5, 2, 1, 7, 3, 4, 8, 8],\n    exit = [2, 3, 6, 7, 8, 9, 9, 9, 14, 17],\n    status = [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],\n    x = [1, 0, 0, 1, 0, 1, 1, 1, 0, 0],\n)\nfte = coxph(@formula(Surv(enter, exit, status)~x), dat2, maxiter=0)\nftb = coxph(@formula(Surv(enter, exit, status)~x), dat2, ties=\"breslow\", maxiter=0)\n\nplot(fte, label=\"Efron\")\nplot!(ftb, label=\"Breslow\")\n\n\n\n\n\n","category":"method"},{"location":"#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.CoxDX}","page":"Home","title":"RecipesBase.apply_recipe","text":"using Plots, LSurvival\ndat2 = (\n    enter = [1, 2, 5, 2, 1, 7, 3, 4, 8, 8],\n    exit = [2, 3, 6, 7, 8, 9, 9, 9, 14, 17],\n    status = [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],\n    x = [1, 0, 0, 1, 0, 1, 1, 1, 0, 0],\n)\nfte = coxph(@formula(Surv(enter, exit, status)~x), dat2)\n\ncoxdx(fte)\n\n\n\n\n\n\n","category":"method"},{"location":"#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.CoxInfluence}","page":"Home","title":"RecipesBase.apply_recipe","text":"using Plots, LSurvival\ndat2 = (\n    enter = [1, 2, 5, 2, 1, 7, 3, 4, 8, 8],\n    exit = [2, 3, 6, 7, 8, 9, 9, 9, 14, 17],\n    status = [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],\n    x = [1, 0, 0, 1, 0, 1, 1, 1, 0, 0],\n)\nfte = coxph(@formula(Surv(enter, exit, status)~x), dat2)\n\ncoxinfluence(fte, type=\"jackknife\", par=1)\ncoxinfluence!(fte, type=\"dfbeta\", color=:red, par=1)\n\n\n\n\n\n\n","category":"method"},{"location":"#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvivalResp}","page":"Home","title":"RecipesBase.apply_recipe","text":"using Plots, LSurvival\n\ndat4 = (\n    id = [1, 1, 2, 2, 2, 3, 4, 5, 5, 6],\n    enter = [1, 2, 5, 4, 6, 7, 3, 6, 8, 0],\n    exit = [2, 5, 6, 7, 8, 9, 6, 8, 14, 9],\n    status = [0, 1, 0, 0, 1, 0, 1, 0, 0, 1],\n    x = [0.1, 0.1, 1.5, 1.5, 1.5, 0, 0, 0, 0, 3],\n    z = [1, 1, 0, 0, 0, 0, 0, 1, 1, 0],\n    w = [0, 0, 0, 0, 0, 1, 1, 1, 1, 0],\n)\nR = LSurvivalResp(dat4.enter, dat4.exit, dat4.status)\nplot([[R.enter[i], R.exit[i]] for i in eachindex(R.enter)], [[i, i] for i in values(R.id)])\n\n\n\n\n\n","category":"method"},{"location":"#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, PHSurv}","page":"Home","title":"RecipesBase.apply_recipe","text":"Recipe for cox-model based risk curves\n\n    using Plots, LSurvival, Random, StatsBase\n    res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)\n    X = hcat(z, x)\n    int = zeros(length(d)) # no late entry\n    ft1 = fit(PHModel, X, int, outt, d .* (event .== 1), wts=wts)\n    ft2 = fit(PHModel, X, int, outt, d .* (event .== 2), wts=wts)\n    c = risk_from_coxphmodels([ft1, ft2], pred_profile = mean(X, dims=1))\n    \n    plot(c)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.confint-Tuple{AJSurv}","page":"Home","title":"StatsAPI.confint","text":"Greenwood's formula for variance and confidence intervals of a Aalen-Johansen risk function\n\nSignatures:\n\nStatsBase.stderror(m::AJSurv)\n\nStatsBase.confint(m:AJSurv; level=0.95, method=\"normal\")\n\nKeyword arguments\n\nmethod\n\"normal\" normality-based confidence intervals\n\"lognlog\" log(-log(S(t))) based confidence intervals\n\nres = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)\nint = zeros(length(d)) # no late entry\nm = fit(AJSurv, int, outt, event)\nstderror(m)\nconfint(m, level=0.95)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.confint-Tuple{KMSurv}","page":"Home","title":"StatsAPI.confint","text":"Greenwood's formula for variance and confidence intervals of a Kaplan-Meier survival curve\n\nSignatures:\n\nStatsBase.stderror(m::KMSurv)\n\nStatsBase.confint(m:KMSurv; level=0.95, method=\"normal\")\n\nKeyword arguments\n\nmethod:\n\n\"normal\" normality-based confidence intervals\n\"lognlog\" log(-log(S(t))) based confidence intervals\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\nm = fit(KMSurv, enter, t, d)\nmw = fit(KMSurv, enter, t, d, wts=wt)\nstderror(m)\nconfint(m, method=\"normal\")\nconfint(m, method=\"lognlog\") # log-log transformation\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.confint-Tuple{M} where M<:AbstractPH","page":"Home","title":"StatsAPI.confint","text":"using LSurvival\n dat1= (\n   time = [1,1,6,6,8,9],\n   status = [1,0,1,1,0,1],\n   x = [1,1,1,0,0,0]\n )\n\n ft = coxph(@formula(Surv(time, status) ~ x),dat1, keepx=true)\n # model-based variance\n confint(ft)\n\n # robust variance\n confint(ft, type=\"robust\")\n\nfor cluster confidence intervals\n\n```julia  dat1clust= (    id = [1,2,3,3,4,4,5,5,6,6],    enter = [0,0,0,1,0,1,0,1,0,1],    exit = [1,1,1,6,1,6,1,8,1,9],    status = [1,0,0,1,0,1,0,0,0,1],    x = [1,1,1,1,0,0,0,0,0,0]  )\n\nft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id), keepx=true)\n\nmodel-based variance\n\nconfint(ft2)\n\nrobust variance\n\nconfint(ft2, type=\"robust\") ````\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit!-Tuple{T} where T<:AbstractNPSurv","page":"Home","title":"StatsAPI.fit!","text":"Kaplan-Meier estimator for cumulative conditional risk\n\nSignatures\n\nStatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\nkaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; kwargs...)\n\nKeyword arguments\n\nwts::Vector{<:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation\nid::Vector{<:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)\natol = 0.00000001; absolute tolerance for defining tied event times\ncensval = 0;  value of the outcome to be considered a censored event\nkeepy = true; keep the outcome vector after fitting (may save memory with large datasets)\neps = 0.00000001; deprecated (replaced by atol)\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\nm = fit(KMSurv, enter, t, d)\nmw = fit(KMSurv, enter, t, d, wts=wt)\n\nor, equivalently:\n\nkaplan_meier(enter, t, d, wts=wt)\n\nAalen-Johansen estimator for cumulative cause-specific risk (in the presence of competing events)\n\nSignatures\n\n StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\n aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; kwargs...)\n\n\nKeyword arguments\n\nwts::Vector{<:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation\nid::Vector{<:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)\natol = 0.00000001; absolute tolerance for defining tied event times\nkeepy = true; keep the outcome vector after fitting (may save memory with large datasets)\neps = 0.00000001; deprecated (replaced by atol)\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\n   # event variable is coded 0[referent],1,2\nm = fit(AJSurv, enter, t, event)\nmw = fit(AJSurv, enter, t, event, wts=wt)\n\nor, equivalently:\n\naalen_johansen(enter, t, event, wts=wt)\n\nSurvival curve estimation using multiple cox models\n\nSignatures\n\n```julia   riskfromcoxphmodels(fitlist::Vector{T}, args...; kwargs...) where {T<:PHModel}\n\nfit(::Type{M}, fitlist::Vector{T}, ; fitargs...) where {M<:PHSurv,T<:PHModel}  ```\n\nOptional keywords\n\ncoef_vectors = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]\npred_profile = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]\n\n```@example  using LSurvival  using Random\n\nevent variable is coded 0[referent],1,2\n\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);  enter = zeros(length(t));\n\nft1 = coxph(hcat(x,z), enter, t, (event .== 1))  nidx = findall(event .!= 1)  ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))\n\nrisk at referent levels of x and z\n\nriskfromcoxphmodels([ft1,ft2])\n\nrisk at average levels of x and z\n\nmnx = sum(x)/length(x)  mnz = sum(z)/length(z)\n\nequivalent\n\nfit(PHSurv, [ft1,ft2], predprofile=[mnx,mnz])  riskfromcoxphmodels([ft1,ft2], predprofile=[mnx,mnz])  ```\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{T}, Tuple{M}, Tuple{Type{M}, Vector{T}}} where {M<:PHSurv, T<:PHModel}","page":"Home","title":"StatsAPI.fit","text":"Survival curve estimation using multiple cox models\n\nSignatures\n\n```julia   riskfromcoxphmodels(fitlist::Vector{T}, args...; kwargs...) where {T<:PHModel}\n\nfit(::Type{M}, fitlist::Vector{T}, ; fitargs...) where {M<:PHSurv,T<:PHModel}  ```\n\nOptional keywords\n\ncoef_vectors = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]\npred_profile = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]\n\n```@example  using LSurvival  using Random\n\nevent variable is coded 0[referent],1,2\n\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);  enter = zeros(length(t));\n\nft1 = coxph(hcat(x,z), enter, t, (event .== 1))  nidx = findall(event .!= 1)  ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))\n\nrisk at referent levels of x and z\n\nriskfromcoxphmodels([ft1,ft2])\n\nrisk at average levels of x and z\n\nmnx = sum(x)/length(x)  mnz = sum(z)/length(z)\n\nequivalent\n\nfit(PHSurv, [ft1,ft2], predprofile=[mnx,mnz])  riskfromcoxphmodels([ft1,ft2], predprofile=[mnx,mnz])  ```\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Matrix{<:Real}, Vector{<:Real}, Vector{<:Real}, Y}} where {M<:AbstractPH, Y<:Union{BitVector, Vector{<:Real}}}","page":"Home","title":"StatsAPI.fit","text":"Fit method for AbstractPH objects (Cox models)\n\nKeyword arguments (used here, and passed on to internal structs)\n\nties \"breslow\" or \"efron\" (default)\nwts observation weights\nties \"breslow\" or \"efron\" (default)\noffset not currently used at all\nfitargs arguments passed to other structs, which include\nid cluster or individual level ID (defaults to a unique value for each row of data) see note below on ID\ncontrasts StatsModel style contrasts (dicts) that can be used for variable transformations/indicator variable creation (e.g. https://juliastats.org/StatsModels.jl/stable/contrasts/)\nSignatures\nfit(::Type{M},\nX::AbstractMatrix,#{<:FP},\nenter::AbstractVector{<:Real},\nexit::AbstractVector{<:Real},\ny::Union{AbstractVector{<:Real},BitVector}\n;\nties =\"breslow\",\nwts::AbstractVector{<:Real}      = similar(y, 0),\noffset::AbstractVector{<:Real}   = similar(y, 0),\nfitargs...) where {M<:AbstractPH}\n```\n\ncoxph(f::FormulaTerm, data; kwargs...)   ```\n\ncoxph(X, enter, exit, y, args...; kwargs...)\n\njulia    using LSurvival, Random    z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);    enter = zeros(length(t));    X = hcat(x,rand(length(x)));     m = fit(PHModel, X, enter, t, d, ties=\"efron\")    m2 = fit(PHModel, X, enter, t, d, ties=\"breslow\")    coeftable(m)\n\nNote on use of id keyword\n\nid is not needed in person-period structure data for standard estimates or confidence intervals\n\n```@example   using Random, LSurvival      id, int, outt, dat =          LSurvival.dgm(MersenneTwister(123123), 100, 100; afun = LSurvival.int_0)      data = (              int = int,              outt = outt,              d = dat[:,4] .== 1,              x = dat[:,1],              z = dat[:,2]      )\n\n f = @formula(Surv(int, outt,d)~x+z)\n coxph(f, data)\n\n```\n\nBUT, you must specify id to get appropriate robust variance and some other statistics.\n\nHere is an example where the same data are presented in two different ways, which should yield identical statistics when used in Cox model.   ```@example  dat1 = (     time = [1,1,6,6,8,9],     status = [1,0,1,1,0,1],     x = [1,1,1,0,0,0]   )   ft = coxph(@formula(Surv(time,status)~x),dat1)   bic(ft)   nobs(ft)   dof_residual(ft)\n\nlrtest is another one\n\nstderror(ft)                     # model based   stderror(ft, type=\"robust\")   # robust standard error, based on dfbeta residuals   ft\n\nnow using \"clustered\" data with multiple observations per individual\n\ndat1clust= (      id = [1,2,3,3,4,4,5,5,6,6],      enter = [0,0,0,1,0,1,0,1,0,1],      exit = [1,1,1,6,1,6,1,8,1,9],      status = [1,0,0,1,0,1,0,0,0,1],      x = [1,1,1,1,0,0,0,0,0,0]  )\n\nuse the id parameter with the ID struct\n\nft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id))  bic(ft2)                       # CORRECT          nobs(ft2)                      # CORRECT  dof_residual(ft2)              # CORRECT\n\nstderror(ft2)                  # model based (CORRECT)  stderror(ft2, type=\"robust\")   # robust standard error, based on id level dfbeta residuals (CORRECT)\n\nonce robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics\n\nft2   # CORRECT (compare to ft object)   ```\n\nNOTE THE FOLLOWING IS INCORRECT because the id keyword is omitted\n\n```@example  ft2w = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust)  bic(ft2w)                          # INCORRECT   nobs(ft2w)                         # INCORRECT  dof_residual(ft2w)                 # INCORRECT\n\nstderror(ft2w)                     # model based (CORRECT)  stderror(ft2w, type=\"robust\")      # robust variance (INCORRECT)\n\nft2w # the coefficient table now shows incorrect confidence intervals and test statistics\n\n```\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{<:Real}, Vector{<:Real}, Y}} where {M<:AJSurv, Y<:Union{BitVector, Vector{<:Real}}}","page":"Home","title":"StatsAPI.fit","text":"Aalen-Johansen estimator for cumulative cause-specific risk (in the presence of competing events)\n\nSignatures\n\n StatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\n aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; kwargs...)\n\n\nKeyword arguments\n\nwts::Vector{<:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation\nid::Vector{<:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)\natol = 0.00000001; absolute tolerance for defining tied event times\nkeepy = true; keep the outcome vector after fitting (may save memory with large datasets)\neps = 0.00000001; deprecated (replaced by atol)\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\n   # event variable is coded 0[referent],1,2\nm = fit(AJSurv, enter, t, event)\nmw = fit(AJSurv, enter, t, event, wts=wt)\n\nor, equivalently:\n\naalen_johansen(enter, t, event, wts=wt)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{<:Real}, Vector{<:Real}, Y}} where {M<:KMSurv, Y<:Union{BitVector, Vector{<:Real}}}","page":"Home","title":"StatsAPI.fit","text":"Kaplan-Meier estimator for cumulative conditional risk\n\nSignatures\n\nStatsBase.fit!(m::T; kwargs...) where {T<:AbstractNPSurv}\n\nkaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,\n   ; kwargs...)\n\nKeyword arguments\n\nwts::Vector{<:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation\nid::Vector{<:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)\natol = 0.00000001; absolute tolerance for defining tied event times\ncensval = 0;  value of the outcome to be considered a censored event\nkeepy = true; keep the outcome vector after fitting (may save memory with large datasets)\neps = 0.00000001; deprecated (replaced by atol)\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\nm = fit(KMSurv, enter, t, d)\nmw = fit(KMSurv, enter, t, d, wts=wt)\n\nor, equivalently:\n\nkaplan_meier(enter, t, d, wts=wt)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.loglikelihood-Tuple{M} where M<:AbstractPH","page":"Home","title":"StatsAPI.loglikelihood","text":"Maximum log partial likelihood for a fitted AbstractPH model Efron or Breslow (depending on the ties` parameter)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.nullloglikelihood-Tuple{M} where M<:AbstractPH","page":"Home","title":"StatsAPI.nullloglikelihood","text":"Null log-partial likelihood for a fitted AbstractPH model Efron or Breslow (depending on the ties` parameter)\n\nNote: this is just the log partial likelihood at the initial values of the model, which default to 0. If initial values are non-null, then this function no longer validly returns the null log-partial likelihood.\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.residuals-Tuple{M} where M<:PHModel","page":"Home","title":"StatsAPI.residuals","text":"####################################################################\n\nCox proportional hazards model residuals:\n\nSignature\n\njulia   residuals(m::M; type = \"martingale\") where {M<:PHModel}   where type is one of \n\nmartingale\nschoenfeld\nscore\ndfbeta\nscaled_schoenfeld\nResiduals from the residuals function are designed to exactly emulate those from the survival package in R. Currently, they are validated for single observation data (e.g. one data row per individual).\n####################################################################\nMartingale residuals: Observed versus expected\n# example from https://cran.r-project.org/web/packages/survival/vignettes/validate.pdf\n# by Terry Therneau\n\ndat1 = (\n  time = [1,1,6,6,8,9],\n  status = [1,0,1,1,0,1],\n  x = [1,1,1,0,0,0]\n)\n\n# Nelson-Aalen type estimator for Breslow partial likelihood\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"breslow\")\nresiduals(ft, type=\"martingale\")\ndat1 = (\n  time = [1,1,6,6,8,9],\n  status = [1,0,1,1,0,1],\n  x = [1,1,1,0,0,0]\n)\n\n# Fleming-Harrington type estimator for Efron partial likelihood\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"efron\")\nresiduals(ft, type=\"martingale\")\n\n####################################################################\nScore residuals: Per observation contribution to score function\nusing LSurvival\ndat1 = (\n  time = [1,1,6,6,8,9],\n  status = [1,0,1,1,0,1],\n  x = [1,1,1,0,0,0]\n)\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"breslow\")\nS = residuals(ft, type=\"score\")[:]\nft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"efron\", maxiter=0)\nS = residuals(ft, type=\"score\")[:]\n####################################################################\nSchoenfeld residuals: Per time contribution to score function\n```julia using LSurvival dat1 = (   time = [1,1,6,6,8,9],   status = [1,0,1,1,0,1],   x = [1,1,1,0,0,0] ) ft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=\"breslow\", maxiter=0)\n\nX = ft.P.X   M = residuals(ft, type=\"martingale\")   S = residuals(ft, type=\"schoenfeld\")[:]   ```\n\n####################################################################\n\ndfbeta residuals: influence of individual observations on each parameter\n\n```@example   using LSurvival   dat1 = (     time = [1,1,6,6,8,9],     status = [1,0,1,1,0,1],     x = [1,1,1,0,0,0]   )\n\nft = coxph(@formula(Surv(time,status)~x),dat1, ties=\"breslow\")   residuals(ft, type=\"dfbeta\")\n\ncan also calculate from score residuals and Hessian matrix\n\nL = residuals(ft, type=\"score\") # n X p   H = ft.P._hess   # p X p   dfbeta = L*inv(H)   robVar = dfbeta'dfbeta   sqrt(robVar)\n\n```\n\nusing the id keyword argument\n\nsee help for LSurvival.vcov for what happens when id keyword is not used\n\n```@example   dat1clust= (     id = [1,2,3,3,4,4,5,5,6,6],     enter = [0,0,0,1,0,1,0,1,0,1],     exit = [1,1,1,6,1,6,1,8,1,9],     status = [1,0,0,1,0,1,0,0,0,1],     x = [1,1,1,1,0,0,0,0,0,0]   )\n\nft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id), ties=\"breslow\")\n\nnote these are still on the observation level (not the id level)!\n\nresiduals(ft2, type=\"dfbeta\")\n\ngetting id level dfbeta residuals\n\ndfbeta = residuals(ft2, type=\"dfbeta\")   id = values(ft2.R.id)   D = reduce(vcat, [sum(dfbeta[findall(id .== i),:], dims=1) for i in unique(id)])   D'D   vcov(ft, type=\"robust\")   vcov(ft2, type=\"robust\")   ```\n\n####################################################################\n\njackknife residuals: influence of individual observations on each parameter using leave-one-out estimates\n\nnote there are other definitions of jackknife residuals  See Chapter 7.1 of \"Extending the Cox Model\" by Therneau and Grambsch for an example of the type of jackknife residuals used here\n\nJackknife residuals r_i for i in 1n are given as the difference between the maximum partial likelihood estimate and the jackknife estimates for each observation\n\nr_i = hatbeta - hatbeta_(-i)\n\nwhere beta_(-i) is the maximum partial likelihood estimate of the log-hazard ratio vector obtained from a dataset in which observations belonging to individual i are removed\n\n```@example   using LSurvival   dat1 = (     time = [1,1,6,6,8,9],     status = [1,0,1,1,0,1],     x = [1,1,1,0,0,0]   )\n\nft = coxph(@formula(Surv(time,status)~x),dat1, ties=\"breslow\")   #jackknife(ft)   residuals(ft, type=\"jackknife\")\n\n```\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.stderror-Tuple{AJSurv}","page":"Home","title":"StatsAPI.stderror","text":"Greenwood's formula for variance and confidence intervals of a Aalen-Johansen risk function\n\nSignatures:\n\nStatsBase.stderror(m::AJSurv)\n\nStatsBase.confint(m:AJSurv; level=0.95, method=\"normal\")\n\nKeyword arguments\n\nmethod\n\"normal\" normality-based confidence intervals\n\"lognlog\" log(-log(S(t))) based confidence intervals\n\nres = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)\nint = zeros(length(d)) # no late entry\nm = fit(AJSurv, int, outt, event)\nstderror(m)\nconfint(m, level=0.95)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.stderror-Tuple{KMSurv}","page":"Home","title":"StatsAPI.stderror","text":"Greenwood's formula for variance and confidence intervals of a Kaplan-Meier survival curve\n\nSignatures:\n\nStatsBase.stderror(m::KMSurv)\n\nStatsBase.confint(m:KMSurv; level=0.95, method=\"normal\")\n\nKeyword arguments\n\nmethod:\n\n\"normal\" normality-based confidence intervals\n\"lognlog\" log(-log(S(t))) based confidence intervals\n\nusing LSurvival\nusing Random\nz,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);\nenter = zeros(length(t));\nm = fit(KMSurv, enter, t, d)\nmw = fit(KMSurv, enter, t, d, wts=wt)\nstderror(m)\nconfint(m, method=\"normal\")\nconfint(m, method=\"lognlog\") # log-log transformation\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.vcov-Tuple{M} where M<:AbstractPH","page":"Home","title":"StatsAPI.vcov","text":"Covariance matrix for Cox proportional hazards models  \n\nKeyword arguments\n\ntype nothing or \"robust\": determines whether model based or robust (dfbeta based) variance is returned.\nSee ?residuals for info on dfbeta residuals\n\nusing LSurvival\ndat1 = (\n  time = [1,1,6,6,8,9],\n  status = [1,0,1,1,0,1],\n  x = [1,1,1,0,0,0]\n)\nft = coxph(@formula(Surv(time,status)~x),dat1, id=ID.(collect(1:6)))\n\nvcov(ft)                   # model based\nvcov(ft, type=\"robust\")    # robust variance, based on dfbeta residuals\n# once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics\nft\n\ncluster robust standard errors using the id keyword argument\n\ndat1clust= (\n  id = [1,2,3,3,4,4,5,5,6,6],\n  enter = [0,0,0,1,0,1,0,1,0,1],\n  exit = [1,1,1,6,1,6,1,8,1,9],\n  status = [1,0,0,1,0,1,0,0,0,1],\n  x = [1,1,1,1,0,0,0,0,0,0]\n)\n\nft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id))\n\nvcov(ft2)                     # model based\nvcov(ft2, type=\"robust\")       # robust variance, based on dfbeta residuals\nstderror(ft2, type=\"robust\")   # robust variance, based on dfbeta residuals\nconfint(ft2, type=\"robust\")    # robust variance, based on dfbeta residuals\nnobs(ft2)                     # id argument yields correct value of number of independent observations\n# once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics\nft2 \n\nNOTE THE FOLLOWING IS INCORRECT because the id keyword is omitted\n\nft2w = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust)\n\nvcov(ft2w)                   # model based (CORRECT)\nvcov(ft2w, type=\"robust\")    # robust variance (INCORRECT)\nnobs(ft2w)\n\nft2w\n\n\n\n\n\n","category":"method"}]
}
