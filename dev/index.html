<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · LSurvival</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>LSurvival</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Quick-examples"><span>Quick examples</span></a></li><li><a class="tocitem" href="#Index-of-functions"><span>Index of functions</span></a></li><li><a class="tocitem" href="#Function-help"><span>Function help</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/alexpkeil1/LSurvival.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="[LSurvival](https://github.com/alexpkeil1/LSurvival.jl)"><a class="docs-heading-anchor" href="#[LSurvival](https://github.com/alexpkeil1/LSurvival.jl)"><a href="https://github.com/alexpkeil1/LSurvival.jl">LSurvival</a></a><a id="[LSurvival](https://github.com/alexpkeil1/LSurvival.jl)-1"></a><a class="docs-heading-anchor-permalink" href="#[LSurvival](https://github.com/alexpkeil1/LSurvival.jl)" title="Permalink"></a></h1><p>Survival analysis functions in Julia for time-to-event outcomes that can include:</p><ul><li>Loss-to-follow-up/right censoring</li><li>Late entry/left truncation (not available in Survival.jl)</li><li>&quot;Person-period&quot; data structures (not available in Survival.jl)</li><li>Observation weights (not available in Survival.jl)</li><li>Competing risks (not available in Survival.jl)</li></ul><p>Capabilities include estimators for</p><ul><li>Kaplan-Meier non-parametric conditional risk functions</li><li>Aalen-Johansen non-parametric cause-specific unconditional risk functions</li><li>Cox proportional hazards model (Efron&#39;s or Breslow&#39;s methods for ties)</li></ul><p>Convenience functions enable:</p><ul><li>Non-parametric bootstrapping, cluster-bootstrapping</li><li>Estimating baseline hazards from a Cox Model</li><li>Estimating cause-specific risk from an exhaustive set of Cox models for competing risk outcomes</li><li>Simple simulation of competing and non-competing survival events</li><li>Cluster robust variance estimation (without bootstrapping)</li><li>Martingale, score, Schoenfeld, and dfbeta residuals</li><li>Cluster robust variance estimation</li></ul><p>Plans to include:</p><ul><li>Parametric survival models</li><li>Stratification in Cox models</li></ul><p>The package has been tuned to follow the &quot;survival&quot; package from R in terms of specific estimators/results.</p><p>Report issues <a href="https://github.com/alexpkeil1/LSurvival.jl/issues">here</a></p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><pre><code class="language- hljs">using Pkg; Pkg.add(url = &quot;https://github.com/alexpkeil1/LSurvival.jl&quot;)</code></pre><h2 id="Quick-examples"><a class="docs-heading-anchor" href="#Quick-examples">Quick examples</a><a id="Quick-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-examples" title="Permalink"></a></h2><h3 id="Single-event-type:-Cox-model-and-Kaplan-Meier-curve"><a class="docs-heading-anchor" href="#Single-event-type:-Cox-model-and-Kaplan-Meier-curve">Single event type: Cox model and Kaplan-Meier curve</a><a id="Single-event-type:-Cox-model-and-Kaplan-Meier-curve-1"></a><a class="docs-heading-anchor-permalink" href="#Single-event-type:-Cox-model-and-Kaplan-Meier-curve" title="Permalink"></a></h3><pre><code class="language- hljs">using Random, LSurvival, Distributions, LinearAlgebra

# generate some data under a discrete hazards model
expit(mu) = inv(1.0 + exp(-mu))

function dgm(rng, n, maxT; regimefun = int_0)
    V = rand(rng, n)
    LAY = Array{Float64,2}(undef, n * maxT, 4)
    keep = ones(Bool, n * maxT)
    id = sort(reduce(vcat, fill(collect(1:n), maxT)))
    time = (reduce(vcat, fill(collect(1:maxT), n)))
    for i = 1:n
        v = V[i]
        l = 0
        a = 0
        lkeep = true
        for t = 1:maxT
            currIDX = (i - 1) * maxT + t
            l = expit(-3 + 2 * v + 0 * l + 0 * a) &gt; rand(rng) ? 1 : 0
            a = 0.1 &gt; rand(rng) ? 1 : 0
            y = expit(-3 + 2 * v + 0 * l + 2 * a) &gt; rand(rng) ? 1 : 0
            LAY[currIDX, :] .= [v, l, a, y]
            keep[currIDX] = lkeep
            lkeep = (!lkeep || (y == 1)) ? false : true
        end
    end
    id[findall(keep)], time[findall(keep)] .- 1, time[findall(keep)], LAY[findall(keep), :]
end

id, int, outt, data = dgm(MersenneTwister(), 1000, 10; regimefun = int_0)
data[:, 1] = round.(data[:, 1], digits = 3)
d, X = data[:, 4], data[:, 1:3]
wt = rand(length(d)) # random weights just to demonstrate usage

# Cox model
# Breslow&#39;s partial likelihood
m = fit(PHModel, X, int, outt, d, ties = &quot;breslow&quot;, wts = wt)

# Efron&#39;s partial likelihood
m2 = fit(PHModel, X, int, outt, d, ties = &quot;efron&quot;, wts = wt)

#equivalent way to specify 
# using `coxph` function
m2b = coxph(X, int, outt, d, ties = &quot;efron&quot;, wts = wt)

# using `coxph` function with `Tables.jl` and `StatsAPI.@formula` interface (similar to GLM.jl)
tab = ( in = int, out = out, d=d, x=X[:,1], z1=X[:,2], z2=X[:,3]) # can also be a DataFrame from DataFrames.jl
m2b = coxph(@formula(Surv(in, out, d)~x+z1+z2), ties = &quot;efron&quot;, wts = wt)

# can also be done if there is no late entry
m2b = coxph(@formula(Surv(out, d)~x+z1+z2), ties = &quot;efron&quot;, wts = wt)
# can also be done if there is no late entry and no right censoring (i.e. all times are failure times)
m2b = coxph(@formula(Surv(out)~x+z1+z2), ties = &quot;efron&quot;, wts = wt)



# Kaplan-Meier estimator of the cumulative risk/survival
res = kaplan_meier(int, outt, d)</code></pre><h3 id="Competing-event-analysis:-Aalen-Johansen-and-Cox-model-based-estimators-of-the-cumulative-risk/survival"><a class="docs-heading-anchor" href="#Competing-event-analysis:-Aalen-Johansen-and-Cox-model-based-estimators-of-the-cumulative-risk/survival">Competing event analysis: Aalen-Johansen and Cox-model-based estimators of the cumulative risk/survival</a><a id="Competing-event-analysis:-Aalen-Johansen-and-Cox-model-based-estimators-of-the-cumulative-risk/survival-1"></a><a class="docs-heading-anchor-permalink" href="#Competing-event-analysis:-Aalen-Johansen-and-Cox-model-based-estimators-of-the-cumulative-risk/survival" title="Permalink"></a></h3><pre><code class="language- hljs">using Random, LSurvival, Distributions, LinearAlgebra

# simulate some data
function dgm_comprisk(; n = 100, rng = MersenneTwister())
    z = rand(rng, n) .* 5
    x = rand(rng, n) .* 5
    dt1 = Weibull.(fill(0.75, n), inv.(exp.(-x .- z)))
    dt2 = Weibull.(fill(0.75, n), inv.(exp.(-x .- z)))
    t01 = rand.(rng, dt1)
    t02 = rand.(rng, dt2)
    t0 = min.(t01, t02)
    t = Array{Float64,1}(undef, n)
    for i = 1:n
        t[i] = t0[i] &gt; 1.0 ? 1.0 : t0[i]
    end
    d = (t .== t0)
    event = (t .== t01) .+ 2.0 .* (t .== t02)
    wtu = rand(rng, n) .* 5.0
    wt = wtu ./ mean(wtu)
    reshape(round.(z, digits = 4), (n, 1)),
    reshape(round.(x, digits = 4), (n, 1)),
    round.(t, digits = 4),
    d,
    event,
    round.(wt, digits = 4)
end

z, x, t, d, event, wt = dgm_comprisk(; n = 100, rng = MersenneTwister(12))
X = hcat(x,z)
enter = t .* rand(length(d))*0.02 # create some fake entry times

# Aalen-Johansen estimator: marginal cause-specific risks
res_aj = aalen_johansen(enter, t, event; wts = wt);
res_aj

# Cox-model estimator: cause-specific risks at given levels of covariates
fit1 = fit(PHModel, X, enter, t, (event .== 1), ties = &quot;efron&quot;,  wts = wt)
#n2idx = findall(event .!= 1)
n2idx = findall(event .&gt; -1)
fit2 = fit(PHModel, X[n2idx,:], enter[n2idx], t[n2idx], (event[n2idx] .== 2), ties = &quot;breslow&quot;,  wts = wt[n2idx])

# risk at referent levels of `x` and `z` (can be very extreme if referent levels are unlikely/unobservable)
res_cph_ref = risk_from_coxphmodels([fit1,fit2])

# risk at average levels of `x` and `z`
mnx = sum(x)/length(x)
mnz = sum(z)/length(z)
res_cph = risk_from_coxphmodels([fit1,fit2], coef_vectors=[coef(ft1), coef(ft2)], pred_profile=mean(X, dims=1))
# compare to Aalen-Johansen fit
res_aj


# this approach operates on left censored outcomes (which operate in the background in model fitting)
LSurvivalResp(enter, t, d, origintime=0)
LSurvivalCompResp(enter, t, event) # automatically infers origin


# can use the ID type to refer to units with multiple observations
id, int, outt, data = dgm(MersenneTwister(), 1000, 10; regimefun = int_0)
LSurvivalResp(int, outt, data[:,4], ID.(id))</code></pre><h2 id="Index-of-functions"><a class="docs-heading-anchor" href="#Index-of-functions">Index of functions</a><a id="Index-of-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Index-of-functions" title="Permalink"></a></h2><ul><li><a href="#LSurvival.AbstractLSurvivalParms"><code>LSurvival.AbstractLSurvivalParms</code></a></li><li><a href="#LSurvival.AbstractLSurvivalResp"><code>LSurvival.AbstractLSurvivalResp</code></a></li><li><a href="#LSurvival.AbstractNPSurv"><code>LSurvival.AbstractNPSurv</code></a></li><li><a href="#LSurvival.AbstractPH"><code>LSurvival.AbstractPH</code></a></li><li><a href="#LSurvival.ID"><code>LSurvival.ID</code></a></li><li><a href="#LSurvival.LSurvivalCompResp"><code>LSurvival.LSurvivalCompResp</code></a></li><li><a href="#LSurvival.LSurvivalResp"><code>LSurvival.LSurvivalResp</code></a></li><li><a href="#LSurvival.PHModel"><code>LSurvival.PHModel</code></a></li><li><a href="#LSurvival.PHSurv"><code>LSurvival.PHSurv</code></a></li><li><a href="#LSurvival.Strata"><code>LSurvival.Strata</code></a></li><li><a href="#LSurvival._update_PHParms!-Union{Tuple{T}, Tuple{I}, Tuple{M}, Tuple{M, I, Array{Vector{T}, 1}, Array{Vector{T}, 1}}} where {M&lt;:AbstractPH, I&lt;:Int64, T&lt;:Int64}"><code>LSurvival._update_PHParms!</code></a></li><li><a href="#LSurvival.aalen_johansen-Tuple{Any, Any, Any}"><code>LSurvival.aalen_johansen</code></a></li><li><a href="#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T&lt;:LSurvivalCompResp"><code>LSurvival.bootstrap</code></a></li><li><a href="#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M&lt;:AJSurv"><code>LSurvival.bootstrap</code></a></li><li><a href="#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M&lt;:KMSurv"><code>LSurvival.bootstrap</code></a></li><li><a href="#LSurvival.bootstrap-Tuple{MersenneTwister, PHModel}"><code>LSurvival.bootstrap</code></a></li><li><a href="#LSurvival.bootstrap-Tuple{MersenneTwister, PHModel, Int64}"><code>LSurvival.bootstrap</code></a></li><li><a href="#LSurvival.bootstrap-Tuple{Vector{Int64}, PHParms}"><code>LSurvival.bootstrap</code></a></li><li><a href="#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T&lt;:LSurvivalResp"><code>LSurvival.bootstrap</code></a></li><li><a href="#LSurvival.coxph-Tuple{Any, Any, Any, Any, Vararg{Any}}"><code>LSurvival.coxph</code></a></li><li><a href="#LSurvival.dgm-Tuple{MersenneTwister, Int64, Int64}"><code>LSurvival.dgm</code></a></li><li><a href="#LSurvival.dgm_comprisk-Tuple{MersenneTwister, Int64}"><code>LSurvival.dgm_comprisk</code></a></li><li><a href="#LSurvival.jackknife-Tuple{M} where M&lt;:PHModel"><code>LSurvival.jackknife</code></a></li><li><a href="#LSurvival.jackknife-Tuple{M} where M&lt;:KMSurv"><code>LSurvival.jackknife</code></a></li><li><a href="#LSurvival.jackknife-Tuple{M} where M&lt;:AJSurv"><code>LSurvival.jackknife</code></a></li><li><a href="#LSurvival.kaplan_meier-Tuple{Any, Any, Any}"><code>LSurvival.kaplan_meier</code></a></li><li><a href="#LSurvival.lgh_breslow!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M&lt;:AbstractPH"><code>LSurvival.lgh_breslow!</code></a></li><li><a href="#LSurvival.lgh_efron!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M&lt;:AbstractPH"><code>LSurvival.lgh_efron!</code></a></li><li><a href="#LSurvival.risk_from_coxphmodels-Union{Tuple{T}, Tuple{Vector{T}, Vararg{Any}}} where T&lt;:PHModel"><code>LSurvival.risk_from_coxphmodels</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.CoxDX}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, PHSurv}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, AJSurv}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, KMSurv}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.BaseHazPlot}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvivalResp}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.CoxInfluence}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#StatsAPI.confint-Tuple{M} where M&lt;:AbstractPH"><code>StatsAPI.confint</code></a></li><li><a href="#StatsAPI.confint-Tuple{KMSurv}"><code>StatsAPI.confint</code></a></li><li><a href="#StatsAPI.confint-Tuple{AJSurv}"><code>StatsAPI.confint</code></a></li><li><a href="#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:KMSurv, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}"><code>StatsAPI.fit</code></a></li><li><a href="#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:AJSurv, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}"><code>StatsAPI.fit</code></a></li><li><a href="#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Matrix{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:AbstractPH, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}"><code>StatsAPI.fit</code></a></li><li><a href="#StatsAPI.fit-Union{Tuple{T}, Tuple{M}, Tuple{Type{M}, Vector{T}}} where {M&lt;:PHSurv, T&lt;:PHModel}"><code>StatsAPI.fit</code></a></li><li><a href="#StatsAPI.fit!-Tuple{T} where T&lt;:AbstractNPSurv"><code>StatsAPI.fit!</code></a></li><li><a href="#StatsAPI.loglikelihood-Tuple{M} where M&lt;:AbstractPH"><code>StatsAPI.loglikelihood</code></a></li><li><a href="#StatsAPI.nullloglikelihood-Tuple{M} where M&lt;:AbstractPH"><code>StatsAPI.nullloglikelihood</code></a></li><li><a href="#StatsAPI.residuals-Tuple{M} where M&lt;:PHModel"><code>StatsAPI.residuals</code></a></li><li><a href="#StatsAPI.stderror-Tuple{KMSurv}"><code>StatsAPI.stderror</code></a></li><li><a href="#StatsAPI.stderror-Tuple{AJSurv}"><code>StatsAPI.stderror</code></a></li><li><a href="#StatsAPI.vcov-Tuple{M} where M&lt;:AbstractPH"><code>StatsAPI.vcov</code></a></li></ul><h2 id="Function-help"><a class="docs-heading-anchor" href="#Function-help">Function help</a><a id="Function-help-1"></a><a class="docs-heading-anchor-permalink" href="#Function-help" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LSurvival.AbstractLSurvivalParms" href="#LSurvival.AbstractLSurvivalParms"><code>LSurvival.AbstractLSurvivalParms</code></a> — <span class="docstring-category">Type</span></header><section><div><p>AbstractLsurvParms</p><p>Abstract type representing a model predictors and coefficient parameters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/LSurvival.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.AbstractLSurvivalResp" href="#LSurvival.AbstractLSurvivalResp"><code>LSurvival.AbstractLSurvivalResp</code></a> — <span class="docstring-category">Type</span></header><section><div><p>AbstractLsurvResp</p><p>Abstract type representing a model response vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/LSurvival.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.AbstractNPSurv" href="#LSurvival.AbstractNPSurv"><code>LSurvival.AbstractNPSurv</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for non-parametric survival models, including Kaplan-Meier, Aalen Johansen, and Cox-model based estimates of survival using an Aalen-Johansen-like estimator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/LSurvival.jl#L133-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.AbstractPH" href="#LSurvival.AbstractPH"><code>LSurvival.AbstractPH</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for proportional hazards models</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/LSurvival.jl#L128-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.ID" href="#LSurvival.ID"><code>LSurvival.ID</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type for identifying individuals in survival outcomes.</p><p>Used for the id argument in </p><ul><li>Outcome types: LSurvivalResp, LSurvivalCompResp </li><li>Model types: PHModel, KMRisk, AJRisk</li></ul><p>Accepts any Number or String. There is no significance to having this particular struct, but it enables easier use of multiple dispatch.</p><pre><code class="language- hljs">[ID(i) for i in 1:10]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/shared_structs.jl#L8-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.LSurvivalCompResp" href="#LSurvival.LSurvivalCompResp"><code>LSurvival.LSurvivalCompResp</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Outcome type for competing risk survival outcomes subject to left truncation and right censoring (not generally needed for users)</p><p>Parameters</p><ul><li><p><code>enter</code> Time at observation start</p></li><li><p><code>exit</code> Time at observation end</p></li><li><p><code>y</code> event occurrence in observation</p></li><li><p><code>wts</code> observation weights</p></li><li><p><code>eventtimes</code> unique event times</p></li><li><p><code>origin</code> origin on the time scale</p></li><li><p><code>id</code> person level identifier (must be wrapped in ID() function)</p></li><li><p><code>eventtypes</code> vector of unique event types</p></li><li><p><code>eventmatrix</code> matrix of indicators on the observation level</p><h2>Signatures:</h2></li></ul><p><code>julia  struct LSurvivalCompResp{  E&lt;:AbstractVector,  X&lt;:AbstractVector,  Y&lt;:AbstractVector,  W&lt;:AbstractVector,  T&lt;:Real,  I&lt;:AbstractLSurvivalID,  V&lt;:AbstractVector,  M&lt;:AbstractMatrix,  } &lt;: AbstractLSurvivalResp  enter::E  exit::X  y::Y  wts::W  eventtimes::X  origin::T  id::Vector{I}  eventtypes::V  eventmatrix::M  end</code></p><p><code>julia  LSurvivalCompResp(  enter::E,  exit::X,  y::Y,  wts::W,  id::Vector{I}  )</code></p><p><code>julia  LSurvivalCompResp(  enter::E,  exit::X,  y::Y,  id::Vector{I}  )</code></p><p><code>julia  LSurvivalCompResp(  enter::E,  exit::X,  y::Y,  wts::W,  )</code></p><p><code>julia  LSurvivalCompResp(  enter::E,  exit::X,  y::Y,  )</code></p><p><code>julia  LSurvivalCompResp(   exit::X,   y::Y,   ) where {X&lt;:Vector,Y&lt;:Union{Vector{&lt;:Real},BitVector}}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/shared_structs.jl#L193-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.LSurvivalResp" href="#LSurvival.LSurvivalResp"><code>LSurvival.LSurvivalResp</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Outcome type for survival outcome subject to left truncation and right censoring. </p><p>Will not generally be needed by users</p><p>Parameters</p><ul><li><code>enter</code>: Time at observation start</li><li><code>exit</code>: Time at observation end</li><li><code>y</code>: event occurrence in observation</li><li><code>wts</code>: observation weights</li><li><code>eventtimes</code>: unique event times</li><li><code>origin</code>: origin on the time scale</li><li><code>id</code>: person level identifier (must be wrapped in ID() function)</li></ul><p>```julia  struct LSurvivalResp{  E&lt;:AbstractVector,  X&lt;:AbstractVector,  Y&lt;:AbstractVector,  W&lt;:AbstractVector,  T&lt;:Real,  I&lt;:AbstractLSurvivalID,  } &lt;: AbstractLSurvivalResp  enter::E  exit::X  y::Y  wts::W  eventtimes::E  origin::T  id::Vector{I}  end</p><p>```</p><p><code>julia  LSurvivalResp(     enter::E,     exit::X,     y::Y,     wts::W,     id::Vector{I},   ) where {     E&lt;:Vector,     X&lt;:Vector,     Y&lt;:Union{Vector{&lt;:Real},BitVector},     W&lt;:Vector,     I&lt;:AbstractLSurvivalID, }</code></p><p>```julia  LSurvivalResp(  enter::E,  exit::X,  y::Y,  id::Vector{I},  ) </p><p>```</p><p><code>julia  LSurvivalResp(   y::Vector{Y},   wts::W,   id::Vector{I},   ) where {Y&lt;:AbstractSurvTime,W&lt;:Vector,I&lt;:AbstractLSurvivalID}</code></p><p><code>julia  LSurvivalResp(   enter::E,   exit::X,   y::Y,   ) where {E&lt;:Vector,X&lt;:Vector,Y&lt;:Union{Vector{&lt;:Real},BitVector}}</code></p><p><code>julia  LSurvivalResp(exit::X, y::Y) where {X&lt;:Vector,Y&lt;:Vector}</code></p><p><strong>Examples</strong></p><p>```julia</p><p><strong>no late entry</strong></p><p>LSurvivalResp([.5, .6], [1,0])</p><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/shared_structs.jl#L62-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.PHModel" href="#LSurvival.PHModel"><code>LSurvival.PHModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>PHModel: Mutable object type for proportional hazards regression (not generally needed for users)</p><p>Parameters</p><ul><li><p><code>R</code> Survival response</p></li><li><p><code>P</code>        # parameters</p></li><li><p><code>ties</code> String: &quot;efron&quot; or &quot;breslow&quot;</p></li><li><p><code>fit</code> Bool: logical for whether the model has been fitted</p></li><li><p><code>bh</code> AbstractMatrix: baseline hazard estimates</p><h2>Signatures</h2></li></ul><p>```julia  mutable struct PHModel{G&lt;:LSurvivalResp,L&lt;:AbstractLSurvivalParms} &lt;: AbstractPH  R::G        # Survival response  P::L        # parameters  ties::String #&quot;efron&quot; or&quot;breslow&quot;  fit::Bool  bh::AbstractMatrix  end</p><p>PHModel(  R::G,  P::L,  ties::String,  fit::Bool,  ) where {G&lt;:LSurvivalResp,L&lt;:AbstractLSurvivalParms}  PHModel(R::G, P::L, ties::String) where {G&lt;:LSurvivalResp,L&lt;:AbstractLSurvivalParms}  PHModel(R::G, P::L) where {G&lt;:LSurvivalResp,L&lt;:AbstractLSurvivalParms}  ```  Methods: fit, coef, confint, std_err, show</p><p><strong>Example</strong></p><p>```@example  using LSurvival  using Random  import LSurvival: <em>stepcox!, dgm</em>comprisk</p><p>z,x,t,d, event,wt = dgm<em>comprisk(MersenneTwister(1212), 100);  enter = zeros(length(t));  X = hcat(x,z);  R = LSurvivalResp(enter, t, Int.(d), wt)  P = PHParms(X)  mf = PHModel(R,P)   LSurvival.</em>fit!(mf)  ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/coxmodel.jl#L58-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.PHSurv" href="#LSurvival.PHSurv"><code>LSurvival.PHSurv</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Mutable type for proportional hazards models (not generally needed by users)</p><p>PHSsurv: Object type for proportional hazards regression</p><p>surv::Vector{Float64} risk::Matrix{Float64} basehaz::Vector{Float64} event::Vector{Float64}</p><ul><li><code>fitlist</code>: vector of PHSurv objects (Cox model fits)</li><li><code>eventtypes</code>: vector of unique event types</li><li><code>times</code>: unique event times</li><li><code>surv</code>: Overall survival at each time</li><li><code>risk</code>: Cause-specific risk  at each time (1 for each outcome type)</li><li><code>basehaz</code>: baseline hazard for a specific event type</li><li><code>event</code>: value of event type that occurred at each time</li></ul><p>Methods: fit, show</p><pre><code class="language-julia hljs">mutable struct PHSurv{G&lt;:Array{T} where {T&lt;:PHModel}} &lt;: AbstractNPSurv
fitlist::G        
eventtypes::AbstractVector
times::AbstractVector
surv::Vector{Float64}
risk::Matrix{Float64}
basehaz::Vector{Float64}
event::Vector{Float64}
end

PHSurv(fitlist::Array{T}, eventtypes) where {T&lt;:PHModel}
PHSurv(fitlist::Array{T}) where {T&lt;:PHModel}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/coxmodel.jl#L126-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.Strata" href="#LSurvival.Strata"><code>LSurvival.Strata</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type for identifying individuals in survival outcomes. Used for the strata argument in PHModel (not yet implemented)</p><p>Accepts any Number or String. There is no significance to having this particular struct, but it enables easier use of multiple dispatch.</p><pre><code class="language-julia hljs">[Strata(i) for i in 1:10]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/shared_structs.jl#L15-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival._update_PHParms!-Union{Tuple{T}, Tuple{I}, Tuple{M}, Tuple{M, I, Array{Vector{T}, 1}, Array{Vector{T}, 1}}} where {M&lt;:AbstractPH, I&lt;:Int64, T&lt;:Int64}" href="#LSurvival._update_PHParms!-Union{Tuple{T}, Tuple{I}, Tuple{M}, Tuple{M, I, Array{Vector{T}, 1}, Array{Vector{T}, 1}}} where {M&lt;:AbstractPH, I&lt;:Int64, T&lt;:Int64}"><code>LSurvival._update_PHParms!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).</p><p>Uses Breslow&#39;s or Efron&#39;s partial likelihood.</p><p>Updates over all observations</p><p><strong>Signature</strong></p><pre><code class="language-julia hljs">_update_PHParms!(
 m::M,
 # big indexes
 ne::I,
 caseidxs::Vector{Vector{T}},
 risksetidxs::Vector{Vector{T}},
 ) where {M&lt;:AbstractPH,I&lt;:Int,T&lt;:Int}</code></pre><p><em>update</em>PHParms!(m, risksetidxs, caseidxs, ne, den)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/coxmodel.jl#L693-L713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.aalen_johansen-Tuple{Any, Any, Any}" href="#LSurvival.aalen_johansen-Tuple{Any, Any, Any}"><code>LSurvival.aalen_johansen</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Aalen-Johansen estimator for cumulative cause-specific risk (in the presence of competing events)</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs"> StatsBase.fit!(m::T; kwargs...) where {T&lt;:AbstractNPSurv}

 aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,
   ; kwargs...)
</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>wts::Vector{&lt;:Real} = similar(enter, 0)</code>; vector of case weights (or zero length vector) for each observation</li><li><code>id::Vector{&lt;:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]</code>; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)</li><li><code>atol = 0.00000001</code>; absolute tolerance for defining tied event times</li><li><code>keepy = true</code>; keep the outcome vector after fitting (may save memory with large datasets)</li><li><code>eps = 0.00000001</code>; deprecated (replaced by atol)</li></ul><pre><code class="language- hljs">using LSurvival
using Random
z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
enter = zeros(length(t));
   # event variable is coded 0[referent],1,2
m = fit(AJSurv, enter, t, event)
mw = fit(AJSurv, enter, t, event, wts=wt)</code></pre><p>or, equivalently:</p><pre><code class="language-julia hljs">aalen_johansen(enter, t, event, wts=wt)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/npsurvival.jl#L176-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.bootstrap-Tuple{MersenneTwister, PHModel, Int64}" href="#LSurvival.bootstrap-Tuple{MersenneTwister, PHModel, Int64}"><code>LSurvival.bootstrap</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bootstrapping coefficients of a proportional hazards model</p><p><strong>Signatures</strong></p><pre><code class="nohighlight hljs"># single bootstrap draw, keeping the entire object
bootstrap(rng::MersenneTwister, m::PHModel)
bootstrap(m::PHModel)
# muliple bootstrap draws, keeping only coefficient estimates
bootstrap(rng::MersenneTwister, m::PHModel, iter::Int; kwargs...)
bootstrap(m::PHModel, iter::Int; kwargs...)</code></pre><p>Returns:</p><ul><li>If using <code>bootstrap(m)</code>: a single bootstrap draw</li><li>If using <code>bootstrap(m, 10)</code> (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up</li></ul><pre><code class="language-julia hljs">using LSurvival, Random

id, int, outt, data =
LSurvival.dgm(MersenneTwister(1212), 500, 5; afun = LSurvival.int_0)

d, X = data[:, 4], data[:, 1:3]
weights = rand(length(d))

# survival outcome:
R = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only
P = PHParms(X)

Mod = PHModel(R, P)
LSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)


# careful propogation of bootstrap sampling
idx, R2 = bootstrap(R)
P2 = bootstrap(idx, P)
Modb = PHModel(R2, P2)
LSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)

# convenience function for bootstrapping a model
Modc = bootstrap(Mod)
LSurvival._fit!(Modc, start=Modc.P._B);
Modc
Modc.P.X == nothing
Modc.R == nothing
</code></pre><p>Bootstrap Cox model coefficients</p><pre><code class="nohighlight hljs">LSurvival._fit!(mb, keepx=true, keepy=true, start=[0.0, 0.0])</code></pre><pre><code class="language- hljs">using LSurvival, Random
res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 200)
int = zeros(length(d)) # no late entry
X = hcat(z, x)

mainfit = fit(PHModel, X, int, outt, d .* (event .== 1), keepx=true, keepy=true)

function stddev_finite(x)
 n = length(x)
 mnx = sum(x)/n
 ret = sum((x .- mnx) .^ 2)
 ret /= n-1
 sqrt(ret)
end

# bootstrap standard error versus asymptotic
mb = bootstrap(MersenneTwister(123123), mainfit, 200)
## bootstrap standard error
[stddev_finite(mb[:,i]) for i in 1:2]
## asymptotic standard error
stderror(mainfit)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/bootstrap.jl#L54-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.bootstrap-Tuple{MersenneTwister, PHModel}" href="#LSurvival.bootstrap-Tuple{MersenneTwister, PHModel}"><code>LSurvival.bootstrap</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bootstrapping coefficients of a proportional hazards model</p><p><strong>Signatures</strong></p><pre><code class="nohighlight hljs"># single bootstrap draw, keeping the entire object
bootstrap(rng::MersenneTwister, m::PHModel)
bootstrap(m::PHModel)
# muliple bootstrap draws, keeping only coefficient estimates
bootstrap(rng::MersenneTwister, m::PHModel, iter::Int; kwargs...)
bootstrap(m::PHModel, iter::Int; kwargs...)</code></pre><p>Returns:</p><ul><li>If using <code>bootstrap(m)</code>: a single bootstrap draw</li><li>If using <code>bootstrap(m, 10)</code> (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up</li></ul><pre><code class="language-julia hljs">using LSurvival, Random

id, int, outt, data =
LSurvival.dgm(MersenneTwister(1212), 500, 5; afun = LSurvival.int_0)

d, X = data[:, 4], data[:, 1:3]
weights = rand(length(d))

# survival outcome:
R = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only
P = PHParms(X)

Mod = PHModel(R, P)
LSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)


# careful propogation of bootstrap sampling
idx, R2 = bootstrap(R)
P2 = bootstrap(idx, P)
Modb = PHModel(R2, P2)
LSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)

# convenience function for bootstrapping a model
Modc = bootstrap(Mod)
LSurvival._fit!(Modc, start=Modc.P._B);
Modc
Modc.P.X == nothing
Modc.R == nothing
</code></pre><p>Bootstrap Cox model coefficients</p><pre><code class="nohighlight hljs">LSurvival._fit!(mb, keepx=true, keepy=true, start=[0.0, 0.0])</code></pre><pre><code class="language- hljs">using LSurvival, Random
res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 200)
int = zeros(length(d)) # no late entry
X = hcat(z, x)

mainfit = fit(PHModel, X, int, outt, d .* (event .== 1), keepx=true, keepy=true)

function stddev_finite(x)
 n = length(x)
 mnx = sum(x)/n
 ret = sum((x .- mnx) .^ 2)
 ret /= n-1
 sqrt(ret)
end

# bootstrap standard error versus asymptotic
mb = bootstrap(MersenneTwister(123123), mainfit, 200)
## bootstrap standard error
[stddev_finite(mb[:,i]) for i in 1:2]
## asymptotic standard error
stderror(mainfit)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/bootstrap.jl#L42-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.bootstrap-Tuple{Vector{Int64}, PHParms}" href="#LSurvival.bootstrap-Tuple{Vector{Int64}, PHParms}"><code>LSurvival.bootstrap</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bootstrap sampling of a proportional hazards predictor object</p><pre><code class="nohighlight hljs">using LSurvival, Random

id, int, outt, data =
LSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)

d, X = data[:, 4], data[:, 1:3]
weights = rand(length(d))

# survival outcome:
R = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only
P = PHParms(X)
idx, R2 = bootstrap(R)
P2 = bootstrap(idx, P)

Mod = PHModel(R2, P2)
LSurvival._fit!(Mod, start=Mod.P._B)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/bootstrap.jl#L34-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M&lt;:AJSurv" href="#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M&lt;:AJSurv"><code>LSurvival.bootstrap</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bootstrap methods for Aalen-Johansen cumulative risk estimator</p><p><strong>Signatures</strong></p><pre><code class="nohighlight hljs"> # single bootstrap draw, keeping the entire object
 bootstrap(rng::MersenneTwister, m::AJSurv)
 bootstrap(m::AJSurv)

 # muliple bootstrap draws, keeping only coefficient estimates
 bootstrap(rng::MersenneTwister, m::AJSurv, iter::Int; kwargs...)
 bootstrap(m::AJSurv, iter::Int; kwargs...)</code></pre><p>Returns:</p><ul><li>If using <code>bootstrap(m)</code>: a single bootstrap draw</li><li>If using <code>bootstrap(m, 10)</code> (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up</li></ul><pre><code class="language- hljs">using LSurvival
using Random

z, x, t, d, event, wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 100)
id = 1:length(x)
enter = zeros(length(t))

aj1 = aalen_johansen(enter, t, event, id=ID.(id), wts=wt)
aj2 = bootstrap(aj1, keepy=false);
ajboot = bootstrap(aj1, 10, keepy=false);
aj1


aj1.R
aj2.R
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/bootstrap.jl#L103-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M&lt;:KMSurv" href="#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M&lt;:KMSurv"><code>LSurvival.bootstrap</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bootstrap methods for Kaplan-Meier survival curve estimator</p><p><strong>Signatures</strong></p><pre><code class="nohighlight hljs"> # single bootstrap draw, keeping the entire object
 bootstrap(rng::MersenneTwister, m::KMSurv)
 bootstrap(m::KMSurv)

 # muliple bootstrap draws, keeping only coefficient estimates
 bootstrap(rng::MersenneTwister, m::KMSurv, iter::Int; kwargs...)
 bootstrap(m::KMSurv, iter::Int; kwargs...)</code></pre><p>Returns:</p><ul><li>If using <code>bootstrap(m)</code>: a single bootstrap draw</li><li>If using <code>bootstrap(m, 10)</code> (e.g.): 10 bootstrap draws of the survival probability at the end of follow up</li></ul><pre><code class="language- hljs">using LSurvival
using Random

id, int, outt, data =
LSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)

d, X = data[:, 4], data[:, 1:3]
wts = rand(length(d))

km1 = kaplan_meier(int, outt, d, id=ID.(id), wts=wts)
km2 = bootstrap(km1, keepy=false)
km3 = bootstrap(km1, 10, keepy=false)
km1

km1.R
km2.R
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/bootstrap.jl#L76-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T&lt;:LSurvivalCompResp" href="#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T&lt;:LSurvivalCompResp"><code>LSurvival.bootstrap</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bootstrapping sampling of a competing risk survival response</p><p><strong>Signatures</strong></p><pre><code class="nohighlight hljs">bootstrap(rng::MersenneTwister, R::T) where {T&lt;:LSurvivalCompResp}
bootstrap(R::T) where {T&lt;:LSurvivalCompResp}</code></pre><pre><code class="nohighlight hljs">z,x,t,d,event,weights =
LSurvival.dgm_comprisk(MersenneTwister(1212), 300)
enter = zeros(length(event))

# survival outcome:
R = LSurvivalCompResp(enter, t, event, weights, ID.(collect(1:length(t))))    # specification with ID only
bootstrap(R) # note that entire observations/clusters identified by id are kept</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/bootstrap.jl#L18-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T&lt;:LSurvivalResp" href="#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T&lt;:LSurvivalResp"><code>LSurvival.bootstrap</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bootstrapping sampling of a survival response</p><pre><code class="nohighlight hljs">id, int, outt, data =
LSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)

d, X = data[:, 4], data[:, 1:3]
weights = rand(length(d))

# survival outcome:
R = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/bootstrap.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.coxph-Tuple{Any, Any, Any, Any, Vararg{Any}}" href="#LSurvival.coxph-Tuple{Any, Any, Any, Any, Vararg{Any}}"><code>LSurvival.coxph</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Fit method for AbstractPH objects (Cox models)</p><p>Keyword arguments (used here, and passed on to internal structs)</p><ul><li><p><code>ties</code> &quot;breslow&quot; or &quot;efron&quot; (default)</p></li><li><p><code>wts</code> observation weights</p></li><li><p><code>ties</code> &quot;breslow&quot; or &quot;efron&quot; (default)</p></li><li><p><code>offset</code> not currently used at all</p></li><li><p><code>fitargs</code> arguments passed to other structs, which include</p><ul><li><code>id</code> cluster or individual level ID (defaults to a unique value for each row of data) see note below on ID</li><li><code>contrasts</code> StatsModel style contrasts (dicts) that can be used for variable transformations/indicator variable creation (e.g. https://juliastats.org/StatsModels.jl/stable/contrasts/)</li></ul><h2>Signatures</h2><pre><code class="language-julia hljs">fit(::Type{M},
X::AbstractMatrix,#{&lt;:FP},
enter::AbstractVector{&lt;:Real},
exit::AbstractVector{&lt;:Real},
y::Union{AbstractVector{&lt;:Real},BitVector}
;
ties =&quot;breslow&quot;,
wts::AbstractVector{&lt;:Real}      = similar(y, 0),
offset::AbstractVector{&lt;:Real}   = similar(y, 0),
fitargs...) where {M&lt;:AbstractPH}</code></pre><p>```</p></li></ul><p>coxph(f::FormulaTerm, data; kwargs...)   ```</p><p><code>coxph(X, enter, exit, y, args...; kwargs...)</code></p><p><code>julia    using LSurvival, Random    z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);    enter = zeros(length(t));    X = hcat(x,rand(length(x)));     m = fit(PHModel, X, enter, t, d, ties=&quot;efron&quot;)    m2 = fit(PHModel, X, enter, t, d, ties=&quot;breslow&quot;)    coeftable(m)</code></p><p><strong>Note on use of <code>id</code> keyword</strong></p><p><code>id</code> is not needed in person-period structure data for standard estimates or confidence intervals</p><p>```@example   using Random, LSurvival      id, int, outt, dat =          LSurvival.dgm(MersenneTwister(123123), 100, 100; afun = LSurvival.int_0)      data = (              int = int,              outt = outt,              d = dat[:,4] .== 1,              x = dat[:,1],              z = dat[:,2]      )</p><pre><code class="nohighlight hljs"> f = @formula(Surv(int, outt,d)~x+z)
 coxph(f, data)</code></pre><p>```</p><p><strong>BUT, you must specify <code>id</code> to get appropriate robust variance and some other statistics.</strong></p><p>Here is an example where the same data are presented in two different ways, which should yield identical statistics when used in Cox model.   ```@example  dat1 = (     time = [1,1,6,6,8,9],     status = [1,0,1,1,0,1],     x = [1,1,1,0,0,0]   )   ft = coxph(@formula(Surv(time,status)~x),dat1)   bic(ft)   nobs(ft)   dof_residual(ft)</p><p><strong>lrtest is another one</strong></p><p>stderror(ft)                     # model based   stderror(ft, type=&quot;robust&quot;)   # robust standard error, based on dfbeta residuals   ft</p><p><strong>now using &quot;clustered&quot; data with multiple observations per individual</strong></p><p>dat1clust= (      id = [1,2,3,3,4,4,5,5,6,6],      enter = [0,0,0,1,0,1,0,1,0,1],      exit = [1,1,1,6,1,6,1,8,1,9],      status = [1,0,0,1,0,1,0,0,0,1],      x = [1,1,1,1,0,0,0,0,0,0]  )</p><p><strong>use the <code>id</code> parameter with the ID struct</strong></p><p>ft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id))  bic(ft2)                       # CORRECT          nobs(ft2)                      # CORRECT  dof_residual(ft2)              # CORRECT</p><p>stderror(ft2)                  # model based (CORRECT)  stderror(ft2, type=&quot;robust&quot;)   # robust standard error, based on <code>id</code> level dfbeta residuals (CORRECT)</p><p><strong>once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics</strong></p><p>ft2   # CORRECT (compare to <code>ft</code> object)   ```</p><p><strong>NOTE THE FOLLOWING IS INCORRECT because the <code>id</code> keyword is omitted</strong></p><p>```@example  ft2w = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust)  bic(ft2w)                          # INCORRECT   nobs(ft2w)                         # INCORRECT  dof_residual(ft2w)                 # INCORRECT</p><p>stderror(ft2w)                     # model based (CORRECT)  stderror(ft2w, type=&quot;robust&quot;)      # robust variance (INCORRECT)</p><p>ft2w # the coefficient table now shows incorrect confidence intervals and test statistics</p><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/coxmodel.jl#L356-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.dgm-Tuple{MersenneTwister, Int64, Int64}" href="#LSurvival.dgm-Tuple{MersenneTwister, Int64, Int64}"><code>LSurvival.dgm</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generating discrete survival data without competing risks</p><p><strong>Signatures</strong></p><pre><code class="nohighlight hljs">dgm(rng::MersenneTwister, n::Int, maxT:Int; afun = int_0, yfun = yprob, lfun = lprob)

dgm(n::Int, maxT::Int; kwargs...)</code></pre><p>Usage: dgm(rng, n, maxT;afun=int<em>0, yfun=yprob, lfun=lprob) dgm(n, maxT;afun=int</em>0, yfun=yprob, lfun=lprob)</p><p>Where afun, yfun, and lfun are all functions that take arguments v,l,a and output time-specific values of a, y, and l respectively Example:</p><pre><code class="language-julia hljs">
expit(mu) =  inv(1.0+exp(-mu))

function aprob(v,l,a)
expit(-1.0 + 3*v + 2*l)
end
  
function lprob(v,l,a)
expit(-3 + 2*v + 0*l + 0*a)
end
  
function yprob(v,l,a)
expit(-3 + 2*v + 0*l + 2*a)
end
  # 10 individuals followed for up to 5 times
LSurvival.dgm(10, 5;afun=aprob, yfun=yprob, lfun=lprob)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/data_generators.jl#L20-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.dgm_comprisk-Tuple{MersenneTwister, Int64}" href="#LSurvival.dgm_comprisk-Tuple{MersenneTwister, Int64}"><code>LSurvival.dgm_comprisk</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generating continuous survival data with competing risks</p><p><strong>Signatures</strong></p><pre><code class="nohighlight hljs">dgm_comprisk(rng::MersenneTwister, n::Int)

dgm_comprisk(n::Int)</code></pre><pre><code class="nohighlight hljs">    - rng = random number generator    
    - n = sample size</code></pre><p>Example:</p><pre><code class="language-julia hljs">using LSurvival
# 100 individuals with two competing events
z,x,t,d,event,weights = LSurvival.dgm_comprisk(100)
    
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/data_generators.jl#L49-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.jackknife-Tuple{M} where M&lt;:AJSurv" href="#LSurvival.jackknife-Tuple{M} where M&lt;:AJSurv"><code>LSurvival.jackknife</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Obtain jackknife (leave-one-out) estimates from a Aalen-Johansen risk curve (risk at end of follow-up) by refitting the model n times</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs">jackknife(m::M;kwargs...) where {M&lt;:AJSurv}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/jackknife.jl#L183-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.jackknife-Tuple{M} where M&lt;:KMSurv" href="#LSurvival.jackknife-Tuple{M} where M&lt;:KMSurv"><code>LSurvival.jackknife</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Obtain jackknife (leave-one-out) estimates from a Kaplan-Meier survival curve (survival at end of follow-up) by refitting the model n times</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs">jackknife(m::M;kwargs...) where {M&lt;:KMSurv}</code></pre><pre><code class="language- hljs">using LSurvival, Random, StatsBase

dat1 = (time = [1, 1, 6, 6, 8, 9], status = [1, 0, 1, 1, 0, 1], x = [1, 1, 1, 0, 0, 0])

dat1clust = (
  id = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6],
  enter = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1],
  exit = [1, 1, 1, 6, 1, 6, 1, 8, 1, 9],
  status = [1, 0, 0, 1, 0, 1, 0, 0, 0, 1],
  x = [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
)

m = kaplan_meier(dat1.time, dat1.status)
a = aalen_johansen(dat1.time, dat1.status)
mc = kaplan_meier(dat1clust.enter, dat1clust.exit, dat1clust.status, id=ID.(dat1clust.id))
ac = aalen_johansen(dat1clust.enter, dat1clust.exit, dat1clust.status, id=ID.(dat1clust.id))
jk = jackknife(m);
jkc = jackknife(mc);
jka = jackknife(a);
bs = bootstrap(mc, 100);
std(bs[:,1])
stderror(m, type=&quot;jackknife&quot;)
stderror(mc, type=&quot;jackknife&quot;)
@assert jk == jkc</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/jackknife.jl#L131-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.jackknife-Tuple{M} where M&lt;:PHModel" href="#LSurvival.jackknife-Tuple{M} where M&lt;:PHModel"><code>LSurvival.jackknife</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Obtain jackknife (leave-one-out) estimates from a Cox model by refitting the model n times</p><pre><code class="language- hljs">using LSurvival, Random, StatsBase
id, int, outt, data =
LSurvival.dgm(MersenneTwister(112), 100, 10; afun = LSurvival.int_0)
data[:, 1] = round.(data[:, 1], digits = 3)
d, X = data[:, 4], data[:, 1:3]
wt = rand(length(d))
wt ./= (sum(wt) / length(wt))
m = coxph(X,int, outt,d, wts=wt, id=ID.(id))

jk = jackknife(m);
bs = bootstrap(MersenneTwister(12321), m, 1000);
N = nobs(m)
#comparing estimate with jackknife estimate with bootstrap mean
hcat(coef(m), mean(jk, dims=1)[1,:], mean(bs, dims=1)[1,:])
semb = stderror(m)
sebs = std(bs, dims=1)
sero = stderror(m, type=&quot;robust&quot;)
sejk = stderror(m, type=&quot;jackknife&quot;)
sejk_manual = std(jk, dims=1, corrected=false) .* sqrt(N-1)

sqrt.(diag(LSurvival.jackknife_vcov(m)))

hcat(semb, sebs[1,:], sejk, sejk_manual[1,:], sero)

dat1 = (time = [1, 1, 6, 6, 8, 9], status = [1, 0, 1, 1, 0, 1], x = [1, 1, 1, 0, 0, 0])
dat1clust = (
  id = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6],
  enter = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1],
  exit = [1, 1, 1, 6, 1, 6, 1, 8, 1, 9],
  status = [1, 0, 0, 1, 0, 1, 0, 0, 0, 1],
  x = [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
)

m = coxph(@formula(Surv(time, status)~x),dat1)
mc = coxph(@formula(Surv(enter, exit, status)~x),dat1clust, id=ID.(dat1clust.id))
jk = jackknife(m);
jkc = jackknife(mc);
bs = bootstrap(mc, 100);
std(bs[:,1])
stderror(m, type=&quot;jackknife&quot;)
stderror(mc, type=&quot;jackknife&quot;)
@assert jk == jkc</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/jackknife.jl#L92-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.kaplan_meier-Tuple{Any, Any, Any}" href="#LSurvival.kaplan_meier-Tuple{Any, Any, Any}"><code>LSurvival.kaplan_meier</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Kaplan-Meier estimator for cumulative conditional risk</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs">StatsBase.fit!(m::T; kwargs...) where {T&lt;:AbstractNPSurv}

kaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,
   ; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li>wts::Vector{&lt;:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation</li><li>id::Vector{&lt;:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)</li><li>atol = 0.00000001; absolute tolerance for defining tied event times</li><li>censval = 0;  value of the outcome to be considered a censored event</li><li>keepy = true; keep the outcome vector after fitting (may save memory with large datasets)</li><li>eps = 0.00000001; deprecated (replaced by atol)</li></ul><pre><code class="language- hljs">using LSurvival
using Random
z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
enter = zeros(length(t));
m = fit(KMSurv, enter, t, d)
mw = fit(KMSurv, enter, t, d, wts=wt)</code></pre><p>or, equivalently:</p><pre><code class="language-julia hljs">kaplan_meier(enter, t, d, wts=wt)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/npsurvival.jl#L143-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.lgh_breslow!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M&lt;:AbstractPH" href="#LSurvival.lgh_breslow!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M&lt;:AbstractPH"><code>LSurvival.lgh_breslow!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).</p><p>Uses Breslow&#39;s partial likelihood.</p><p>Updates over all observations</p><p><strong>Signature</strong></p><pre><code class="language-julia hljs">lgh_breslow!(m::M, j, caseidx, risksetidx) where {M&lt;:AbstractPH}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/coxmodel.jl#L587-L600">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.lgh_efron!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M&lt;:AbstractPH" href="#LSurvival.lgh_efron!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M&lt;:AbstractPH"><code>LSurvival.lgh_efron!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).</p><p>Uses Efron&#39;s partial likelihood.</p><p>Updates over all observations</p><p><strong>Signature</strong></p><pre><code class="language-julia hljs">lgh_efron!(m::M, j, caseidx, risksetidx) where {M&lt;:AbstractPH}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/coxmodel.jl#L628-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LSurvival.risk_from_coxphmodels-Union{Tuple{T}, Tuple{Vector{T}, Vararg{Any}}} where T&lt;:PHModel" href="#LSurvival.risk_from_coxphmodels-Union{Tuple{T}, Tuple{Vector{T}, Vararg{Any}}} where T&lt;:PHModel"><code>LSurvival.risk_from_coxphmodels</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Survival curve estimation using multiple cox models</p><p><strong>Signatures</strong></p><p>```julia   risk<em>from</em>coxphmodels(fitlist::Vector{T}, args...; kwargs...) where {T&lt;:PHModel}</p><p>fit(::Type{M}, fitlist::Vector{T}, ; fitargs...) where {M&lt;:PHSurv,T&lt;:PHModel}  ```</p><p><strong>Optional keywords</strong></p><ul><li><code>coef_vectors</code> = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]</li><li><code>pred_profile</code> = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]</li></ul><p>```@example  using LSurvival  using Random</p><p><strong>event variable is coded 0[referent],1,2</strong></p><p>z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);  enter = zeros(length(t));</p><p>ft1 = coxph(hcat(x,z), enter, t, (event .== 1))  nidx = findall(event .!= 1)  ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))</p><p><strong>risk at referent levels of <code>x</code> and <code>z</code></strong></p><p>risk<em>from</em>coxphmodels([ft1,ft2])</p><p><strong>risk at average levels of <code>x</code> and <code>z</code></strong></p><p>mnx = sum(x)/length(x)  mnz = sum(z)/length(z)</p><p><strong>equivalent</strong></p><p>fit(PHSurv, [ft1,ft2], pred<em>profile=[mnx,mnz])  risk</em>from<em>coxphmodels([ft1,ft2], pred</em>profile=[mnx,mnz])  ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/coxmodel.jl#L813-L850">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, AJSurv}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, AJSurv}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Recipe for aalen-johansen risk curve</p><pre><code class="language-julia hljs">    using Plots, LSurvival
    res = z, x, outt, d, event, weights = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)
    int = zeros(length(d)) # no late entry
    
        c = fit(AJSurv, int, outt, event)
        #risk2 = aalen_johansen(int, outt, event)
        plot(c)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/plot_recipes.jl#L90-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, KMSurv}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, KMSurv}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Recipe for kaplan meier curve</p><pre><code class="language-julia hljs">    using Plots, LSurvival
dat4 = (
    id = [1, 1, 2, 2, 2, 3, 4, 5, 5, 6],
    enter = [1, 2, 5, 4, 6, 7, 3, 6, 8, 0],
    exit = [2, 5, 6, 7, 8, 9, 6, 8, 14, 9],
    status = [0, 1, 0, 0, 1, 0, 1, 0, 0, 1],
    x = [0.1, 0.1, 1.5, 1.5, 1.5, 0, 0, 0, 0, 3],
    z = [1, 1, 0, 0, 0, 0, 0, 1, 1, 0],
    w = [0, 0, 0, 0, 0, 1, 1, 1, 1, 0],
)
R = LSurvivalResp(dat4.enter, dat4.exit, dat4.status)
    k = kaplan_meier(dat4.enter, dat4.exit, dat4.status)
    plot(k)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/plot_recipes.jl#L50-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.BaseHazPlot}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.BaseHazPlot}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Plotting baseline hazard for a Cox model</p><pre><code class="language-julia hljs">using Plots, LSurvival
dat2 = (
    enter = [1, 2, 5, 2, 1, 7, 3, 4, 8, 8],
    exit = [2, 3, 6, 7, 8, 9, 9, 9, 14, 17],
    status = [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
    x = [1, 0, 0, 1, 0, 1, 1, 1, 0, 0],
)
fte = coxph(@formula(Surv(enter, exit, status)~x), dat2, maxiter=0)
ftb = coxph(@formula(Surv(enter, exit, status)~x), dat2, ties=&quot;breslow&quot;, maxiter=0)

plot(fte, label=&quot;Efron&quot;)
plot!(ftb, label=&quot;Breslow&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/plot_recipes.jl#L167-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.CoxDX}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.CoxDX}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">using Plots, LSurvival
dat2 = (
    enter = [1, 2, 5, 2, 1, 7, 3, 4, 8, 8],
    exit = [2, 3, 6, 7, 8, 9, 9, 9, 14, 17],
    status = [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
    x = [1, 0, 0, 1, 0, 1, 1, 1, 0, 0],
)
fte = coxph(@formula(Surv(enter, exit, status)~x), dat2)

coxdx(fte)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/plot_recipes.jl#L210-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.CoxInfluence}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.CoxInfluence}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">using Plots, LSurvival
dat2 = (
    enter = [1, 2, 5, 2, 1, 7, 3, 4, 8, 8],
    exit = [2, 3, 6, 7, 8, 9, 9, 9, 14, 17],
    status = [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
    x = [1, 0, 0, 1, 0, 1, 1, 1, 0, 0],
)
fte = coxph(@formula(Surv(enter, exit, status)~x), dat2)

coxinfluence(fte, type=&quot;jackknife&quot;, par=1)
coxinfluence!(fte, type=&quot;dfbeta&quot;, color=:red, par=1)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/plot_recipes.jl#L245-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvivalResp}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvivalResp}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><p>using Plots, LSurvival</p><pre><code class="language-julia hljs">dat4 = (
    id = [1, 1, 2, 2, 2, 3, 4, 5, 5, 6],
    enter = [1, 2, 5, 4, 6, 7, 3, 6, 8, 0],
    exit = [2, 5, 6, 7, 8, 9, 6, 8, 14, 9],
    status = [0, 1, 0, 0, 1, 0, 1, 0, 0, 1],
    x = [0.1, 0.1, 1.5, 1.5, 1.5, 0, 0, 0, 0, 3],
    z = [1, 1, 0, 0, 0, 0, 0, 1, 1, 0],
    w = [0, 0, 0, 0, 0, 1, 1, 1, 1, 0],
)
R = LSurvivalResp(dat4.enter, dat4.exit, dat4.status)
plot([[R.enter[i], R.exit[i]] for i in eachindex(R.enter)], [[i, i] for i in values(R.id)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/plot_recipes.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, PHSurv}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, PHSurv}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Recipe for cox-model based risk curves</p><pre><code class="language-julia hljs">    using Plots, LSurvival, Random, StatsBase
    res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)
    X = hcat(z, x)
    int = zeros(length(d)) # no late entry
    ft1 = fit(PHModel, X, int, outt, d .* (event .== 1), wts=wts)
    ft2 = fit(PHModel, X, int, outt, d .* (event .== 2), wts=wts)
    c = risk_from_coxphmodels([ft1, ft2], pred_profile = mean(X, dims=1))
    
    plot(c)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/plot_recipes.jl#L127-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.confint-Tuple{AJSurv}" href="#StatsAPI.confint-Tuple{AJSurv}"><code>StatsAPI.confint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Greenwood&#39;s formula for variance and confidence intervals of a Aalen-Johansen risk function</p><p><strong>Signatures:</strong></p><pre><code class="language-julia hljs">StatsBase.stderror(m::AJSurv)

StatsBase.confint(m:AJSurv; level=0.95, method=&quot;normal&quot;)</code></pre><p><strong>Keyword arguments</strong></p><ul><li>method<ul><li>&quot;normal&quot; normality-based confidence intervals</li><li>&quot;lognlog&quot; log(-log(S(t))) based confidence intervals</li></ul></li></ul><pre><code class="language- hljs">res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)
int = zeros(length(d)) # no late entry
m = fit(AJSurv, int, outt, event)
stderror(m)
confint(m, level=0.95)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/npsurvival.jl#L286-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.confint-Tuple{KMSurv}" href="#StatsAPI.confint-Tuple{KMSurv}"><code>StatsAPI.confint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Greenwood&#39;s formula for variance and confidence intervals of a Kaplan-Meier survival curve</p><p><strong>Signatures:</strong></p><pre><code class="language-julia hljs">StatsBase.stderror(m::KMSurv)

StatsBase.confint(m:KMSurv; level=0.95, method=&quot;normal&quot;)</code></pre><p><strong>Keyword arguments</strong></p><p><code>method</code>:</p><ul><li>&quot;normal&quot; normality-based confidence intervals</li><li>&quot;lognlog&quot; log(-log(S(t))) based confidence intervals</li></ul><pre><code class="language- hljs">using LSurvival
using Random
z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
enter = zeros(length(t));
m = fit(KMSurv, enter, t, d)
mw = fit(KMSurv, enter, t, d, wts=wt)
stderror(m)
confint(m, method=&quot;normal&quot;)
confint(m, method=&quot;lognlog&quot;) # log-log transformation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/npsurvival.jl#L278-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.confint-Tuple{M} where M&lt;:AbstractPH" href="#StatsAPI.confint-Tuple{M} where M&lt;:AbstractPH"><code>StatsAPI.confint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">using LSurvival
 dat1= (
   time = [1,1,6,6,8,9],
   status = [1,0,1,1,0,1],
   x = [1,1,1,0,0,0]
 )

 ft = coxph(@formula(Surv(time, status) ~ x),dat1, keepx=true)
 # model-based variance
 confint(ft)

 # robust variance
 confint(ft, type=&quot;robust&quot;)</code></pre><p><strong>for cluster confidence intervals</strong></p><p>```julia  dat1clust= (    id = [1,2,3,3,4,4,5,5,6,6],    enter = [0,0,0,1,0,1,0,1,0,1],    exit = [1,1,1,6,1,6,1,8,1,9],    status = [1,0,0,1,0,1,0,0,0,1],    x = [1,1,1,1,0,0,0,0,0,0]  )</p><p>ft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id), keepx=true)</p><p><strong>model-based variance</strong></p><p>confint(ft2)</p><p><strong>robust variance</strong></p><p>confint(ft2, type=&quot;robust&quot;) ````</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/coxmodel.jl#L411-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.fit!-Tuple{T} where T&lt;:AbstractNPSurv" href="#StatsAPI.fit!-Tuple{T} where T&lt;:AbstractNPSurv"><code>StatsAPI.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Kaplan-Meier estimator for cumulative conditional risk</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs">StatsBase.fit!(m::T; kwargs...) where {T&lt;:AbstractNPSurv}

kaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,
   ; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li>wts::Vector{&lt;:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation</li><li>id::Vector{&lt;:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)</li><li>atol = 0.00000001; absolute tolerance for defining tied event times</li><li>censval = 0;  value of the outcome to be considered a censored event</li><li>keepy = true; keep the outcome vector after fitting (may save memory with large datasets)</li><li>eps = 0.00000001; deprecated (replaced by atol)</li></ul><pre><code class="language- hljs">using LSurvival
using Random
z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
enter = zeros(length(t));
m = fit(KMSurv, enter, t, d)
mw = fit(KMSurv, enter, t, d, wts=wt)</code></pre><p>or, equivalently:</p><pre><code class="language-julia hljs">kaplan_meier(enter, t, d, wts=wt)</code></pre><p>Aalen-Johansen estimator for cumulative cause-specific risk (in the presence of competing events)</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs"> StatsBase.fit!(m::T; kwargs...) where {T&lt;:AbstractNPSurv}

 aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,
   ; kwargs...)
</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>wts::Vector{&lt;:Real} = similar(enter, 0)</code>; vector of case weights (or zero length vector) for each observation</li><li><code>id::Vector{&lt;:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]</code>; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)</li><li><code>atol = 0.00000001</code>; absolute tolerance for defining tied event times</li><li><code>keepy = true</code>; keep the outcome vector after fitting (may save memory with large datasets)</li><li><code>eps = 0.00000001</code>; deprecated (replaced by atol)</li></ul><pre><code class="language- hljs">using LSurvival
using Random
z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
enter = zeros(length(t));
   # event variable is coded 0[referent],1,2
m = fit(AJSurv, enter, t, event)
mw = fit(AJSurv, enter, t, event, wts=wt)</code></pre><p>or, equivalently:</p><pre><code class="language-julia hljs">aalen_johansen(enter, t, event, wts=wt)</code></pre><p>Survival curve estimation using multiple cox models</p><p><strong>Signatures</strong></p><p>```julia   risk<em>from</em>coxphmodels(fitlist::Vector{T}, args...; kwargs...) where {T&lt;:PHModel}</p><p>fit(::Type{M}, fitlist::Vector{T}, ; fitargs...) where {M&lt;:PHSurv,T&lt;:PHModel}  ```</p><p><strong>Optional keywords</strong></p><ul><li><code>coef_vectors</code> = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]</li><li><code>pred_profile</code> = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]</li></ul><p>```@example  using LSurvival  using Random</p><p><strong>event variable is coded 0[referent],1,2</strong></p><p>z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);  enter = zeros(length(t));</p><p>ft1 = coxph(hcat(x,z), enter, t, (event .== 1))  nidx = findall(event .!= 1)  ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))</p><p><strong>risk at referent levels of <code>x</code> and <code>z</code></strong></p><p>risk<em>from</em>coxphmodels([ft1,ft2])</p><p><strong>risk at average levels of <code>x</code> and <code>z</code></strong></p><p>mnx = sum(x)/length(x)  mnz = sum(z)/length(z)</p><p><strong>equivalent</strong></p><p>fit(PHSurv, [ft1,ft2], pred<em>profile=[mnx,mnz])  risk</em>from<em>coxphmodels([ft1,ft2], pred</em>profile=[mnx,mnz])  ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/npsurvival.jl#L108-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.fit-Union{Tuple{T}, Tuple{M}, Tuple{Type{M}, Vector{T}}} where {M&lt;:PHSurv, T&lt;:PHModel}" href="#StatsAPI.fit-Union{Tuple{T}, Tuple{M}, Tuple{Type{M}, Vector{T}}} where {M&lt;:PHSurv, T&lt;:PHModel}"><code>StatsAPI.fit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Survival curve estimation using multiple cox models</p><p><strong>Signatures</strong></p><p>```julia   risk<em>from</em>coxphmodels(fitlist::Vector{T}, args...; kwargs...) where {T&lt;:PHModel}</p><p>fit(::Type{M}, fitlist::Vector{T}, ; fitargs...) where {M&lt;:PHSurv,T&lt;:PHModel}  ```</p><p><strong>Optional keywords</strong></p><ul><li><code>coef_vectors</code> = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]</li><li><code>pred_profile</code> = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]</li></ul><p>```@example  using LSurvival  using Random</p><p><strong>event variable is coded 0[referent],1,2</strong></p><p>z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);  enter = zeros(length(t));</p><p>ft1 = coxph(hcat(x,z), enter, t, (event .== 1))  nidx = findall(event .!= 1)  ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))</p><p><strong>risk at referent levels of <code>x</code> and <code>z</code></strong></p><p>risk<em>from</em>coxphmodels([ft1,ft2])</p><p><strong>risk at average levels of <code>x</code> and <code>z</code></strong></p><p>mnx = sum(x)/length(x)  mnz = sum(z)/length(z)</p><p><strong>equivalent</strong></p><p>fit(PHSurv, [ft1,ft2], pred<em>profile=[mnx,mnz])  risk</em>from<em>coxphmodels([ft1,ft2], pred</em>profile=[mnx,mnz])  ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/coxmodel.jl#L803-L840">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Matrix{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:AbstractPH, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}" href="#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Matrix{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:AbstractPH, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}"><code>StatsAPI.fit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Fit method for AbstractPH objects (Cox models)</p><p>Keyword arguments (used here, and passed on to internal structs)</p><ul><li><p><code>ties</code> &quot;breslow&quot; or &quot;efron&quot; (default)</p></li><li><p><code>wts</code> observation weights</p></li><li><p><code>ties</code> &quot;breslow&quot; or &quot;efron&quot; (default)</p></li><li><p><code>offset</code> not currently used at all</p></li><li><p><code>fitargs</code> arguments passed to other structs, which include</p><ul><li><code>id</code> cluster or individual level ID (defaults to a unique value for each row of data) see note below on ID</li><li><code>contrasts</code> StatsModel style contrasts (dicts) that can be used for variable transformations/indicator variable creation (e.g. https://juliastats.org/StatsModels.jl/stable/contrasts/)</li></ul><h2>Signatures</h2><pre><code class="language-julia hljs">fit(::Type{M},
X::AbstractMatrix,#{&lt;:FP},
enter::AbstractVector{&lt;:Real},
exit::AbstractVector{&lt;:Real},
y::Union{AbstractVector{&lt;:Real},BitVector}
;
ties =&quot;breslow&quot;,
wts::AbstractVector{&lt;:Real}      = similar(y, 0),
offset::AbstractVector{&lt;:Real}   = similar(y, 0),
fitargs...) where {M&lt;:AbstractPH}</code></pre><p>```</p></li></ul><p>coxph(f::FormulaTerm, data; kwargs...)   ```</p><p><code>coxph(X, enter, exit, y, args...; kwargs...)</code></p><p><code>julia    using LSurvival, Random    z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);    enter = zeros(length(t));    X = hcat(x,rand(length(x)));     m = fit(PHModel, X, enter, t, d, ties=&quot;efron&quot;)    m2 = fit(PHModel, X, enter, t, d, ties=&quot;breslow&quot;)    coeftable(m)</code></p><p><strong>Note on use of <code>id</code> keyword</strong></p><p><code>id</code> is not needed in person-period structure data for standard estimates or confidence intervals</p><p>```@example   using Random, LSurvival      id, int, outt, dat =          LSurvival.dgm(MersenneTwister(123123), 100, 100; afun = LSurvival.int_0)      data = (              int = int,              outt = outt,              d = dat[:,4] .== 1,              x = dat[:,1],              z = dat[:,2]      )</p><pre><code class="nohighlight hljs"> f = @formula(Surv(int, outt,d)~x+z)
 coxph(f, data)</code></pre><p>```</p><p><strong>BUT, you must specify <code>id</code> to get appropriate robust variance and some other statistics.</strong></p><p>Here is an example where the same data are presented in two different ways, which should yield identical statistics when used in Cox model.   ```@example  dat1 = (     time = [1,1,6,6,8,9],     status = [1,0,1,1,0,1],     x = [1,1,1,0,0,0]   )   ft = coxph(@formula(Surv(time,status)~x),dat1)   bic(ft)   nobs(ft)   dof_residual(ft)</p><p><strong>lrtest is another one</strong></p><p>stderror(ft)                     # model based   stderror(ft, type=&quot;robust&quot;)   # robust standard error, based on dfbeta residuals   ft</p><p><strong>now using &quot;clustered&quot; data with multiple observations per individual</strong></p><p>dat1clust= (      id = [1,2,3,3,4,4,5,5,6,6],      enter = [0,0,0,1,0,1,0,1,0,1],      exit = [1,1,1,6,1,6,1,8,1,9],      status = [1,0,0,1,0,1,0,0,0,1],      x = [1,1,1,1,0,0,0,0,0,0]  )</p><p><strong>use the <code>id</code> parameter with the ID struct</strong></p><p>ft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id))  bic(ft2)                       # CORRECT          nobs(ft2)                      # CORRECT  dof_residual(ft2)              # CORRECT</p><p>stderror(ft2)                  # model based (CORRECT)  stderror(ft2, type=&quot;robust&quot;)   # robust standard error, based on <code>id</code> level dfbeta residuals (CORRECT)</p><p><strong>once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics</strong></p><p>ft2   # CORRECT (compare to <code>ft</code> object)   ```</p><p><strong>NOTE THE FOLLOWING IS INCORRECT because the <code>id</code> keyword is omitted</strong></p><p>```@example  ft2w = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust)  bic(ft2w)                          # INCORRECT   nobs(ft2w)                         # INCORRECT  dof_residual(ft2w)                 # INCORRECT</p><p>stderror(ft2w)                     # model based (CORRECT)  stderror(ft2w, type=&quot;robust&quot;)      # robust variance (INCORRECT)</p><p>ft2w # the coefficient table now shows incorrect confidence intervals and test statistics</p><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/coxmodel.jl#L288-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:AJSurv, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}" href="#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:AJSurv, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}"><code>StatsAPI.fit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Aalen-Johansen estimator for cumulative cause-specific risk (in the presence of competing events)</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs"> StatsBase.fit!(m::T; kwargs...) where {T&lt;:AbstractNPSurv}

 aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,
   ; kwargs...)
</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>wts::Vector{&lt;:Real} = similar(enter, 0)</code>; vector of case weights (or zero length vector) for each observation</li><li><code>id::Vector{&lt;:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]</code>; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)</li><li><code>atol = 0.00000001</code>; absolute tolerance for defining tied event times</li><li><code>keepy = true</code>; keep the outcome vector after fitting (may save memory with large datasets)</li><li><code>eps = 0.00000001</code>; deprecated (replaced by atol)</li></ul><pre><code class="language- hljs">using LSurvival
using Random
z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
enter = zeros(length(t));
   # event variable is coded 0[referent],1,2
m = fit(AJSurv, enter, t, event)
mw = fit(AJSurv, enter, t, event, wts=wt)</code></pre><p>or, equivalently:</p><pre><code class="language-julia hljs">aalen_johansen(enter, t, event, wts=wt)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/npsurvival.jl#L151-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:KMSurv, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}" href="#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:KMSurv, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}"><code>StatsAPI.fit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Kaplan-Meier estimator for cumulative conditional risk</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs">StatsBase.fit!(m::T; kwargs...) where {T&lt;:AbstractNPSurv}

kaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,
   ; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li>wts::Vector{&lt;:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation</li><li>id::Vector{&lt;:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)</li><li>atol = 0.00000001; absolute tolerance for defining tied event times</li><li>censval = 0;  value of the outcome to be considered a censored event</li><li>keepy = true; keep the outcome vector after fitting (may save memory with large datasets)</li><li>eps = 0.00000001; deprecated (replaced by atol)</li></ul><pre><code class="language- hljs">using LSurvival
using Random
z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
enter = zeros(length(t));
m = fit(KMSurv, enter, t, d)
mw = fit(KMSurv, enter, t, d, wts=wt)</code></pre><p>or, equivalently:</p><pre><code class="language-julia hljs">kaplan_meier(enter, t, d, wts=wt)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/npsurvival.jl#L119-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.loglikelihood-Tuple{M} where M&lt;:AbstractPH" href="#StatsAPI.loglikelihood-Tuple{M} where M&lt;:AbstractPH"><code>StatsAPI.loglikelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Maximum log partial likelihood for a fitted <code>AbstractPH</code> model Efron or Breslow (depending on the <code>ties</code>` parameter)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/coxmodel.jl#L475-L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.nullloglikelihood-Tuple{M} where M&lt;:AbstractPH" href="#StatsAPI.nullloglikelihood-Tuple{M} where M&lt;:AbstractPH"><code>StatsAPI.nullloglikelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Null log-partial likelihood for a fitted <code>AbstractPH</code> model Efron or Breslow (depending on the <code>ties</code>` parameter)</p><p>Note: this is just the log partial likelihood at the initial values of the model, which default to 0. If initial values are non-null, then this function no longer validly returns the null log-partial likelihood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/coxmodel.jl#L490-L495">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.residuals-Tuple{M} where M&lt;:PHModel" href="#StatsAPI.residuals-Tuple{M} where M&lt;:PHModel"><code>StatsAPI.residuals</code></a> — <span class="docstring-category">Method</span></header><section><div><p>####################################################################</p><p>Cox proportional hazards model residuals:</p><p>Signature</p><p><code>julia   residuals(m::M; type = &quot;martingale&quot;) where {M&lt;:PHModel}</code>   where type is one of </p><ul><li><p><code>martingale</code></p></li><li><p><code>schoenfeld</code></p></li><li><p><code>score</code></p></li><li><p><code>dfbeta</code></p></li><li><p><code>scaled_schoenfeld</code></p><p>Residuals from the residuals function are designed to exactly emulate those from the <code>survival</code> package in R. Currently, they are validated for single observation data (e.g. one data row per individual).</p><p>####################################################################</p><h2>Martingale residuals: Observed versus expected</h2><pre><code class="language- hljs"># example from https://cran.r-project.org/web/packages/survival/vignettes/validate.pdf
# by Terry Therneau

dat1 = (
  time = [1,1,6,6,8,9],
  status = [1,0,1,1,0,1],
  x = [1,1,1,0,0,0]
)

# Nelson-Aalen type estimator for Breslow partial likelihood
ft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=&quot;breslow&quot;)
residuals(ft, type=&quot;martingale&quot;)</code></pre><pre><code class="language- hljs">dat1 = (
  time = [1,1,6,6,8,9],
  status = [1,0,1,1,0,1],
  x = [1,1,1,0,0,0]
)

# Fleming-Harrington type estimator for Efron partial likelihood
ft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=&quot;efron&quot;)
residuals(ft, type=&quot;martingale&quot;)
</code></pre><p>####################################################################</p><h2>Score residuals: Per observation contribution to score function</h2><pre><code class="language-julia hljs">using LSurvival
dat1 = (
  time = [1,1,6,6,8,9],
  status = [1,0,1,1,0,1],
  x = [1,1,1,0,0,0]
)
ft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=&quot;breslow&quot;)
S = residuals(ft, type=&quot;score&quot;)[:]
ft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=&quot;efron&quot;, maxiter=0)
S = residuals(ft, type=&quot;score&quot;)[:]</code></pre><p>####################################################################</p><h2>Schoenfeld residuals: Per time contribution to score function</h2><p>```julia using LSurvival dat1 = (   time = [1,1,6,6,8,9],   status = [1,0,1,1,0,1],   x = [1,1,1,0,0,0] ) ft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=&quot;breslow&quot;, maxiter=0)</p></li></ul><p>X = ft.P.X   M = residuals(ft, type=&quot;martingale&quot;)   S = residuals(ft, type=&quot;schoenfeld&quot;)[:]   ```</p><p>####################################################################</p><p><strong>dfbeta residuals: influence of individual observations on each parameter</strong></p><p>```@example   using LSurvival   dat1 = (     time = [1,1,6,6,8,9],     status = [1,0,1,1,0,1],     x = [1,1,1,0,0,0]   )</p><p>ft = coxph(@formula(Surv(time,status)~x),dat1, ties=&quot;breslow&quot;)   residuals(ft, type=&quot;dfbeta&quot;)</p><p><strong>can also calculate from score residuals and Hessian matrix</strong></p><p>L = residuals(ft, type=&quot;score&quot;) # n X p   H = ft.P._hess   # p X p   dfbeta = L*inv(H)   robVar = dfbeta&#39;dfbeta   sqrt(robVar)</p><p>```</p><p><strong>using the <code>id</code> keyword argument</strong></p><p><strong>see help for LSurvival.vcov for what happens when <code>id</code> keyword is not used</strong></p><p>```@example   dat1clust= (     id = [1,2,3,3,4,4,5,5,6,6],     enter = [0,0,0,1,0,1,0,1,0,1],     exit = [1,1,1,6,1,6,1,8,1,9],     status = [1,0,0,1,0,1,0,0,0,1],     x = [1,1,1,1,0,0,0,0,0,0]   )</p><p>ft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id), ties=&quot;breslow&quot;)</p><p><strong>note these are still on the observation level (not the id level)!</strong></p><p>residuals(ft2, type=&quot;dfbeta&quot;)</p><p><strong>getting id level dfbeta residuals</strong></p><p>dfbeta = residuals(ft2, type=&quot;dfbeta&quot;)   id = values(ft2.R.id)   D = reduce(vcat, [sum(dfbeta[findall(id .== i),:], dims=1) for i in unique(id)])   D&#39;D   vcov(ft, type=&quot;robust&quot;)   vcov(ft2, type=&quot;robust&quot;)   ```</p><p>####################################################################</p><p><strong>jackknife residuals: influence of individual observations on each parameter using leave-one-out estimates</strong></p><p>note there are other definitions of jackknife residuals  See Chapter 7.1 of &quot;Extending the Cox Model&quot; by Therneau and Grambsch for an example of the type of jackknife residuals used here</p><p>Jackknife residuals <span>$r_i$</span> for <span>$i \in 1:n$</span> are given as the difference between the maximum partial likelihood estimate and the jackknife estimates for each observation</p><p class="math-container">\[r_i = \hat\beta - \hat\beta_{(-i)}\]</p><p>where <span>$\beta_{(-i)}$</span> is the maximum partial likelihood estimate of the log-hazard ratio vector obtained from a dataset in which observations belonging to individual <code>i</code> are removed</p><p>```@example   using LSurvival   dat1 = (     time = [1,1,6,6,8,9],     status = [1,0,1,1,0,1],     x = [1,1,1,0,0,0]   )</p><p>ft = coxph(@formula(Surv(time,status)~x),dat1, ties=&quot;breslow&quot;)   #jackknife(ft)   residuals(ft, type=&quot;jackknife&quot;)</p><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/residuals.jl#L4-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.stderror-Tuple{AJSurv}" href="#StatsAPI.stderror-Tuple{AJSurv}"><code>StatsAPI.stderror</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Greenwood&#39;s formula for variance and confidence intervals of a Aalen-Johansen risk function</p><p><strong>Signatures:</strong></p><pre><code class="language-julia hljs">StatsBase.stderror(m::AJSurv)

StatsBase.confint(m:AJSurv; level=0.95, method=&quot;normal&quot;)</code></pre><p><strong>Keyword arguments</strong></p><ul><li>method<ul><li>&quot;normal&quot; normality-based confidence intervals</li><li>&quot;lognlog&quot; log(-log(S(t))) based confidence intervals</li></ul></li></ul><pre><code class="language- hljs">res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)
int = zeros(length(d)) # no late entry
m = fit(AJSurv, int, outt, event)
stderror(m)
confint(m, level=0.95)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/npsurvival.jl#L232-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.stderror-Tuple{KMSurv}" href="#StatsAPI.stderror-Tuple{KMSurv}"><code>StatsAPI.stderror</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Greenwood&#39;s formula for variance and confidence intervals of a Kaplan-Meier survival curve</p><p><strong>Signatures:</strong></p><pre><code class="language-julia hljs">StatsBase.stderror(m::KMSurv)

StatsBase.confint(m:KMSurv; level=0.95, method=&quot;normal&quot;)</code></pre><p><strong>Keyword arguments</strong></p><p><code>method</code>:</p><ul><li>&quot;normal&quot; normality-based confidence intervals</li><li>&quot;lognlog&quot; log(-log(S(t))) based confidence intervals</li></ul><pre><code class="language- hljs">using LSurvival
using Random
z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
enter = zeros(length(t));
m = fit(KMSurv, enter, t, d)
mw = fit(KMSurv, enter, t, d, wts=wt)
stderror(m)
confint(m, method=&quot;normal&quot;)
confint(m, method=&quot;lognlog&quot;) # log-log transformation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/npsurvival.jl#L195-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.vcov-Tuple{M} where M&lt;:AbstractPH" href="#StatsAPI.vcov-Tuple{M} where M&lt;:AbstractPH"><code>StatsAPI.vcov</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Covariance matrix for Cox proportional hazards models  </p><p>Keyword arguments</p><ul><li><p><code>type</code> nothing or &quot;robust&quot;: determines whether model based or robust (dfbeta based) variance is returned.</p><p>See ?residuals for info on <code>dfbeta</code> residuals</p></li></ul><pre><code class="language- hljs">using LSurvival
dat1 = (
  time = [1,1,6,6,8,9],
  status = [1,0,1,1,0,1],
  x = [1,1,1,0,0,0]
)
ft = coxph(@formula(Surv(time,status)~x),dat1, id=ID.(collect(1:6)))

vcov(ft)                   # model based
vcov(ft, type=&quot;robust&quot;)    # robust variance, based on dfbeta residuals
# once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics
ft</code></pre><p><strong>cluster robust standard errors using the <code>id</code> keyword argument</strong></p><pre><code class="language- hljs">dat1clust= (
  id = [1,2,3,3,4,4,5,5,6,6],
  enter = [0,0,0,1,0,1,0,1,0,1],
  exit = [1,1,1,6,1,6,1,8,1,9],
  status = [1,0,0,1,0,1,0,0,0,1],
  x = [1,1,1,1,0,0,0,0,0,0]
)

ft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id))

vcov(ft2)                     # model based
vcov(ft2, type=&quot;robust&quot;)       # robust variance, based on dfbeta residuals
stderror(ft2, type=&quot;robust&quot;)   # robust variance, based on dfbeta residuals
confint(ft2, type=&quot;robust&quot;)    # robust variance, based on dfbeta residuals
nobs(ft2)                     # id argument yields correct value of number of independent observations
# once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics
ft2 </code></pre><p><strong>NOTE THE FOLLOWING IS INCORRECT because the <code>id</code> keyword is omitted</strong></p><pre><code class="language- hljs">ft2w = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust)

vcov(ft2w)                   # model based (CORRECT)
vcov(ft2w, type=&quot;robust&quot;)    # robust variance (INCORRECT)
nobs(ft2w)

ft2w</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/8fbce969558a1103e20843e3dffbc309f77439f5/src/coxmodel.jl#L519-L575">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 15 September 2023 11:06">Friday 15 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
