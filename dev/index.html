<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Help · LSurvival: survival analysis for left-truncated, right-censored outcomes</title><meta name="title" content="Help · LSurvival: survival analysis for left-truncated, right-censored outcomes"/><meta property="og:title" content="Help · LSurvival: survival analysis for left-truncated, right-censored outcomes"/><meta property="twitter:title" content="Help · LSurvival: survival analysis for left-truncated, right-censored outcomes"/><meta name="description" content="Documentation for LSurvival: survival analysis for left-truncated, right-censored outcomes."/><meta property="og:description" content="Documentation for LSurvival: survival analysis for left-truncated, right-censored outcomes."/><meta property="twitter:description" content="Documentation for LSurvival: survival analysis for left-truncated, right-censored outcomes."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>LSurvival: survival analysis for left-truncated, right-censored outcomes</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Help</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Quick-examples"><span>Quick examples</span></a></li><li class="toplevel"><a class="tocitem" href="#Index-of-functions"><span>Index of functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Function-help"><span>Function help</span></a></li><li class="toplevel"><a class="tocitem" href="#Implementation-details-and-further-help"><span>Implementation details and further help</span></a></li></ul></li><li><span class="tocitem">Details</span><ul><li><a class="tocitem" href="Likelihood/">Likelihood functions</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="nonparametric/">Non-parametric survival analysis</a></li><li><a class="tocitem" href="coxmodel/">Semi-parametric survival analysis with Cox models</a></li><li><a class="tocitem" href="parametric/">Parametric survival analysis with AFT models</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Help</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Help</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/alexpkeil1/LSurvival.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/alexpkeil1/LSurvival.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="[LSurvival](https://github.com/alexpkeil1/LSurvival.jl)"><a class="docs-heading-anchor" href="#[LSurvival](https://github.com/alexpkeil1/LSurvival.jl)"><a href="https://github.com/alexpkeil1/LSurvival.jl">LSurvival</a></a><a id="[LSurvival](https://github.com/alexpkeil1/LSurvival.jl)-1"></a><a class="docs-heading-anchor-permalink" href="#[LSurvival](https://github.com/alexpkeil1/LSurvival.jl)" title="Permalink"></a></h1><p>Survival analysis functions in Julia for time-to-event outcomes that can include:</p><ul><li>Loss-to-follow-up/right censoring</li><li>Late entry/left truncation (not available in Survival.jl)</li><li>&quot;Person-period&quot; data structures (not available in Survival.jl)</li><li>Observation weights (not available in Survival.jl)</li><li>Competing risks (not available in Survival.jl)</li></ul><p>Capabilities include estimators for</p><ul><li>Kaplan-Meier non-parametric conditional risk functions</li><li>Aalen-Johansen non-parametric cause-specific unconditional risk functions</li><li>Cox proportional hazards model (Efron&#39;s or Breslow&#39;s methods for ties)</li><li>Parametric survival models</li></ul><p>Convenience functions enable:</p><ul><li>Non-parametric bootstrapping, cluster-bootstrapping, jackknife</li><li>Estimating baseline hazards from a Cox Model</li><li>Estimating cause-specific risk from an exhaustive set of Cox models for competing risk outcomes</li><li>Simple simulation of competing and non-competing survival events</li><li>Martingale, score, Schoenfeld, and dfbeta residuals</li><li>Cluster robust variance estimation (Cox models)</li></ul><p>Plans to include:</p><ul><li>Parametric survival models: more distributions</li><li>Stratification in Cox models</li><li>Parametric survival model diagnostics</li></ul><p>The package has been tuned to follow the &quot;survival&quot; package from R in terms of specific estimators/results.</p><p>Report issues <a href="https://github.com/alexpkeil1/LSurvival.jl/issues">here</a></p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><pre><code class="language- hljs">using Pkg; Pkg.add(url = &quot;https://github.com/alexpkeil1/LSurvival.jl&quot;)</code></pre><h2 id="Quick-examples"><a class="docs-heading-anchor" href="#Quick-examples">Quick examples</a><a id="Quick-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-examples" title="Permalink"></a></h2><h3 id="Single-event-type:-Cox-model-and-Kaplan-Meier-curve"><a class="docs-heading-anchor" href="#Single-event-type:-Cox-model-and-Kaplan-Meier-curve">Single event type: Cox model and Kaplan-Meier curve</a><a id="Single-event-type:-Cox-model-and-Kaplan-Meier-curve-1"></a><a class="docs-heading-anchor-permalink" href="#Single-event-type:-Cox-model-and-Kaplan-Meier-curve" title="Permalink"></a></h3><pre><code class="language-julia hljs"># generate some data under a discrete hazards model
using Random
id, int, out, data = LSurvival.dgm(MersenneTwister(1212), 100, 20)

data[:, 1] = round.(data[:, 1], digits = 3)
d, X = data[:, 4], data[:, 1:3]

tab = ( in = int, out = out, d=d, x=X[:,1], z1=X[:,2], z2=X[:,3]) 
wt = ones(length(d)) # weights of 1.0 just to demonstrate usage


coxph(@formula(Surv(in, out, d)~x+z1+z2), tab, ties = &quot;efron&quot;, wts = wt)</code></pre><p>Output:</p><pre><code class="nohighlight hljs">Maximum partial likelihood estimates (alpha=0.05):
───────────────────────────────────────────────────────────
      ln(HR)    StdErr         LCI       UCI     Z  P(&gt;|Z|)
───────────────────────────────────────────────────────────
x   1.12624   0.392651   0.356659   1.89582   2.87   0.0041
z1  0.434587  0.27122   -0.0969944  0.966168  1.60   0.1091
z2  1.70434   0.222878   1.26751    2.14117   7.65   &lt;1e-13
───────────────────────────────────────────────────────────
Partial log-likelihood (null): -361.948
Partial log-likelihood (fitted): -332.063
LRT p-value (χ²=59.77, df=3): 6.5858e-13
Newton-Raphson iterations: 5</code></pre><pre><code class="language-julia hljs"># can also be done if there is no late entry
coxph(@formula(Surv(out, d)~x+z1+z2), tab, ties = &quot;efron&quot;, wts = wt)
# can also be done if there is no late entry and no right censoring (i.e. all times are failure times)
coxph(@formula(Surv(out)~x+z1+z2), tab, ties = &quot;efron&quot;, wts = wt)

# Kaplan-Meier estimator of the cumulative risk/survival
kaplan_meier(int, outt, d)</code></pre><h3 id="Competing-event-analysis:-Aalen-Johansen-and-Cox-model-based-estimators-of-the-cumulative-risk/survival"><a class="docs-heading-anchor" href="#Competing-event-analysis:-Aalen-Johansen-and-Cox-model-based-estimators-of-the-cumulative-risk/survival">Competing event analysis: Aalen-Johansen and Cox-model-based estimators of the cumulative risk/survival</a><a id="Competing-event-analysis:-Aalen-Johansen-and-Cox-model-based-estimators-of-the-cumulative-risk/survival-1"></a><a class="docs-heading-anchor-permalink" href="#Competing-event-analysis:-Aalen-Johansen-and-Cox-model-based-estimators-of-the-cumulative-risk/survival" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Aalen-Johansen estimator: marginal cause-specific risks
res_aj = aalen_johansen(enter, t, event; wts = wt);
res_aj

# Cox-model estimator: cause-specific risks at given levels of covariates
fit1 = fit(PHModel, X, enter, t, (event .== 1), ties = &quot;efron&quot;,  wts = wt)
n2idx = findall(event .!= 1)
fit2 = fit(PHModel, X[n2idx,:], enter[n2idx], t[n2idx], (event[n2idx] .== 2), ties = &quot;efron&quot;,  wts = wt[n2idx])

# risk at average levels of `x` and `z`
res_cph = risk_from_coxphmodels([fit1,fit2], coef_vectors=[coef(fit1), coef(fit2)], pred_profile=mean(X, dims=1))
# compare to Aalen-Johansen fit
res_aj


# this approach operates on left censored outcomes (which operate in the background in model fitting)
LSurvivalResp(enter, t, d, origintime=0)
LSurvivalCompResp(enter, t, event) # automatically infers origin


# can use the ID type to refer to units with multiple observations
id, int, outt, data = dgm(MersenneTwister(), 1000, 10; regimefun = int_0)
LSurvivalResp(int, outt, data[:,4], ID.(id))</code></pre><h1 id="Index-of-functions"><a class="docs-heading-anchor" href="#Index-of-functions">Index of functions</a><a id="Index-of-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Index-of-functions" title="Permalink"></a></h1><ul><li><a href="#LSurvival.AbstractLSurvivalParms"><code>LSurvival.AbstractLSurvivalParms</code></a></li><li><a href="#LSurvival.AbstractLSurvivalResp"><code>LSurvival.AbstractLSurvivalResp</code></a></li><li><a href="#LSurvival.AbstractNPSurv"><code>LSurvival.AbstractNPSurv</code></a></li><li><a href="#LSurvival.AbstractPH"><code>LSurvival.AbstractPH</code></a></li><li><a href="#LSurvival.AbstractPSModel"><code>LSurvival.AbstractPSModel</code></a></li><li><a href="#LSurvival.AbstractSurvDist"><code>LSurvival.AbstractSurvDist</code></a></li><li><a href="#LSurvival.ID"><code>LSurvival.ID</code></a></li><li><a href="#LSurvival.LSurvivalCompResp"><code>LSurvival.LSurvivalCompResp</code></a></li><li><a href="#LSurvival.LSurvivalResp"><code>LSurvival.LSurvivalResp</code></a></li><li><a href="#LSurvival.PHModel"><code>LSurvival.PHModel</code></a></li><li><a href="#LSurvival.PHSurv"><code>LSurvival.PHSurv</code></a></li><li><a href="#LSurvival.Strata"><code>LSurvival.Strata</code></a></li><li><a href="#LSurvival._update_PHParms!-Union{Tuple{T}, Tuple{I}, Tuple{M}, Tuple{M, I, Array{Vector{T}, 1}, Array{Vector{T}, 1}}} where {M&lt;:AbstractPH, I&lt;:Int64, T&lt;:Int64}"><code>LSurvival._update_PHParms!</code></a></li><li><a href="#LSurvival.aalen_johansen-Tuple{FormulaTerm, Any}"><code>LSurvival.aalen_johansen</code></a></li><li><a href="#LSurvival.bootstrap-Tuple{MersenneTwister, PHModel, Int64}"><code>LSurvival.bootstrap</code></a></li><li><a href="#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M&lt;:AJSurv"><code>LSurvival.bootstrap</code></a></li><li><a href="#LSurvival.bootstrap-Union{Tuple{S}, Tuple{Vector{Int64}, S}} where S&lt;:PSParms"><code>LSurvival.bootstrap</code></a></li><li><a href="#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M&lt;:KMSurv"><code>LSurvival.bootstrap</code></a></li><li><a href="#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M&lt;:PHModel"><code>LSurvival.bootstrap</code></a></li><li><a href="#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T&lt;:LSurvivalResp"><code>LSurvival.bootstrap</code></a></li><li><a href="#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T&lt;:LSurvivalCompResp"><code>LSurvival.bootstrap</code></a></li><li><a href="#LSurvival.calcp-Tuple{Any}"><code>LSurvival.calcp</code></a></li><li><a href="#LSurvival.cdfchisq-Tuple{Any, Any}"><code>LSurvival.cdfchisq</code></a></li><li><a href="#LSurvival.cdfnorm-Tuple{Any}"><code>LSurvival.cdfnorm</code></a></li><li><a href="#LSurvival.coxph-Tuple{Any, Any, Any, Any, Vararg{Any}}"><code>LSurvival.coxph</code></a></li><li><a href="#LSurvival.ddloglik!-Union{Tuple{D}, Tuple{Any, D, Vararg{Any, 6}}} where D&lt;:AbstractSurvDist"><code>LSurvival.ddloglik!</code></a></li><li><a href="#LSurvival.dgm-Tuple{MersenneTwister, Int64, Int64}"><code>LSurvival.dgm</code></a></li><li><a href="#LSurvival.dgm_comprisk-Tuple{MersenneTwister, Int64}"><code>LSurvival.dgm_comprisk</code></a></li><li><a href="#LSurvival.dgm_phmodel-Tuple{MersenneTwister, Int64}"><code>LSurvival.dgm_phmodel</code></a></li><li><a href="#LSurvival.dloglik!-Union{Tuple{D}, Tuple{Any, D, Vararg{Any, 6}}} where D&lt;:AbstractSurvDist"><code>LSurvival.dloglik!</code></a></li><li><a href="#LSurvival.dlpdf_gengamma-NTuple{4, Any}"><code>LSurvival.dlpdf_gengamma</code></a></li><li><a href="#LSurvival.dlsurv_gengamma-NTuple{4, Any}"><code>LSurvival.dlsurv_gengamma</code></a></li><li><a href="#LSurvival.jackknife-Tuple{M} where M&lt;:KMSurv"><code>LSurvival.jackknife</code></a></li><li><a href="#LSurvival.jackknife-Tuple{M} where M&lt;:AJSurv"><code>LSurvival.jackknife</code></a></li><li><a href="#LSurvival.jackknife-Tuple{M} where M&lt;:PHModel"><code>LSurvival.jackknife</code></a></li><li><a href="#LSurvival.kaplan_meier-Tuple{FormulaTerm, Any}"><code>LSurvival.kaplan_meier</code></a></li><li><a href="#LSurvival.lgh!-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:PSModel"><code>LSurvival.lgh!</code></a></li><li><a href="#LSurvival.lgh_breslow!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M&lt;:AbstractPH"><code>LSurvival.lgh_breslow!</code></a></li><li><a href="#LSurvival.lgh_efron!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M&lt;:AbstractPH"><code>LSurvival.lgh_efron!</code></a></li><li><a href="#LSurvival.loglik-Union{Tuple{D}, Tuple{D, Vararg{Any, 6}}} where D&lt;:AbstractSurvDist"><code>LSurvival.loglik</code></a></li><li><a href="#LSurvival.lpdf-Tuple{LSurvival.Lognormal, Any}"><code>LSurvival.lpdf</code></a></li><li><a href="#LSurvival.lpdf-Tuple{LSurvival.Gamma, Any, Any, Any}"><code>LSurvival.lpdf</code></a></li><li><a href="#LSurvival.lpdf-Tuple{LSurvival.GGamma, Any}"><code>LSurvival.lpdf</code></a></li><li><a href="#LSurvival.lpdf-Tuple{LSurvival.Weibull, Any, Any, Any}"><code>LSurvival.lpdf</code></a></li><li><a href="#LSurvival.lpdf-Tuple{LSurvival.Gamma, Any}"><code>LSurvival.lpdf</code></a></li><li><a href="#LSurvival.lpdf-Tuple{LSurvival.GGamma, Any, Any, Any}"><code>LSurvival.lpdf</code></a></li><li><a href="#LSurvival.lpdf-Tuple{LSurvival.Weibull, Any}"><code>LSurvival.lpdf</code></a></li><li><a href="#LSurvival.lpdf-Tuple{LSurvival.Lognormal, Any, Any, Any}"><code>LSurvival.lpdf</code></a></li><li><a href="#LSurvival.lpdf-Tuple{LSurvival.Exponential, Any}"><code>LSurvival.lpdf</code></a></li><li><a href="#LSurvival.lpdf-Tuple{LSurvival.Exponential, Any, Any, Any}"><code>LSurvival.lpdf</code></a></li><li><a href="#LSurvival.lpdf_gradient-Tuple{LSurvival.Exponential, Any, Any, Any}"><code>LSurvival.lpdf_gradient</code></a></li><li><a href="#LSurvival.lpdf_gradient-Tuple{LSurvival.Gamma, Any, Any, Any}"><code>LSurvival.lpdf_gradient</code></a></li><li><a href="#LSurvival.lpdf_gradient-Tuple{LSurvival.Lognormal, Any, Any, Any}"><code>LSurvival.lpdf_gradient</code></a></li><li><a href="#LSurvival.lpdf_gradient-Tuple{LSurvival.Weibull, Any, Any, Any}"><code>LSurvival.lpdf_gradient</code></a></li><li><a href="#LSurvival.lpdf_gradient-Tuple{LSurvival.GGamma, Any, Any, Any}"><code>LSurvival.lpdf_gradient</code></a></li><li><a href="#LSurvival.lpdf_hessian-Tuple{LSurvival.Exponential, Any, Any, Any}"><code>LSurvival.lpdf_hessian</code></a></li><li><a href="#LSurvival.lpdf_hessian-Tuple{LSurvival.Lognormal, Any, Any, Any}"><code>LSurvival.lpdf_hessian</code></a></li><li><a href="#LSurvival.lpdf_hessian-Tuple{LSurvival.Gamma, Any, Any, Any}"><code>LSurvival.lpdf_hessian</code></a></li><li><a href="#LSurvival.lpdf_hessian-Tuple{LSurvival.GGamma, Any, Any, Any}"><code>LSurvival.lpdf_hessian</code></a></li><li><a href="#LSurvival.lpdf_hessian-Tuple{LSurvival.Gamma, Any}"><code>LSurvival.lpdf_hessian</code></a></li><li><a href="#LSurvival.lpdf_hessian-Tuple{LSurvival.GGamma, Any}"><code>LSurvival.lpdf_hessian</code></a></li><li><a href="#LSurvival.lpdf_hessian-Tuple{LSurvival.Exponential, Any}"><code>LSurvival.lpdf_hessian</code></a></li><li><a href="#LSurvival.lpdf_hessian-Tuple{LSurvival.Weibull, Any, Any, Any}"><code>LSurvival.lpdf_hessian</code></a></li><li><a href="#LSurvival.lpdf_hessian-Tuple{LSurvival.Lognormal, Any}"><code>LSurvival.lpdf_hessian</code></a></li><li><a href="#LSurvival.lpdf_weibull-Tuple{Any, Any, Any}"><code>LSurvival.lpdf_weibull</code></a></li><li><a href="#LSurvival.lsurv-Tuple{LSurvival.Gamma, Any, Any, Any}"><code>LSurvival.lsurv</code></a></li><li><a href="#LSurvival.lsurv-Tuple{LSurvival.Weibull, Any, Any, Any}"><code>LSurvival.lsurv</code></a></li><li><a href="#LSurvival.lsurv-Tuple{LSurvival.GGamma, Any, Any, Any}"><code>LSurvival.lsurv</code></a></li><li><a href="#LSurvival.lsurv-Tuple{LSurvival.Exponential, Any}"><code>LSurvival.lsurv</code></a></li><li><a href="#LSurvival.lsurv-Tuple{LSurvival.Lognormal, Any}"><code>LSurvival.lsurv</code></a></li><li><a href="#LSurvival.lsurv-Tuple{LSurvival.Gamma, Any}"><code>LSurvival.lsurv</code></a></li><li><a href="#LSurvival.lsurv-Tuple{LSurvival.GGamma, Any}"><code>LSurvival.lsurv</code></a></li><li><a href="#LSurvival.lsurv-Tuple{LSurvival.Lognormal, Any, Any, Any}"><code>LSurvival.lsurv</code></a></li><li><a href="#LSurvival.lsurv-Tuple{LSurvival.Exponential, Any, Any, Any}"><code>LSurvival.lsurv</code></a></li><li><a href="#LSurvival.lsurv-Tuple{LSurvival.Weibull, Any}"><code>LSurvival.lsurv</code></a></li><li><a href="#LSurvival.lsurv_gradient-Tuple{LSurvival.Exponential, Any, Any, Any}"><code>LSurvival.lsurv_gradient</code></a></li><li><a href="#LSurvival.lsurv_gradient-Tuple{LSurvival.Lognormal, Any, Any, Any}"><code>LSurvival.lsurv_gradient</code></a></li><li><a href="#LSurvival.lsurv_gradient-Tuple{LSurvival.GGamma, Any, Any, Any}"><code>LSurvival.lsurv_gradient</code></a></li><li><a href="#LSurvival.lsurv_gradient-Tuple{LSurvival.Gamma, Any, Any, Any}"><code>LSurvival.lsurv_gradient</code></a></li><li><a href="#LSurvival.lsurv_gradient-Tuple{LSurvival.Weibull, Any, Any, Any}"><code>LSurvival.lsurv_gradient</code></a></li><li><a href="#LSurvival.lsurv_hessian-Tuple{LSurvival.GGamma, Any, Any, Any}"><code>LSurvival.lsurv_hessian</code></a></li><li><a href="#LSurvival.lsurv_hessian-Tuple{LSurvival.GGamma, Any}"><code>LSurvival.lsurv_hessian</code></a></li><li><a href="#LSurvival.lsurv_hessian-Tuple{LSurvival.Gamma, Any}"><code>LSurvival.lsurv_hessian</code></a></li><li><a href="#LSurvival.lsurv_hessian-Tuple{LSurvival.Lognormal, Any}"><code>LSurvival.lsurv_hessian</code></a></li><li><a href="#LSurvival.lsurv_hessian-Tuple{LSurvival.Weibull, Any, Any, Any}"><code>LSurvival.lsurv_hessian</code></a></li><li><a href="#LSurvival.lsurv_hessian-Tuple{LSurvival.Gamma, Any, Any, Any}"><code>LSurvival.lsurv_hessian</code></a></li><li><a href="#LSurvival.lsurv_hessian-Tuple{LSurvival.Exponential, Any, Any, Any}"><code>LSurvival.lsurv_hessian</code></a></li><li><a href="#LSurvival.lsurv_hessian-Tuple{LSurvival.Lognormal, Any, Any, Any}"><code>LSurvival.lsurv_hessian</code></a></li><li><a href="#LSurvival.lsurv_hessian-Tuple{LSurvival.Exponential, Any}"><code>LSurvival.lsurv_hessian</code></a></li><li><a href="#LSurvival.lsurv_hessian-Tuple{LSurvival.Weibull, Any}"><code>LSurvival.lsurv_hessian</code></a></li><li><a href="#LSurvival.qstdnorm-Tuple{Any}"><code>LSurvival.qstdnorm</code></a></li><li><a href="#LSurvival.qweibull-Tuple{Any, Any, Any}"><code>LSurvival.qweibull</code></a></li><li><a href="#LSurvival.randweibull-Tuple{Any, Any, Any}"><code>LSurvival.randweibull</code></a></li><li><a href="#LSurvival.risk_from_coxphmodels-Union{Tuple{T}, Tuple{Vector{T}, Vararg{Any}}} where T&lt;:PHModel"><code>LSurvival.risk_from_coxphmodels</code></a></li><li><a href="#LSurvival.survivaldata-Tuple"><code>LSurvival.survivaldata</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, PHSurv}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.LognLogPlot}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvivalResp}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.AFTdist}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, KMSurv}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, AJSurv}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.CoxInfluence}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.BaseHazPlot}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.CoxDX}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#StatsAPI.confint-Tuple{AJSurv}"><code>StatsAPI.confint</code></a></li><li><a href="#StatsAPI.confint-Tuple{KMSurv}"><code>StatsAPI.confint</code></a></li><li><a href="#StatsAPI.confint-Tuple{M} where M&lt;:AbstractPH"><code>StatsAPI.confint</code></a></li><li><a href="#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Matrix{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:AbstractPH, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}"><code>StatsAPI.fit</code></a></li><li><a href="#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:AJSurv, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}"><code>StatsAPI.fit</code></a></li><li><a href="#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:KMSurv, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}"><code>StatsAPI.fit</code></a></li><li><a href="#StatsAPI.fit-Union{Tuple{T}, Tuple{M}, Tuple{Type{M}, Vector{T}}} where {M&lt;:PHSurv, T&lt;:PHModel}"><code>StatsAPI.fit</code></a></li><li><a href="#StatsAPI.fit!-Tuple{T} where T&lt;:AbstractNPSurv"><code>StatsAPI.fit!</code></a></li><li><a href="#StatsAPI.loglikelihood-Tuple{M} where M&lt;:PSModel"><code>StatsAPI.loglikelihood</code></a></li><li><a href="#StatsAPI.loglikelihood-Tuple{M} where M&lt;:AbstractPH"><code>StatsAPI.loglikelihood</code></a></li><li><a href="#StatsAPI.nullloglikelihood-Tuple{M} where M&lt;:PSModel"><code>StatsAPI.nullloglikelihood</code></a></li><li><a href="#StatsAPI.nullloglikelihood-Tuple{M} where M&lt;:AbstractPH"><code>StatsAPI.nullloglikelihood</code></a></li><li><a href="#StatsAPI.residuals-Tuple{M} where M&lt;:PHModel"><code>StatsAPI.residuals</code></a></li><li><a href="#StatsAPI.stderror-Tuple{AJSurv}"><code>StatsAPI.stderror</code></a></li><li><a href="#StatsAPI.stderror-Tuple{KMSurv}"><code>StatsAPI.stderror</code></a></li><li><a href="#StatsAPI.vcov-Tuple{M} where M&lt;:AbstractPH"><code>StatsAPI.vcov</code></a></li></ul><h1 id="Function-help"><a class="docs-heading-anchor" href="#Function-help">Function help</a><a id="Function-help-1"></a><a class="docs-heading-anchor-permalink" href="#Function-help" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.AbstractLSurvivalParms" href="#LSurvival.AbstractLSurvivalParms"><code>LSurvival.AbstractLSurvivalParms</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>AbstractLsurvParms</p><p>Abstract type representing a model predictors and coefficient parameters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/LSurvival.jl#L149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.AbstractLSurvivalResp" href="#LSurvival.AbstractLSurvivalResp"><code>LSurvival.AbstractLSurvivalResp</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>AbstractLsurvResp</p><p>Abstract type representing a model response vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/LSurvival.jl#L144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.AbstractNPSurv" href="#LSurvival.AbstractNPSurv"><code>LSurvival.AbstractNPSurv</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract type for non-parametric survival models, including Kaplan-Meier, Aalen Johansen, and Cox-model based estimates of survival using an Aalen-Johansen-like estimator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/LSurvival.jl#L166-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.AbstractPH" href="#LSurvival.AbstractPH"><code>LSurvival.AbstractPH</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract type for proportional hazards models</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/LSurvival.jl#L154-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.AbstractPSModel" href="#LSurvival.AbstractPSModel"><code>LSurvival.AbstractPSModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>AbstractPS</p><p>Abstract type for parametric survival models</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/LSurvival.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.AbstractSurvDist" href="#LSurvival.AbstractSurvDist"><code>LSurvival.AbstractSurvDist</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>AbstractSurvDist</p><p>Abstract type for parametric survival distributions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/LSurvival.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.ID" href="#LSurvival.ID"><code>LSurvival.ID</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Type for identifying individuals in survival outcomes.</p><p>Used for the id argument in </p><ul><li>Outcome types: LSurvivalResp, LSurvivalCompResp </li><li>Model types: PHModel, KMRisk, AJRisk</li></ul><p>Accepts any Number or String. There is no significance to having this particular struct, but it enables easier use of multiple dispatch.</p><pre><code class="language- hljs">[ID(i) for i in 1:10]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/shared_structs.jl#L8-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.LSurvivalCompResp" href="#LSurvival.LSurvivalCompResp"><code>LSurvival.LSurvivalCompResp</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Outcome type for competing risk survival outcomes subject to left truncation and right censoring (not generally needed for users)</p><p>Parameters</p><ul><li><p><code>enter</code> Time at observation start</p></li><li><p><code>exit</code> Time at observation end</p></li><li><p><code>y</code> event occurrence in observation</p></li><li><p><code>wts</code> observation weights</p></li><li><p><code>eventtimes</code> unique event times</p></li><li><p><code>origin</code> origin on the time scale</p></li><li><p><code>id</code> person level identifier (must be wrapped in ID() function)</p></li><li><p><code>eventtypes</code> vector of unique event types</p></li><li><p><code>eventmatrix</code> matrix of indicators on the observation level</p><p><strong>Signatures:</strong></p></li></ul><pre><code class="language-julia hljs"> struct LSurvivalCompResp{
 E&lt;:AbstractVector,
 X&lt;:AbstractVector,
 Y&lt;:AbstractVector,
 W&lt;:AbstractVector,
 T&lt;:Real,
 I&lt;:AbstractLSurvivalID,
 V&lt;:AbstractVector,
 M&lt;:AbstractMatrix,
 } &lt;: AbstractLSurvivalResp
 enter::E
 exit::X
 y::Y
 wts::W
 eventtimes::X
 origin::T
 id::Vector{I}
 eventtypes::V
 eventmatrix::M
 end</code></pre><pre><code class="language-julia hljs"> LSurvivalCompResp(
 enter::E,
 exit::X,
 y::Y,
 wts::W,
 id::Vector{I}
 )</code></pre><pre><code class="language-julia hljs"> LSurvivalCompResp(
 enter::E,
 exit::X,
 y::Y,
 id::Vector{I}
 )</code></pre><pre><code class="language-julia hljs"> LSurvivalCompResp(
 enter::E,
 exit::X,
 y::Y,
 wts::W,
 )</code></pre><pre><code class="language-julia hljs"> LSurvivalCompResp(
 enter::E,
 exit::X,
 y::Y,
 )</code></pre><pre><code class="language-julia hljs"> LSurvivalCompResp(
  exit::X,
  y::Y,
  ) where {X&lt;:Vector,Y&lt;:Union{Vector{&lt;:Real},BitVector}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/shared_structs.jl#L193-L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.LSurvivalResp" href="#LSurvival.LSurvivalResp"><code>LSurvival.LSurvivalResp</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Outcome type for survival outcome subject to left truncation and right censoring. </p><p>Will not generally be needed by users</p><p>Parameters</p><ul><li><code>enter</code>: Time at observation start</li><li><code>exit</code>: Time at observation end</li><li><code>y</code>: event occurrence in observation</li><li><code>wts</code>: observation weights</li><li><code>eventtimes</code>: unique event times</li><li><code>origin</code>: origin on the time scale</li><li><code>id</code>: person level identifier (must be wrapped in ID() function)</li></ul><pre><code class="language-julia hljs"> struct LSurvivalResp{
 E&lt;:AbstractVector,
 X&lt;:AbstractVector,
 Y&lt;:AbstractVector,
 W&lt;:AbstractVector,
 T&lt;:Real,
 I&lt;:AbstractLSurvivalID,
 } &lt;: AbstractLSurvivalResp
 enter::E
 exit::X
 y::Y
 wts::W
 eventtimes::E
 origin::T
 id::Vector{I}
 end
</code></pre><pre><code class="language-julia hljs"> LSurvivalResp(
    enter::E,
    exit::X,
    y::Y,
    wts::W,
    id::Vector{I},
  ) where {
    E&lt;:Vector,
    X&lt;:Vector,
    Y&lt;:Union{Vector{&lt;:Real},BitVector},
    W&lt;:Vector,
    I&lt;:AbstractLSurvivalID,
}</code></pre><pre><code class="language-julia hljs"> LSurvivalResp(
 enter::E,
 exit::X,
 y::Y,
 id::Vector{I},
 ) 
</code></pre><pre><code class="language-julia hljs"> LSurvivalResp(
  y::Vector{Y},
  wts::W,
  id::Vector{I},
  ) where {Y&lt;:AbstractSurvTime,W&lt;:Vector,I&lt;:AbstractLSurvivalID}</code></pre><pre><code class="language-julia hljs"> LSurvivalResp(
  enter::E,
  exit::X,
  y::Y,
  ) where {E&lt;:Vector,X&lt;:Vector,Y&lt;:Union{Vector{&lt;:Real},BitVector}}</code></pre><pre><code class="language-julia hljs"> LSurvivalResp(exit::X, y::Y) where {X&lt;:Vector,Y&lt;:Vector}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">  # no late entry
  LSurvivalResp([.5, .6], [1,0])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/shared_structs.jl#L62-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.PHModel" href="#LSurvival.PHModel"><code>LSurvival.PHModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>PHModel: Mutable object type for proportional hazards regression (not generally needed for users)</p><p>Parameters</p><ul><li><p><code>R</code> Survival response</p></li><li><p><code>P</code>        # parameters</p></li><li><p><code>ties</code> String: &quot;efron&quot; or &quot;breslow&quot;</p></li><li><p><code>fit</code> Bool: logical for whether the model has been fitted</p></li><li><p><code>bh</code> AbstractMatrix: baseline hazard estimates</p><p><strong>Signatures</strong></p></li></ul><pre><code class="language-julia hljs"> mutable struct PHModel{G&lt;:LSurvivalResp,L&lt;:AbstractLSurvivalParms} &lt;: AbstractPH
 R::G        # Survival response
 P::L        # parameters
 ties::String #&quot;efron&quot; or&quot;breslow&quot;
 fit::Bool
 bh::AbstractMatrix
 end

 PHModel(
 R::G,
 P::L,
 ties::String,
 fit::Bool,
 ) where {G&lt;:LSurvivalResp,L&lt;:AbstractLSurvivalParms}
 PHModel(R::G, P::L, ties::String) where {G&lt;:LSurvivalResp,L&lt;:AbstractLSurvivalParms}
 PHModel(R::G, P::L) where {G&lt;:LSurvivalResp,L&lt;:AbstractLSurvivalParms}</code></pre><p>Methods: fit, coef, confint, std_err, show</p><p><strong>Example</strong></p><pre><code class="language- hljs"> using LSurvival
 using Random
 import LSurvival: _stepcox!, dgm_comprisk

 z,x,t,d, event,wt = dgm_comprisk(MersenneTwister(1212), 100);
 enter = zeros(length(t));
 X = hcat(x,z);
 R = LSurvivalResp(enter, t, Int.(d), wt)
 P = PHParms(X)
 mf = PHModel(R,P)
  LSurvival._fit!(mf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/coxmodel.jl#L58-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.PHSurv" href="#LSurvival.PHSurv"><code>LSurvival.PHSurv</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Mutable type for proportional hazards models (not generally needed by users)</p><p>PHSsurv: Object type for proportional hazards regression</p><p>surv::Vector{Float64} risk::Matrix{Float64} basehaz::Vector{Float64} event::Vector{Float64}</p><ul><li><code>fitlist</code>: vector of PHSurv objects (Cox model fits)</li><li><code>eventtypes</code>: vector of unique event types</li><li><code>times</code>: unique event times</li><li><code>surv</code>: Overall survival at each time</li><li><code>risk</code>: Cause-specific risk  at each time (1 for each outcome type)</li><li><code>basehaz</code>: baseline hazard for a specific event type</li><li><code>event</code>: value of event type that occurred at each time</li></ul><p>Methods: fit, show</p><pre><code class="language-julia hljs">mutable struct PHSurv{G&lt;:Array{T} where {T&lt;:PHModel}} &lt;: AbstractNPSurv
fitlist::G        
eventtypes::AbstractVector
times::AbstractVector
surv::Vector{Float64}
risk::Matrix{Float64}
basehaz::Vector{Float64}
event::Vector{Float64}
end

PHSurv(fitlist::Array{T}, eventtypes) where {T&lt;:PHModel}
PHSurv(fitlist::Array{T}) where {T&lt;:PHModel}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/coxmodel.jl#L129-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.Strata" href="#LSurvival.Strata"><code>LSurvival.Strata</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Type for identifying individuals in survival outcomes. Used for the strata argument in PHModel (not yet implemented)</p><p>Accepts any Number or String. There is no significance to having this particular struct, but it enables easier use of multiple dispatch.</p><pre><code class="language-julia hljs">[Strata(i) for i in 1:10]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/shared_structs.jl#L15-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival._update_PHParms!-Union{Tuple{T}, Tuple{I}, Tuple{M}, Tuple{M, I, Array{Vector{T}, 1}, Array{Vector{T}, 1}}} where {M&lt;:AbstractPH, I&lt;:Int64, T&lt;:Int64}" href="#LSurvival._update_PHParms!-Union{Tuple{T}, Tuple{I}, Tuple{M}, Tuple{M, I, Array{Vector{T}, 1}, Array{Vector{T}, 1}}} where {M&lt;:AbstractPH, I&lt;:Int64, T&lt;:Int64}"><code>LSurvival._update_PHParms!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).</p><p>Uses Breslow&#39;s or Efron&#39;s partial likelihood.</p><p>Updates over all observations</p><p><strong>Signature</strong></p><pre><code class="language-julia hljs">_update_PHParms!(
 m::M,
 # big indexes
 ne::I,
 caseidxs::Vector{Vector{T}},
 risksetidxs::Vector{Vector{T}},
 ) where {M&lt;:AbstractPH,I&lt;:Int,T&lt;:Int}</code></pre><p><em>update</em>PHParms!(m, risksetidxs, caseidxs, ne, den)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/coxmodel.jl#L721-L739">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.aalen_johansen-Tuple{FormulaTerm, Any}" href="#LSurvival.aalen_johansen-Tuple{FormulaTerm, Any}"><code>LSurvival.aalen_johansen</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Aalen-Johansen estimator for cumulative cause-specific risk (in the presence of competing events)</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs"> StatsBase.fit!(m::T; kwargs...) where {T&lt;:AbstractNPSurv}

 aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,
   ; kwargs...)
</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>wts::Vector{&lt;:Real} = similar(enter, 0)</code>; vector of case weights (or zero length vector) for each observation</li><li><code>id::Vector{&lt;:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]</code>; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)</li><li><code>atol = 0.00000001</code>; absolute tolerance for defining tied event times</li><li><code>keepy = true</code>; keep the outcome vector after fitting (may save memory with large datasets)</li><li><code>eps = 0.00000001</code>; deprecated (replaced by atol)</li></ul><pre><code class="language- hljs">using LSurvival
using Random
z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
enter = zeros(length(t));
   # event variable is coded 0[referent],1,2
m = fit(AJSurv, enter, t, event)
mw = fit(AJSurv, enter, t, event, wts=wt)</code></pre><p>or, equivalently:</p><pre><code class="language-julia hljs">aalen_johansen(enter, t, event, wts=wt)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/npsurvival.jl#L220-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.bootstrap-Tuple{MersenneTwister, PHModel, Int64}" href="#LSurvival.bootstrap-Tuple{MersenneTwister, PHModel, Int64}"><code>LSurvival.bootstrap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Bootstrapping coefficients of a proportional hazards model</p><p><strong>Signatures</strong></p><pre><code class="nohighlight hljs"># single bootstrap draw, keeping the entire object
bootstrap(rng::MersenneTwister, m::PHModel)
bootstrap(m::PHModel)
# muliple bootstrap draws, keeping only coefficient estimates
bootstrap(rng::MersenneTwister, m::PHModel, iter::Int; kwargs...)
bootstrap(m::PHModel, iter::Int; kwargs...)</code></pre><p>Returns:</p><ul><li>If using <code>bootstrap(m)</code>: a single bootstrap draw</li><li>If using <code>bootstrap(m, 10)</code> (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up</li></ul><pre><code class="language-julia hljs">using LSurvival, Random

id, int, outt, data =
LSurvival.dgm(MersenneTwister(1212), 500, 5; afun = LSurvival.int_0)

d, X = data[:, 4], data[:, 1:3]
weights = rand(length(d))

# survival outcome:
R = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only
P = PHParms(X)

Mod = PHModel(R, P)
LSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)


# careful propogation of bootstrap sampling
idx, R2 = bootstrap(R)
P2 = bootstrap(idx, P)
Modb = PHModel(R2, P2)
LSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)

# convenience function for bootstrapping a model
Modc = bootstrap(Mod)
LSurvival._fit!(Modc, start=Modc.P._B);
Modc
Modc.P.X == nothing
Modc.R == nothing
</code></pre><p>Bootstrap Cox model coefficients</p><pre><code class="nohighlight hljs">LSurvival._fit!(mb, keepx=true, keepy=true, start=[0.0, 0.0])</code></pre><pre><code class="language- hljs">using LSurvival, Random
res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 200)
int = zeros(length(d)) # no late entry
X = hcat(z, x)

mainfit = fit(PHModel, X, int, outt, d .* (event .== 1), keepx=true, keepy=true)

function stddev_finite(x)
 n = length(x)
 mnx = sum(x)/n
 ret = sum((x .- mnx) .^ 2)
 ret /= n-1
 sqrt(ret)
end

# bootstrap standard error versus asymptotic
mb = bootstrap(MersenneTwister(123123), mainfit, 200)
## bootstrap standard error
[stddev_finite(mb[:,i]) for i in 1:2]
## asymptotic standard error
stderror(mainfit)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/bootstrap.jl#L67-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M&lt;:AJSurv" href="#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M&lt;:AJSurv"><code>LSurvival.bootstrap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Bootstrap methods for Aalen-Johansen cumulative risk estimator</p><p><strong>Signatures</strong></p><pre><code class="nohighlight hljs"> # single bootstrap draw, keeping the entire object
 bootstrap(rng::MersenneTwister, m::AJSurv)
 bootstrap(m::AJSurv)

 # muliple bootstrap draws, keeping only coefficient estimates
 bootstrap(rng::MersenneTwister, m::AJSurv, iter::Int; kwargs...)
 bootstrap(m::AJSurv, iter::Int; kwargs...)</code></pre><p>Returns:</p><ul><li>If using <code>bootstrap(m)</code>: a single bootstrap draw</li><li>If using <code>bootstrap(m, 10)</code> (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up</li></ul><pre><code class="language- hljs">using LSurvival
using Random

z, x, t, d, event, wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 100)
id = 1:length(x)
enter = zeros(length(t))

aj1 = aalen_johansen(enter, t, event, id=ID.(id), wts=wt)
aj2 = bootstrap(aj1, keepy=false);
ajboot = bootstrap(aj1, 10, keepy=false);
aj1


aj1.R
aj2.R
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/bootstrap.jl#L162-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M&lt;:KMSurv" href="#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M&lt;:KMSurv"><code>LSurvival.bootstrap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Bootstrap methods for Kaplan-Meier survival curve estimator</p><p><strong>Signatures</strong></p><pre><code class="nohighlight hljs"> # single bootstrap draw, keeping the entire object
 bootstrap(rng::MersenneTwister, m::KMSurv)
 bootstrap(m::KMSurv)

 # muliple bootstrap draws, keeping only coefficient estimates
 bootstrap(rng::MersenneTwister, m::KMSurv, iter::Int; kwargs...)
 bootstrap(m::KMSurv, iter::Int; kwargs...)</code></pre><p>Returns:</p><ul><li>If using <code>bootstrap(m)</code>: a single bootstrap draw</li><li>If using <code>bootstrap(m, 10)</code> (e.g.): 10 bootstrap draws of the survival probability at the end of follow up</li></ul><pre><code class="language- hljs">using LSurvival
using Random

id, int, outt, data =
LSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)

d, X = data[:, 4], data[:, 1:3]
wts = rand(length(d))

km1 = kaplan_meier(int, outt, d, id=ID.(id), wts=wts)
km2 = bootstrap(km1, keepy=false)
km3 = bootstrap(km1, 10, keepy=false)
km1

km1.R
km2.R
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/bootstrap.jl#L135-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M&lt;:PHModel" href="#LSurvival.bootstrap-Union{Tuple{M}, Tuple{MersenneTwister, M}} where M&lt;:PHModel"><code>LSurvival.bootstrap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Bootstrapping coefficients of a proportional hazards model</p><p><strong>Signatures</strong></p><pre><code class="nohighlight hljs"># single bootstrap draw, keeping the entire object
bootstrap(rng::MersenneTwister, m::PHModel)
bootstrap(m::PHModel)
# muliple bootstrap draws, keeping only coefficient estimates
bootstrap(rng::MersenneTwister, m::PHModel, iter::Int; kwargs...)
bootstrap(m::PHModel, iter::Int; kwargs...)</code></pre><p>Returns:</p><ul><li>If using <code>bootstrap(m)</code>: a single bootstrap draw</li><li>If using <code>bootstrap(m, 10)</code> (e.g.): 10 bootstrap draws of the cumulative cause-specific risks at the end of follow up</li></ul><pre><code class="language-julia hljs">using LSurvival, Random

id, int, outt, data =
LSurvival.dgm(MersenneTwister(1212), 500, 5; afun = LSurvival.int_0)

d, X = data[:, 4], data[:, 1:3]
weights = rand(length(d))

# survival outcome:
R = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only
P = PHParms(X)

Mod = PHModel(R, P)
LSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)


# careful propogation of bootstrap sampling
idx, R2 = bootstrap(R)
P2 = bootstrap(idx, P)
Modb = PHModel(R2, P2)
LSurvival._fit!(Mod, start=Mod.P._B, keepx=true, keepy=true)

# convenience function for bootstrapping a model
Modc = bootstrap(Mod)
LSurvival._fit!(Modc, start=Modc.P._B);
Modc
Modc.P.X == nothing
Modc.R == nothing
</code></pre><p>Bootstrap Cox model coefficients</p><pre><code class="nohighlight hljs">LSurvival._fit!(mb, keepx=true, keepy=true, start=[0.0, 0.0])</code></pre><pre><code class="language- hljs">using LSurvival, Random
res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 200)
int = zeros(length(d)) # no late entry
X = hcat(z, x)

mainfit = fit(PHModel, X, int, outt, d .* (event .== 1), keepx=true, keepy=true)

function stddev_finite(x)
 n = length(x)
 mnx = sum(x)/n
 ret = sum((x .- mnx) .^ 2)
 ret /= n-1
 sqrt(ret)
end

# bootstrap standard error versus asymptotic
mb = bootstrap(MersenneTwister(123123), mainfit, 200)
## bootstrap standard error
[stddev_finite(mb[:,i]) for i in 1:2]
## asymptotic standard error
stderror(mainfit)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/bootstrap.jl#L48-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.bootstrap-Union{Tuple{S}, Tuple{Vector{Int64}, S}} where S&lt;:PSParms" href="#LSurvival.bootstrap-Union{Tuple{S}, Tuple{Vector{Int64}, S}} where S&lt;:PSParms"><code>LSurvival.bootstrap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Bootstrap sampling of a proportional hazards predictor object</p><pre><code class="nohighlight hljs">using LSurvival, Random

id, int, outt, data =
LSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)

d, X = data[:, 4], data[:, 1:3]
weights = rand(length(d))

# survival outcome:
R = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only
P = PHParms(X)
idx, R2 = bootstrap(R)
P2 = bootstrap(idx, P)

Mod = PHModel(R2, P2)
LSurvival._fit!(Mod, start=Mod.P._B)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/bootstrap.jl#L34-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T&lt;:LSurvivalCompResp" href="#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T&lt;:LSurvivalCompResp"><code>LSurvival.bootstrap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Bootstrapping sampling of a competing risk survival response</p><p><strong>Signatures</strong></p><pre><code class="nohighlight hljs">bootstrap(rng::MersenneTwister, R::T) where {T&lt;:LSurvivalCompResp}
bootstrap(R::T) where {T&lt;:LSurvivalCompResp}</code></pre><pre><code class="nohighlight hljs">z,x,t,d,event,weights =
LSurvival.dgm_comprisk(MersenneTwister(1212), 300)
enter = zeros(length(event))

# survival outcome:
R = LSurvivalCompResp(enter, t, event, weights, ID.(collect(1:length(t))))    # specification with ID only
bootstrap(R) # note that entire observations/clusters identified by id are kept</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/bootstrap.jl#L18-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T&lt;:LSurvivalResp" href="#LSurvival.bootstrap-Union{Tuple{T}, Tuple{MersenneTwister, T}} where T&lt;:LSurvivalResp"><code>LSurvival.bootstrap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Bootstrapping sampling of a survival response</p><pre><code class="nohighlight hljs">id, int, outt, data =
LSurvival.dgm(MersenneTwister(1212), 20, 5; afun = LSurvival.int_0)

d, X = data[:, 4], data[:, 1:3]
weights = rand(length(d))

# survival outcome:
R = LSurvivalResp(int, outt, d, ID.(id))    # specification with ID only</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/bootstrap.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.calcp-Tuple{Any}" href="#LSurvival.calcp-Tuple{Any}"><code>LSurvival.calcp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Two-tailed p-value for a (null) standard normal distribution     depends on SpecialFunctions     https://en.wikipedia.org/wiki/Normal_distribution</p><pre><code class="language-julia hljs">    calcp(z) = 1.0 - SpecialFunctions.erf(abs(z) / sqrt(2))

    calcp(1.96)</code></pre><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L61-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.cdfchisq-Tuple{Any, Any}" href="#LSurvival.cdfchisq-Tuple{Any, Any}"><code>LSurvival.cdfchisq</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>quantile function for a chi-squared distribution     depends on SpecialFunctions     https://en.wikipedia.org/wiki/Chi-squared_distribution</p><p>Source code, example:</p><pre><code class="language-julia hljs">    cdfchisq(df, x) = SpecialFunctions.gamma_inc(df / 2, x / 2, 0)[1]

    cdfchisq(3, 3.45)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L44-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.cdfnorm-Tuple{Any}" href="#LSurvival.cdfnorm-Tuple{Any}"><code>LSurvival.cdfnorm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>quantile function for a standard normal distribution     depends on SpecialFunctions     https://en.wikipedia.org/wiki/Normal_distribution</p><p>Source code, example:</p><pre><code class="language-julia hljs">    cdfnorm(z) = 0.5 * (1 + SpecialFunctions.erf(z / sqrt(2)))
    
    cdfnorm(1.96)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L27-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.coxph-Tuple{Any, Any, Any, Any, Vararg{Any}}" href="#LSurvival.coxph-Tuple{Any, Any, Any, Any, Vararg{Any}}"><code>LSurvival.coxph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Fit method for AbstractPH objects (Cox models)</p><p>Keyword arguments (used here, and passed on to internal structs)</p><ul><li><p><code>ties</code> &quot;breslow&quot; or &quot;efron&quot; (default)</p></li><li><p><code>wts</code> observation weights</p></li><li><p><code>ties</code> &quot;breslow&quot; or &quot;efron&quot; (default)</p></li><li><p><code>offset</code> not currently used at all</p></li><li><p><code>fitargs</code> arguments passed to other structs, which include</p><ul><li><code>id</code> cluster or individual level ID (defaults to a unique value for each row of data) see note below on ID</li><li><code>contrasts</code> StatsModel style contrasts (dicts) that can be used for variable transformations/indicator variable creation (e.g. https://juliastats.org/StatsModels.jl/stable/contrasts/)</li></ul></li><li><p>Arguments passed onto fitting routine:</p><ul><li><code>eps</code> (default: Float64 = 1e-9) tolerance for declaring convergence. Model is determined to be converged when relative change in log-partial likelihood is &lt; <code>eps</code> .</li><li><code>getbasehaz</code> (default: true): estimate baseline hazard</li><li><code>start</code> (default: nothing) nothing, or vector of floats corresponding to initial values for parameters. Note that this defaults to a vector of zeros when set to nothing, and setting to other values invalidates some of the test statistics reported by default with <code>coxph.</code></li><li><code>keepx</code> (default: true) logical. Keep design matrix in AbstractPH object output (set to false for slight computational gain).</li><li><code>keepy</code> (default: true)logical.  Keep outcome in AbstractPH object output (set to false for slight computational gain).</li><li><code>bootstrap_sample</code> (default: false) Fit the model to a bootstrap sample of the data (not generally used by end-users, but provides some convenience toward bootstrap variance estimation).</li><li><code>bootstrap_rng</code> (default: Random.MersenneTwister()) Random number seed used when drawing a bootstrap sample of the data (not generally used by end-users, but provides some convenience toward bootstrap variance estimation).</li></ul><p><strong>Signatures</strong></p></li></ul><pre><code class="language-julia hljs">  fit(::Type{M},
  X::AbstractMatrix,#{&lt;:FP},
  enter::AbstractVector{&lt;:Real},
  exit::AbstractVector{&lt;:Real},
  y::Union{AbstractVector{&lt;:Real},BitVector}
  ;
  ties =&quot;breslow&quot;,
  wts::AbstractVector{&lt;:Real}      = similar(y, 0),
  offset::AbstractVector{&lt;:Real}   = similar(y, 0),
  fitargs...) where {M&lt;:AbstractPH}</code></pre><pre><code class="nohighlight hljs"> coxph(f::FormulaTerm, data; kwargs...)</code></pre><pre><code class="nohighlight hljs">  coxph(X, enter, exit, y, args...; kwargs...)</code></pre><pre><code class="language-julia hljs">   using LSurvival, Random
   z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
   enter = zeros(length(t));
   X = hcat(x,rand(length(x)));
    m = fit(PHModel, X, enter, t, d, ties=&quot;efron&quot;)
   m2 = fit(PHModel, X, enter, t, d, ties=&quot;breslow&quot;)
   coeftable(m)</code></pre><p><strong>Note on use of <code>id</code> keyword</strong></p><p><code>id</code> is not needed in person-period structure data for standard estimates or confidence intervals</p><pre><code class="language- hljs">  using Random, LSurvival
     id, int, outt, dat =
         LSurvival.dgm(MersenneTwister(123123), 100, 100; afun = LSurvival.int_0)
     data = (
             int = int,
             outt = outt,
             d = dat[:,4] .== 1,
             x = dat[:,1],
             z = dat[:,2]
     )

     f = @formula(Surv(int, outt,d)~x+z)
     coxph(f, data)</code></pre><p><strong>BUT, you must specify <code>id</code> to get appropriate robust variance and some other statistics.</strong></p><p>Here is an example where the same data are presented in two different ways, which should yield identical statistics when used in Cox model.</p><pre><code class="language- hljs"> dat1 = (
    time = [1,1,6,6,8,9],
    status = [1,0,1,1,0,1],
    x = [1,1,1,0,0,0]
  )
  ft = coxph(@formula(Surv(time,status)~x),dat1)
  bic(ft)
  nobs(ft)
  dof_residual(ft)
  # lrtest is another one

  stderror(ft)                     # model based
  stderror(ft, type=&quot;robust&quot;)   # robust standard error, based on dfbeta residuals
  ft

  # now using &quot;clustered&quot; data with multiple observations per individual
 dat1clust= (
     id = [1,2,3,3,4,4,5,5,6,6],
     enter = [0,0,0,1,0,1,0,1,0,1],
     exit = [1,1,1,6,1,6,1,8,1,9],
     status = [1,0,0,1,0,1,0,0,0,1],
     x = [1,1,1,1,0,0,0,0,0,0]
 )
 
 # use the `id` parameter with the ID struct
 ft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id))
 bic(ft2)                       # CORRECT        
 nobs(ft2)                      # CORRECT
 dof_residual(ft2)              # CORRECT
  
 stderror(ft2)                  # model based (CORRECT)
 stderror(ft2, type=&quot;robust&quot;)   # robust standard error, based on `id` level dfbeta residuals (CORRECT)
 # once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics
 ft2   # CORRECT (compare to `ft` object)</code></pre><p><strong>NOTE THE FOLLOWING IS INCORRECT because the <code>id</code> keyword is omitted</strong></p><pre><code class="language- hljs"> ft2w = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust)
 bic(ft2w)                          # INCORRECT 
 nobs(ft2w)                         # INCORRECT
 dof_residual(ft2w)                 # INCORRECT

 stderror(ft2w)                     # model based (CORRECT)
 stderror(ft2w, type=&quot;robust&quot;)      # robust variance (INCORRECT)
 
 ft2w # the coefficient table now shows incorrect confidence intervals and test statistics
  </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/coxmodel.jl#L365-L492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.ddloglik!-Union{Tuple{D}, Tuple{Any, D, Vararg{Any, 6}}} where D&lt;:AbstractSurvDist" href="#LSurvival.ddloglik!-Union{Tuple{D}, Tuple{Any, D, Vararg{Any, 6}}} where D&lt;:AbstractSurvDist"><code>LSurvival.ddloglik!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian contribution for an observation in a parametric survival model</p><pre><code class="language-julia hljs">    d = m.d
    i = 1
    enter = m.R.enter[i]
    exit = m.R.exit[i]
    y = m.R.y[i]
    wts = m.R.wts[i]
    x = m.P.X[i,:]
    θ=[1,0,.4]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/parsurvival.jl#L147-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.dgm-Tuple{MersenneTwister, Int64, Int64}" href="#LSurvival.dgm-Tuple{MersenneTwister, Int64, Int64}"><code>LSurvival.dgm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generating discrete survival data without competing risks</p><p><strong>Signatures</strong></p><pre><code class="nohighlight hljs">dgm(rng::MersenneTwister, n::Int, maxT:Int; afun = int_0, yfun = yprob, lfun = lprob)

dgm(n::Int, maxT::Int; kwargs...)</code></pre><p>Usage: dgm(rng, n, maxT;afun=int<em>0, yfun=yprob, lfun=lprob) dgm(n, maxT;afun=int</em>0, yfun=yprob, lfun=lprob)</p><p>Where afun, yfun, and lfun are all functions that take arguments v,l,a and output time-specific values of a, y, and l respectively Example:</p><pre><code class="language-julia hljs">
expit(mu) =  inv(1.0+exp(-mu))

function aprob(v,l,a)
expit(-1.0 + 3*v + 2*l)
end
  
function lprob(v,l,a)
expit(-3 + 2*v + 0*l + 0*a)
end
  
function yprob(v,l,a)
expit(-3 + 2*v + 0*l + 2*a)
end
  # 10 individuals followed for up to 5 times
LSurvival.dgm(10, 5;afun=aprob, yfun=yprob, lfun=lprob)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/data_generators.jl#L20-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.dgm_comprisk-Tuple{MersenneTwister, Int64}" href="#LSurvival.dgm_comprisk-Tuple{MersenneTwister, Int64}"><code>LSurvival.dgm_comprisk</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generating continuous survival data with competing risks</p><p><strong>Signatures</strong></p><pre><code class="nohighlight hljs">dgm_comprisk(rng::MersenneTwister, n::Int)

dgm_comprisk(n::Int)</code></pre><pre><code class="nohighlight hljs">    - rng = random number generator    
    - n = sample size</code></pre><p>Example:</p><pre><code class="language-julia hljs">using LSurvival
# 100 individuals with two competing events
z,x,t,d,event,weights = LSurvival.dgm_comprisk(100)
    
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/data_generators.jl#L49-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.dgm_phmodel-Tuple{MersenneTwister, Int64}" href="#LSurvival.dgm_phmodel-Tuple{MersenneTwister, Int64}"><code>LSurvival.dgm_phmodel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Proportional hazards model from a Weibull distribution with scale parameter λ</p><pre><code class="nohighlight hljs">dgm_phmodel(rng::MersenneTwister, n::Int; 
    λ=1.25,
    β=[0.0, 0.0]
    )</code></pre><p>keyword parameters:</p><ul><li>λ: Weibull scale parameter</li><li>β: vector of regression coefficients</li></ul><pre><code class="nohighlight hljs">rng = MersenneTwister()
X, t, d, _ = dgm_phmodel(2000; λ=1.25,β=[1.0, -0.5])
coxph(@formula(Surv(t0,t,d)~x+z), (t=t,t0=t.*0,d=d,x=X[:,1],z=X[:,2]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/data_generators.jl#L81-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.dloglik!-Union{Tuple{D}, Tuple{Any, D, Vararg{Any, 6}}} where D&lt;:AbstractSurvDist" href="#LSurvival.dloglik!-Union{Tuple{D}, Tuple{Any, D, Vararg{Any, 6}}} where D&lt;:AbstractSurvDist"><code>LSurvival.dloglik!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Gradient contribution for an observation in a parametric survival model</p><pre><code class="language-julia hljs">    d = m.d
    i = 1
    enter = m.R.enter[i]
    exit = m.R.exit[i]
    y = m.R.y[i]
    wts = m.R.wts[i]
    x = m.P.X[i,:]
    θ=[1,0,.4]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/parsurvival.jl#L122-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.dlpdf_gengamma-NTuple{4, Any}" href="#LSurvival.dlpdf_gengamma-NTuple{4, Any}"><code>LSurvival.dlpdf_gengamma</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>α=0.1 ρ =-1.2 κ=1.9 t = 2.0</p><p>exp((log(t) - α)<em>exp(-ρ) - ρ) - exp(κ - ρ) (α - log(t))</em>exp(κ - ρ) + (log(t) - α)<em>exp((log(t) - α)</em>exp(-ρ) - ρ) - 1 (log(t) - α)<em>exp(κ - ρ) - exp(κ)</em>SpecialFunctions.digamma(exp(κ))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1224-L1233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.dlsurv_gengamma-NTuple{4, Any}" href="#LSurvival.dlsurv_gengamma-NTuple{4, Any}"><code>LSurvival.dlsurv_gengamma</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>α=0.1 ρ =-1.2 κ=1.9 t = 2.0 dlsurv_gengamma(α, ρ, κ, t; fd = 1e-14)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1244-L1250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.jackknife-Tuple{M} where M&lt;:AJSurv" href="#LSurvival.jackknife-Tuple{M} where M&lt;:AJSurv"><code>LSurvival.jackknife</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Obtain jackknife (leave-one-out) estimates from a Aalen-Johansen risk curve (risk at end of follow-up) by refitting the model n times</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs">jackknife(m::M;kwargs...) where {M&lt;:AJSurv}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/jackknife.jl#L224-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.jackknife-Tuple{M} where M&lt;:KMSurv" href="#LSurvival.jackknife-Tuple{M} where M&lt;:KMSurv"><code>LSurvival.jackknife</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Obtain jackknife (leave-one-out) estimates from a Kaplan-Meier survival curve (survival at end of follow-up) by refitting the model n times</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs">jackknife(m::M;kwargs...) where {M&lt;:KMSurv}</code></pre><pre><code class="language- hljs">using LSurvival, Random, StatsBase

dat1 = (time = [1, 1, 6, 6, 8, 9], status = [1, 0, 1, 1, 0, 1], x = [1, 1, 1, 0, 0, 0])

dat1clust = (
  id = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6],
  enter = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1],
  exit = [1, 1, 1, 6, 1, 6, 1, 8, 1, 9],
  status = [1, 0, 0, 1, 0, 1, 0, 0, 0, 1],
  x = [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
)

m = kaplan_meier(dat1.time, dat1.status)
a = aalen_johansen(dat1.time, dat1.status)
mc = kaplan_meier(dat1clust.enter, dat1clust.exit, dat1clust.status, id=ID.(dat1clust.id))
ac = aalen_johansen(dat1clust.enter, dat1clust.exit, dat1clust.status, id=ID.(dat1clust.id))
jk = jackknife(m);
jkc = jackknife(mc);
jka = jackknife(a);
bs = bootstrap(mc, 100);
std(bs[:,1])
stderror(m, type=&quot;jackknife&quot;)
stderror(mc, type=&quot;jackknife&quot;)
@assert jk == jkc</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/jackknife.jl#L172-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.jackknife-Tuple{M} where M&lt;:PHModel" href="#LSurvival.jackknife-Tuple{M} where M&lt;:PHModel"><code>LSurvival.jackknife</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Obtain jackknife (leave-one-out) estimates from a Cox model by refitting the model n times</p><pre><code class="language- hljs">using LSurvival, Random, StatsBase
id, int, outt, data =
LSurvival.dgm(MersenneTwister(112), 100, 10; afun = LSurvival.int_0)
data[:, 1] = round.(data[:, 1], digits = 3)
d, X = data[:, 4], data[:, 1:3]
wt = rand(length(d))
wt ./= (sum(wt) / length(wt))
m = coxph(X,int, outt,d, wts=wt, id=ID.(id))

jk = jackknife(m);
bs = bootstrap(MersenneTwister(12321), m, 1000);
N = nobs(m)
#comparing estimate with jackknife estimate with bootstrap mean
hcat(coef(m), mean(jk, dims=1)[1,:], mean(bs, dims=1)[1,:])
semb = stderror(m)
sebs = std(bs, dims=1)
sero = stderror(m, type=&quot;robust&quot;)
sejk = stderror(m, type=&quot;jackknife&quot;)
sejk_manual = std(jk, dims=1, corrected=false) .* sqrt(N-1)

sqrt.(diag(LSurvival.jackknife_vcov(m)))

hcat(semb, sebs[1,:], sejk, sejk_manual[1,:], sero)

dat1 = (time = [1, 1, 6, 6, 8, 9], status = [1, 0, 1, 1, 0, 1], x = [1, 1, 1, 0, 0, 0])
dat1clust = (
  id = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6],
  enter = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1],
  exit = [1, 1, 1, 6, 1, 6, 1, 8, 1, 9],
  status = [1, 0, 0, 1, 0, 1, 0, 0, 0, 1],
  x = [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
)

m = coxph(@formula(Surv(time, status)~x),dat1)
mc = coxph(@formula(Surv(enter, exit, status)~x),dat1clust, id=ID.(dat1clust.id))
jk = jackknife(m);
jkc = jackknife(mc);
bs = bootstrap(mc, 100);
std(bs[:,1])
stderror(m, type=&quot;jackknife&quot;)
stderror(mc, type=&quot;jackknife&quot;)
@assert jk == jkc</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/jackknife.jl#L101-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.kaplan_meier-Tuple{FormulaTerm, Any}" href="#LSurvival.kaplan_meier-Tuple{FormulaTerm, Any}"><code>LSurvival.kaplan_meier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Kaplan-Meier estimator for cumulative conditional risk</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs">StatsBase.fit!(m::T; kwargs...) where {T&lt;:AbstractNPSurv}

kaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,
   ; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li>wts::Vector{&lt;:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation</li><li>id::Vector{&lt;:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)</li><li>atol = 0.00000001; absolute tolerance for defining tied event times</li><li>censval = 0;  value of the outcome to be considered a censored event</li><li>keepy = true; keep the outcome vector after fitting (may save memory with large datasets)</li><li>eps = 0.00000001; deprecated (replaced by atol)</li></ul><pre><code class="language- hljs">using LSurvival
using Random
z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
enter = zeros(length(t));
m = fit(KMSurv, enter, t, d)
mw = fit(KMSurv, enter, t, d, wts=wt)</code></pre><p>or, equivalently:</p><pre><code class="language-julia hljs">kaplan_meier(enter, t, d, wts=wt)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/npsurvival.jl#L165-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lgh!-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:PSModel" href="#LSurvival.lgh!-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:PSModel"><code>LSurvival.lgh!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>dat1 = (time = [1, 1, 6, 6, 8, 9], status = [1, 0, 1, 1, 0, 1], x = [1, 1, 1, 0, 0, 0]) enter = zeros(length(dat1.time)) t = dat1.time d = dat1.status X = hcat(ones(length(dat1.x)), dat1.x) wt = ones(length(t))</p><p>dist = Exponential() P = PSParms(X[:,1:1], extraparms=length(dist)-1) P = PSParms(X, extraparms=length(dist)-1) P.<em>B P.</em>grad R = LSurvivalResp(dat1.time, dat1.status)    # specification with ID only m = PSModel(R,P,dist)</p><p>λ=1 θ = rand(2) lgh!(m, θ) θ .+= inv(-m.P.<em>hess) * m.P.</em>grad * λ</p><p>lgh!(m, θ .+ [-.00, 0, 0]) lgh!(m, θ .+ [-.01, 0.05, 0.05])</p><p>m.P._LL</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/parsurvival.jl#L211-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lgh_breslow!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M&lt;:AbstractPH" href="#LSurvival.lgh_breslow!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M&lt;:AbstractPH"><code>LSurvival.lgh_breslow!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).</p><p>Uses Breslow&#39;s partial likelihood.</p><p>Updates over all observations</p><p><strong>Signature</strong></p><pre><code class="language-julia hljs">lgh_breslow!(m::M, j, caseidx, risksetidx) where {M&lt;:AbstractPH}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/coxmodel.jl#L615-L628">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lgh_efron!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M&lt;:AbstractPH" href="#LSurvival.lgh_efron!-Union{Tuple{M}, Tuple{M, Any, Any, Any}} where M&lt;:AbstractPH"><code>LSurvival.lgh_efron!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Update the partial likelihood, gradient and Hessian values from a Cox model fit (used during fitting, not generally useful for users).</p><p>Uses Efron&#39;s partial likelihood.</p><p>Updates over all observations</p><p><strong>Signature</strong></p><pre><code class="language-julia hljs">lgh_efron!(m::M, j, caseidx, risksetidx) where {M&lt;:AbstractPH}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/coxmodel.jl#L656-L668">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.loglik-Union{Tuple{D}, Tuple{D, Vararg{Any, 6}}} where D&lt;:AbstractSurvDist" href="#LSurvival.loglik-Union{Tuple{D}, Tuple{D, Vararg{Any, 6}}} where D&lt;:AbstractSurvDist"><code>LSurvival.loglik</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Log likelihood contribution for an observation in a parametric survival model</p><pre><code class="language-julia hljs">    d = m.d
    i = 1
    enter = m.R.enter[i]
    exit = m.R.exit[i]
    y = m.R.y[i]
    wts = m.R.wts[i]
    x = m.P.X[i,:]
    θ=[1,0,.4]
    
    m.P._B
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/parsurvival.jl#L95-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf-Tuple{LSurvival.Exponential, Any, Any, Any}" href="#LSurvival.lpdf-Tuple{LSurvival.Exponential, Any, Any, Any}"><code>LSurvival.lpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Log-likelihood calculation for Exponential regression: PDF</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Exponential()
lpdf_gradient(d, θ, t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L603-L615">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf-Tuple{LSurvival.Exponential, Any}" href="#LSurvival.lpdf-Tuple{LSurvival.Exponential, Any}"><code>LSurvival.lpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Log probability distribution function: Exponential distribution</p><pre><code class="language-julia hljs">    β = [-2, 1.2]
    x = [2,.1]
    ρ = -0.5
    t = 3.0
    α = dot(β,x)
    d = Exponential()
    lpdf(d, t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L563-L576">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf-Tuple{LSurvival.GGamma, Any, Any, Any}" href="#LSurvival.lpdf-Tuple{LSurvival.GGamma, Any, Any, Any}"><code>LSurvival.lpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log probability distribution for generalized gamma regression</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1132-L1135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf-Tuple{LSurvival.GGamma, Any}" href="#LSurvival.lpdf-Tuple{LSurvival.GGamma, Any}"><code>LSurvival.lpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log probability distribution function, generalized gamma distribution</p><p>Location scale representation (Klein Moeschberger ch 12)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1111-L1116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf-Tuple{LSurvival.Gamma, Any, Any, Any}" href="#LSurvival.lpdf-Tuple{LSurvival.Gamma, Any, Any, Any}"><code>LSurvival.lpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log probability distribution for Gamma regression</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1355-L1358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf-Tuple{LSurvival.Gamma, Any}" href="#LSurvival.lpdf-Tuple{LSurvival.Gamma, Any}"><code>LSurvival.lpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log probability distribution function, Gamma distribution</p><p>Location scale representation (Klein Moeschberger ch 12)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1335-L1340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf-Tuple{LSurvival.Lognormal, Any, Any, Any}" href="#LSurvival.lpdf-Tuple{LSurvival.Lognormal, Any, Any, Any}"><code>LSurvival.lpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Log likelihood calculation for Lognormal regression: PDF</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Lognormal()
lpdf(d, vcat(θ,ρ), t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L798-L810">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf-Tuple{LSurvival.Lognormal, Any}" href="#LSurvival.lpdf-Tuple{LSurvival.Lognormal, Any}"><code>LSurvival.lpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log probability distribution function: Weibull distribution</p><p>Location scale representation (Klein Moeschberger ch 12)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L777-L782">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf-Tuple{LSurvival.Weibull, Any, Any, Any}" href="#LSurvival.lpdf-Tuple{LSurvival.Weibull, Any, Any, Any}"><code>LSurvival.lpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Log-likelihood calculation for weibull regression: PDF</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Weibull()
lpdf(d, vcat(θ,ρ), t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L227-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf-Tuple{LSurvival.Weibull, Any}" href="#LSurvival.lpdf-Tuple{LSurvival.Weibull, Any}"><code>LSurvival.lpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Log probability distribution function: Weibull distribution</p><p><strong>location scale representation (Klein Moeschberger ch 12)</strong></p><pre><code class="language-julia hljs">α=0.1   # location
ρ=-1.2  # log(scale)
time=2
lpdf(Weibull(α, ρ), time)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L192-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf_gradient-Tuple{LSurvival.Exponential, Any, Any, Any}" href="#LSurvival.lpdf_gradient-Tuple{LSurvival.Exponential, Any, Any, Any}"><code>LSurvival.lpdf_gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Gradient calculation for Exponential regression: PDF</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Exponential()
lpdf_gradient(d, θ, t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L637-L649">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf_gradient-Tuple{LSurvival.GGamma, Any, Any, Any}" href="#LSurvival.lpdf_gradient-Tuple{LSurvival.GGamma, Any, Any, Any}"><code>LSurvival.lpdf_gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log probability distribution gradient for generalized gamma regression     analytic gradient</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1147-L1150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf_gradient-Tuple{LSurvival.Gamma, Any, Any, Any}" href="#LSurvival.lpdf_gradient-Tuple{LSurvival.Gamma, Any, Any, Any}"><code>LSurvival.lpdf_gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log probability distribution gradient for Gamma regression     analytic gradient</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1370-L1373">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf_gradient-Tuple{LSurvival.Lognormal, Any, Any, Any}" href="#LSurvival.lpdf_gradient-Tuple{LSurvival.Lognormal, Any, Any, Any}"><code>LSurvival.lpdf_gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Gradient calculation for Lognormal regression: PDF</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Lognormal()
lpdf_gradient(d, vcat(θ,ρ), t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L832-L844">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf_gradient-Tuple{LSurvival.Weibull, Any, Any, Any}" href="#LSurvival.lpdf_gradient-Tuple{LSurvival.Weibull, Any, Any, Any}"><code>LSurvival.lpdf_gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Gradient calculation for weibull regression: PDF</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
#α = dot(β,x)
d = Weibull()
lpdf_gradient(d, vcat(θ,ρ), t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L261-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf_hessian-Tuple{LSurvival.Exponential, Any, Any, Any}" href="#LSurvival.lpdf_hessian-Tuple{LSurvival.Exponential, Any, Any, Any}"><code>LSurvival.lpdf_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for Exponential regression: PDF</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Exponential()
lpdf_hessian(d, θ, t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L672-L684">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf_hessian-Tuple{LSurvival.Exponential, Any}" href="#LSurvival.lpdf_hessian-Tuple{LSurvival.Exponential, Any}"><code>LSurvival.lpdf_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for Weibull distribution: PDF</p><pre><code class="nohighlight hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Exponential(α)
lpdf_hessian(d, t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L706-L718">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf_hessian-Tuple{LSurvival.GGamma, Any, Any, Any}" href="#LSurvival.lpdf_hessian-Tuple{LSurvival.GGamma, Any, Any, Any}"><code>LSurvival.lpdf_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for generalized gamma regression: PDF</p><pre><code class="nohighlight hljs">placeholder function: returns nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1164-L1168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf_hessian-Tuple{LSurvival.GGamma, Any}" href="#LSurvival.lpdf_hessian-Tuple{LSurvival.GGamma, Any}"><code>LSurvival.lpdf_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for generalized gamma distribution: PDF</p><p>placeholder function: returns nothing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1182-L1186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf_hessian-Tuple{LSurvival.Gamma, Any, Any, Any}" href="#LSurvival.lpdf_hessian-Tuple{LSurvival.Gamma, Any, Any, Any}"><code>LSurvival.lpdf_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for Gamma regression: PDF</p><pre><code class="nohighlight hljs">placeholder function: returns nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1387-L1391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf_hessian-Tuple{LSurvival.Gamma, Any}" href="#LSurvival.lpdf_hessian-Tuple{LSurvival.Gamma, Any}"><code>LSurvival.lpdf_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for Gamma distribution: PDF</p><p>placeholder function: returns nothing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1405-L1409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf_hessian-Tuple{LSurvival.Lognormal, Any, Any, Any}" href="#LSurvival.lpdf_hessian-Tuple{LSurvival.Lognormal, Any, Any, Any}"><code>LSurvival.lpdf_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for Log-normal regression: PDF</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Lognormal()
lpdf_hessian(d, vcat(θ,ρ), t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L867-L879">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf_hessian-Tuple{LSurvival.Lognormal, Any}" href="#LSurvival.lpdf_hessian-Tuple{LSurvival.Lognormal, Any}"><code>LSurvival.lpdf_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for Log-normal distribution: PDF</p><pre><code class="nohighlight hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Lognormal(α, ρ)
lpdf_hessian(d, t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L901-L913">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf_hessian-Tuple{LSurvival.Weibull, Any, Any, Any}" href="#LSurvival.lpdf_hessian-Tuple{LSurvival.Weibull, Any, Any, Any}"><code>LSurvival.lpdf_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for weibull regression: PDF</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Weibull()
lpdf_hessian(d, vcat(θ,ρ), t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L296-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lpdf_weibull-Tuple{Any, Any, Any}" href="#LSurvival.lpdf_weibull-Tuple{Any, Any, Any}"><code>LSurvival.lpdf_weibull</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>α = -1.2 ρ = 1.8 t = 4.3 z = (log(t) - α) * exp(-ρ) z - exp(z) - ρ - log(t)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L384-L391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv-Tuple{LSurvival.Exponential, Any, Any, Any}" href="#LSurvival.lsurv-Tuple{LSurvival.Exponential, Any, Any, Any}"><code>LSurvival.lsurv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Log-likelihood calculation for Exponential regression: Survival</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Exponential()
lsurv(d, θ, t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L620-L632">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv-Tuple{LSurvival.Exponential, Any}" href="#LSurvival.lsurv-Tuple{LSurvival.Exponential, Any}"><code>LSurvival.lsurv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Log survival function: Exponential distribution</p><pre><code class="language-julia hljs">    β = [-2, 1.2]
    x = [2,.1]
    ρ = -0.5
    t = 3.0
    α = dot(β,x)
    d = Exponential()
    lsurv(d, t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L584-L597">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv-Tuple{LSurvival.GGamma, Any, Any, Any}" href="#LSurvival.lsurv-Tuple{LSurvival.GGamma, Any, Any, Any}"><code>LSurvival.lsurv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log survival distribution for generalized gamma regression</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1140-L1142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv-Tuple{LSurvival.GGamma, Any}" href="#LSurvival.lsurv-Tuple{LSurvival.GGamma, Any}"><code>LSurvival.lsurv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log probability distribution function, generalized gamma distribution</p><p>Location scale representation (Klein Moeschberger ch 12)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1122-L1126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv-Tuple{LSurvival.Gamma, Any, Any, Any}" href="#LSurvival.lsurv-Tuple{LSurvival.Gamma, Any, Any, Any}"><code>LSurvival.lsurv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log survival distribution for Gamma regression</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1363-L1365">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv-Tuple{LSurvival.Gamma, Any}" href="#LSurvival.lsurv-Tuple{LSurvival.Gamma, Any}"><code>LSurvival.lsurv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log probability distribution function, Gamma distribution</p><p>Location scale representation (Klein Moeschberger ch 12)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1346-L1350">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv-Tuple{LSurvival.Lognormal, Any, Any, Any}" href="#LSurvival.lsurv-Tuple{LSurvival.Lognormal, Any, Any, Any}"><code>LSurvival.lsurv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Log likelihood calculation for Log-normal regression: Survival</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Lognormal()
lsurv(d, vcat(θ,ρ), t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L815-L827">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv-Tuple{LSurvival.Lognormal, Any}" href="#LSurvival.lsurv-Tuple{LSurvival.Lognormal, Any}"><code>LSurvival.lsurv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log probability distribution function: Weibull distribution</p><p>Location scale representation (Klein Moeschberger ch 12)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L788-L792">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv-Tuple{LSurvival.Weibull, Any, Any, Any}" href="#LSurvival.lsurv-Tuple{LSurvival.Weibull, Any, Any, Any}"><code>LSurvival.lsurv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Log-likelihood calculation for weibull regression: Survival</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Weibull()
lsurv(d, vcat(θ,ρ), t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L244-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv-Tuple{LSurvival.Weibull, Any}" href="#LSurvival.lsurv-Tuple{LSurvival.Weibull, Any}"><code>LSurvival.lsurv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Log survival distribution function: Weibull distribution</p><p><strong>location, log(scale) representation (Klein Moeschberger ch 12)</strong></p><pre><code class="language-julia hljs">α=0.1   # location
ρ=-1.2  # log(scale)
time=2
lsurv(Weibull(α, ρ), time)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L208-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv_gradient-Tuple{LSurvival.Exponential, Any, Any, Any}" href="#LSurvival.lsurv_gradient-Tuple{LSurvival.Exponential, Any, Any, Any}"><code>LSurvival.lsurv_gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Gradient calculation for Exponential regression: Survival</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Exponential()
lsurv_gradient(d, θ, t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L654-L666">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv_gradient-Tuple{LSurvival.GGamma, Any, Any, Any}" href="#LSurvival.lsurv_gradient-Tuple{LSurvival.GGamma, Any, Any, Any}"><code>LSurvival.lsurv_gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log survival distribution gradient for generalized gamma regression     uses finite differences</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1155-L1158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv_gradient-Tuple{LSurvival.Gamma, Any, Any, Any}" href="#LSurvival.lsurv_gradient-Tuple{LSurvival.Gamma, Any, Any, Any}"><code>LSurvival.lsurv_gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log survival distribution gradient for Gamma regression     uses finite differences</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1378-L1381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv_gradient-Tuple{LSurvival.Lognormal, Any, Any, Any}" href="#LSurvival.lsurv_gradient-Tuple{LSurvival.Lognormal, Any, Any, Any}"><code>LSurvival.lsurv_gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Gradient calculation for Log-normal regression: Survival</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Lognormal()
lsurv_gradient(d, vcat(θ,ρ), t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L849-L861">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv_gradient-Tuple{LSurvival.Weibull, Any, Any, Any}" href="#LSurvival.lsurv_gradient-Tuple{LSurvival.Weibull, Any, Any, Any}"><code>LSurvival.lsurv_gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Gradient calculation for weibull regression: Survival</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Weibull()
lsurv_gradient(d, vcat(θ,ρ), t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L278-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv_hessian-Tuple{LSurvival.Exponential, Any, Any, Any}" href="#LSurvival.lsurv_hessian-Tuple{LSurvival.Exponential, Any, Any, Any}"><code>LSurvival.lsurv_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for Exponential regression: Survival</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Exponential()
lsurv_hessian(d, θ, t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L689-L701">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv_hessian-Tuple{LSurvival.Exponential, Any}" href="#LSurvival.lsurv_hessian-Tuple{LSurvival.Exponential, Any}"><code>LSurvival.lsurv_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for Exponential distribution: Survival</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Exponential(α)
lsurv_hessian(d, t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L723-L735">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv_hessian-Tuple{LSurvival.GGamma, Any, Any, Any}" href="#LSurvival.lsurv_hessian-Tuple{LSurvival.GGamma, Any, Any, Any}"><code>LSurvival.lsurv_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for generalized gamma regression: Survival</p><pre><code class="nohighlight hljs">placeholder function: returns nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1173-L1177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv_hessian-Tuple{LSurvival.GGamma, Any}" href="#LSurvival.lsurv_hessian-Tuple{LSurvival.GGamma, Any}"><code>LSurvival.lsurv_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for generalized gamma distribution: Survival</p><pre><code class="nohighlight hljs">placeholder function: returns nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1191-L1195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv_hessian-Tuple{LSurvival.Gamma, Any, Any, Any}" href="#LSurvival.lsurv_hessian-Tuple{LSurvival.Gamma, Any, Any, Any}"><code>LSurvival.lsurv_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for Gamma regression: Survival</p><pre><code class="nohighlight hljs">placeholder function: returns nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1396-L1400">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv_hessian-Tuple{LSurvival.Gamma, Any}" href="#LSurvival.lsurv_hessian-Tuple{LSurvival.Gamma, Any}"><code>LSurvival.lsurv_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for Gamma distribution: Survival</p><pre><code class="nohighlight hljs">placeholder function: returns nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L1414-L1418">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv_hessian-Tuple{LSurvival.Lognormal, Any, Any, Any}" href="#LSurvival.lsurv_hessian-Tuple{LSurvival.Lognormal, Any, Any, Any}"><code>LSurvival.lsurv_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for Log-normal regression: Survival</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Lognormal()
lsurv_hessian(d, vcat(θ,ρ), t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L884-L896">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv_hessian-Tuple{LSurvival.Lognormal, Any}" href="#LSurvival.lsurv_hessian-Tuple{LSurvival.Lognormal, Any}"><code>LSurvival.lsurv_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for Log-normal distribution: Survival</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Lognormal(α, ρ)
lsurv_hessian(d, t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L918-L930">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv_hessian-Tuple{LSurvival.Weibull, Any, Any, Any}" href="#LSurvival.lsurv_hessian-Tuple{LSurvival.Weibull, Any, Any, Any}"><code>LSurvival.lsurv_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for weibull regression: Survival</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Weibull()
lsurv_hessian(d, vcat(θ,ρ), t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L313-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.lsurv_hessian-Tuple{LSurvival.Weibull, Any}" href="#LSurvival.lsurv_hessian-Tuple{LSurvival.Weibull, Any}"><code>LSurvival.lsurv_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Hessian calculation for Weibull distribution: Survival</p><pre><code class="language-julia hljs">β = [-2, 1.2]
x = [2,.1]
ρ = -0.5
t = 3.0
α = dot(β,x)
d = Weibull(α, ρ)
lsurv_hessian(d, t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L350-L362">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.qstdnorm-Tuple{Any}" href="#LSurvival.qstdnorm-Tuple{Any}"><code>LSurvival.qstdnorm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>quantile function for a standard normal distribution     depends on SpecialFunctions     https://en.wikipedia.org/wiki/Normal_distribution</p><pre><code class="nohighlight hljs">Source code, example:</code></pre><pre><code class="language-julia hljs">    qstdnorm(p) = sqrt(2) * SpecialFunctions.erfinv(2.0 * p - 1.0)
    
    qstdnorm(.975)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L10-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.qweibull-Tuple{Any, Any, Any}" href="#LSurvival.qweibull-Tuple{Any, Any, Any}"><code>LSurvival.qweibull</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Quantile function for the Weibull distribution</p><p class="math-container">\[F(t) = egin{cases}
     1 - e^{{-t/ρ}^{α}}&amp;, t ≥ 0\
     0&amp;, t &lt; 0
nd{cases}
Q(p) = ρ * (log(1/(1-p))^{1/α})\]</p><p>lightweight function used for simulation</p><p>Note that there is no checking that parameters α,ρ are positively bound, and p ∈ (0,1), and errors will be given if this is not the case</p><p>Signature:</p><pre><code class="language-julia hljs">qweibull(p::Real,α::Real,ρ::Real)</code></pre><p>Source code, example:</p><pre><code class="language-julia hljs">qweibull(p, α, ρ) = ρ * ((-log1p(-p))^(1 / α))

# cross reference the approach in the Distributions package
quantile(Distributions.Weibull(.75, 1.1), .3)
LSurvival.qweibull(0.3, .75, 1.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L76-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.randweibull-Tuple{Any, Any, Any}" href="#LSurvival.randweibull-Tuple{Any, Any, Any}"><code>LSurvival.randweibull</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Random draw from Weibull distribution</p><p>lightweight function used for simulation</p><p>Note that there is no checking that parameters α,ρ are positively bound, and errors will be given if this is not the case</p><p>Signatures:</p><pre><code class="language-julia hljs">randweibull(rng::MersenneTwister,α::Real,ρ::Real)
randweibull(α::Real,ρ::Real)</code></pre><p>Source code, example:</p><pre><code class="language-julia hljs">randweibull(rng, α, ρ) = qweibull(rand(rng), α, ρ)
randweibull(α, ρ) = randweibull(MersenneTwister(), α, ρ)

# cross reference the approach in the Distributions package
rand(Distributions.Weibull(.75, 1.1))
randweibull(.75, 1.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/distributions.jl#L110-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.risk_from_coxphmodels-Union{Tuple{T}, Tuple{Vector{T}, Vararg{Any}}} where T&lt;:PHModel" href="#LSurvival.risk_from_coxphmodels-Union{Tuple{T}, Tuple{Vector{T}, Vararg{Any}}} where T&lt;:PHModel"><code>LSurvival.risk_from_coxphmodels</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Survival curve estimation using multiple cox models</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs">  risk_from_coxphmodels(fitlist::Vector{T}, args...; kwargs...) where {T&lt;:PHModel}

  fit(::Type{M}, fitlist::Vector{T}, ; fitargs...) where {M&lt;:PHSurv,T&lt;:PHModel}</code></pre><p><strong>Optional keywords</strong></p><ul><li><code>coef_vectors</code> = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]</li><li><code>pred_profile</code> = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]</li></ul><pre><code class="language- hljs"> using LSurvival
 using Random
 # event variable is coded 0[referent],1,2
 z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
 enter = zeros(length(t));

 ft1 = coxph(hcat(x,z), enter, t, (event .== 1))
 nidx = findall(event .!= 1)
 ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))

 # risk at referent levels of `x` and `z`
 risk_from_coxphmodels([ft1,ft2])

 # risk at average levels of `x` and `z`
 mnx = sum(x)/length(x)
 mnz = sum(z)/length(z)
 # equivalent
 fit(PHSurv, [ft1,ft2], pred_profile=[mnx,mnz])
 risk_from_coxphmodels([ft1,ft2], pred_profile=[mnx,mnz])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/coxmodel.jl#L872-L909">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LSurvival.survivaldata-Tuple" href="#LSurvival.survivaldata-Tuple"><code>LSurvival.survivaldata</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Loading example survival analysis datasets</p><pre><code class="language-julia hljs">using LSurvival, Plots # note Plots does not install by default
heartdata, heartmeta = survivaldata(&quot;heart&quot;)
ft = coxph(@formula(Surv(start, stop, event)~surgery), heartdata);
# plot baseline cumulative hazard
basehazplot(ft)
# plot Schoenfeld residuals
coxdx(ft)  </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/example_data.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, AJSurv}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, AJSurv}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Recipe for aalen-johansen risk curve</p><pre><code class="language-julia hljs">    using Plots, LSurvival
    res = z, x, outt, d, event, weights = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)
    int = zeros(length(d)) # no late entry
    
        c = fit(AJSurv, int, outt, event)
        #risk2 = aalen_johansen(int, outt, event)
        plot(c)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/plot_recipes.jl#L96-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, KMSurv}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, KMSurv}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Plotting a kaplan meier curve</p><pre><code class="language-julia hljs">    using Plots, LSurvival
dat4 = (
    id = [1, 1, 2, 2, 2, 3, 4, 5, 5, 6],
    enter = [1, 2, 5, 4, 6, 7, 3, 6, 8, 0],
    exit = [2, 5, 6, 7, 8, 9, 6, 8, 14, 9],
    status = [0, 1, 0, 0, 1, 0, 1, 0, 0, 1],
    x = [0.1, 0.1, 1.5, 1.5, 1.5, 0, 0, 0, 0, 3],
    z = [1, 1, 0, 0, 0, 0, 0, 1, 1, 0],
    w = [0, 0, 0, 0, 0, 1, 1, 1, 1, 0],
)
R = LSurvivalResp(dat4.enter, dat4.exit, dat4.status)
    k = kaplan_meier(dat4.enter, dat4.exit, dat4.status)
    plot(k)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/plot_recipes.jl#L55-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.AFTdist}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.AFTdist}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function name(::Type{T}) where {T}
    #https://stackoverflow.com/questions/70043313/get-simple-name-of-type-in-julia
    isempty(T.parameters) ? T : T.name.wrapper
end

using Plots, LSurvival
dat2 = (
    enter = [1, 2, 5, 2, 1, 7, 3, 4, 8, 8],
    exit = [2, 3, 6, 7, 8, 9, 9, 9, 14, 17],
    status = [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
    x = [1, 0, 0, 1, 0, 1, 1, 1, 0, 0],
)
fte = survreg(@formula(Surv(enter, exit, status)~x), dat2)

# density function
aftdist(fte, label=&quot;X=0&quot;)
aftdist!(fte, covlevels=[1.0, 2.0], color=&quot;red&quot;, label=&quot;X=1&quot;)

# Survival function
aftdist(fte, type=&quot;surv&quot;, label=&quot;X=0&quot;)
aftdist!(fte, type=&quot;surv&quot;, covlevels=[1.0, 2.0], color=&quot;red&quot;, label=&quot;X=1&quot;)

# hazard function
aftdist(fte, type=&quot;haz&quot;, label=&quot;X=0&quot;)
aftdist!(fte, type=&quot;haz&quot;, covlevels=[1.0, 2.0], color=&quot;red&quot;, label=&quot;X=1&quot;)

# Cumulative incidence/risk function
aftdist(fte, type=&quot;risk&quot;, label=&quot;X=0&quot;)
aftdist!(fte, type=&quot;risk&quot;, covlevels=[1.0, 2.0], color=&quot;red&quot;, label=&quot;X=1&quot;)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/plot_recipes.jl#L362-L395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.BaseHazPlot}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.BaseHazPlot}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Plotting baseline hazard for a Cox model</p><pre><code class="language-julia hljs">using Plots, LSurvival
dat2 = (
    enter = [1, 2, 5, 2, 1, 7, 3, 4, 8, 8],
    exit = [2, 3, 6, 7, 8, 9, 9, 9, 14, 17],
    status = [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
    x = [1, 0, 0, 1, 0, 1, 1, 1, 0, 0],
)
fte = coxph(@formula(Surv(enter, exit, status)~x), dat2, maxiter=0)
ftb = coxph(@formula(Surv(enter, exit, status)~x), dat2, ties=&quot;breslow&quot;, maxiter=0)

plot(fte, label=&quot;Efron&quot;)
plot!(ftb, label=&quot;Breslow&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/plot_recipes.jl#L229-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.CoxDX}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.CoxDX}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">
using Plots, LSurvival
dat2 = (
    enter = [1, 2, 5, 2, 1, 7, 3, 4, 8, 8],
    exit = [2, 3, 6, 7, 8, 9, 9, 9, 14, 17],
    status = [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
    x = [1, 0, 0, 1, 0, 1, 1, 1, 0, 0],
)
fte = coxph(@formula(Surv(enter, exit, status)~x), dat2)

coxdx(fte)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/plot_recipes.jl#L272-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.CoxInfluence}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.CoxInfluence}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">using Plots, LSurvival
dat2 = (
    enter = [1, 2, 5, 2, 1, 7, 3, 4, 8, 8],
    exit = [2, 3, 6, 7, 8, 9, 9, 9, 14, 17],
    status = [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
    x = [1, 0, 0, 1, 0, 1, 1, 1, 0, 0],
)
fte = coxph(@formula(Surv(enter, exit, status)~x), dat2)

coxinfluence(fte, type=&quot;jackknife&quot;, par=1)
coxinfluence!(fte, type=&quot;dfbeta&quot;, color=:red, par=1)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/plot_recipes.jl#L308-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.LognLogPlot}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvival.LognLogPlot}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Plotting baseline hazard for a Cox model</p><pre><code class="language-julia hljs">using Plots, LSurvival
dat4 = (
    id = [1, 1, 2, 2, 2, 3, 4, 5, 5, 6],
    enter = [1, 2, 5, 4, 6, 7, 3, 6, 8, 0],
    exit = [2, 5, 6, 7, 8, 9, 6, 8, 14, 9],
    status = [0, 1, 0, 0, 1, 0, 1, 0, 0, 1],
    x = [0.1, 0.1, 1.5, 1.5, 1.5, 0, 0, 0, 0, 3],
    z = [1, 1, 0, 0, 0, 0, 0, 1, 1, 0],
    w = [0, 0, 0, 0, 0, 1, 1, 1, 1, 0],
)

k = kaplan_meier(dat4.enter, dat4.exit, dat4.status)

lognlogplot(k)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/plot_recipes.jl#L172-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvivalResp}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, LSurvivalResp}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Plotting <code>LSurvivalResp</code> objects (outcomes in cox models, kaplan meier curves, parametric survival models)</p><p>Recipe for plotting time-to-event outcomes</p><pre><code class="language-julia hljs">using Plots, LSurvival

dat4 = (
    id = [1, 1, 2, 2, 2, 3, 4, 5, 5, 6],
    enter = [1, 2, 5, 4, 6, 7, 3, 6, 8, 0],
    exit = [2, 5, 6, 7, 8, 9, 6, 8, 14, 9],
    status = [0, 1, 0, 0, 1, 0, 1, 0, 0, 1],
    x = [0.1, 0.1, 1.5, 1.5, 1.5, 0, 0, 0, 0, 3],
    z = [1, 1, 0, 0, 0, 0, 0, 1, 1, 0],
    w = [0, 0, 0, 0, 0, 1, 1, 1, 1, 0],
)
R = LSurvivalResp(dat4.enter, dat4.exit, dat4.status)
plot([[R.enter[i], R.exit[i]] for i in eachindex(R.enter)], [[i, i] for i in values(R.id)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/plot_recipes.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, PHSurv}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, PHSurv}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Recipe for cox-model based risk curves</p><pre><code class="language-julia hljs">    using Plots, LSurvival, Random, StatsBase
    res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)
    X = hcat(z, x)
    int = zeros(length(d)) # no late entry
    ft1 = fit(PHModel, X, int, outt, d .* (event .== 1), wts=wts)
    ft2 = fit(PHModel, X, int, outt, d .* (event .== 2), wts=wts)
    c = risk_from_coxphmodels([ft1, ft2], pred_profile = mean(X, dims=1))
    
    plot(c)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/plot_recipes.jl#L133-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.confint-Tuple{AJSurv}" href="#StatsAPI.confint-Tuple{AJSurv}"><code>StatsAPI.confint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Greenwood&#39;s formula for variance and confidence intervals of a Aalen-Johansen risk function</p><p><strong>Signatures:</strong></p><pre><code class="language-julia hljs">StatsBase.stderror(m::AJSurv)

StatsBase.confint(m:AJSurv; level=0.95, method=&quot;normal&quot;)</code></pre><p><strong>Keyword arguments</strong></p><ul><li>method<ul><li>&quot;normal&quot; normality-based confidence intervals</li><li>&quot;lognlog&quot; log(-log(S(t))) based confidence intervals</li></ul></li></ul><pre><code class="language- hljs">res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)
int = zeros(length(d)) # no late entry
m = fit(AJSurv, int, outt, event)
stderror(m)
confint(m, level=0.95)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/npsurvival.jl#L336-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.confint-Tuple{KMSurv}" href="#StatsAPI.confint-Tuple{KMSurv}"><code>StatsAPI.confint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Greenwood&#39;s formula for variance and confidence intervals of a Kaplan-Meier survival curve</p><p><strong>Signatures:</strong></p><pre><code class="language-julia hljs">StatsBase.stderror(m::KMSurv)

StatsBase.confint(m:KMSurv; level=0.95, method=&quot;normal&quot;)</code></pre><p><strong>Keyword arguments</strong></p><p><code>method</code>:</p><ul><li>&quot;normal&quot; normality-based confidence intervals</li><li>&quot;lognlog&quot; log(-log(S(t))) based confidence intervals</li></ul><pre><code class="language- hljs">using LSurvival
using Random
z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
enter = zeros(length(t));
m = fit(KMSurv, enter, t, d)
mw = fit(KMSurv, enter, t, d, wts=wt)
stderror(m)
confint(m, method=&quot;normal&quot;)
confint(m, method=&quot;lognlog&quot;) # log-log transformation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/npsurvival.jl#L328-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.confint-Tuple{M} where M&lt;:AbstractPH" href="#StatsAPI.confint-Tuple{M} where M&lt;:AbstractPH"><code>StatsAPI.confint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">using LSurvival
 dat1= (
   time = [1,1,6,6,8,9],
   status = [1,0,1,1,0,1],
   x = [1,1,1,0,0,0]
 )

 ft = coxph(@formula(Surv(time, status) ~ x),dat1, keepx=true)
 # model-based variance
 confint(ft)

 # robust variance
 confint(ft, type=&quot;robust&quot;)</code></pre><p><strong>for cluster confidence intervals</strong></p><pre><code class="language-julia hljs"> dat1clust= (
   id = [1,2,3,3,4,4,5,5,6,6],
   enter = [0,0,0,1,0,1,0,1,0,1],
   exit = [1,1,1,6,1,6,1,8,1,9],
   status = [1,0,0,1,0,1,0,0,0,1],
   x = [1,1,1,1,0,0,0,0,0,0]
 )

 ft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id), keepx=true)
 # model-based variance
 confint(ft2)

 # robust variance
 confint(ft2, type=&quot;robust&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/coxmodel.jl#L423-L460">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.fit!-Tuple{T} where T&lt;:AbstractNPSurv" href="#StatsAPI.fit!-Tuple{T} where T&lt;:AbstractNPSurv"><code>StatsAPI.fit!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Kaplan-Meier estimator for cumulative conditional risk</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs">StatsBase.fit!(m::T; kwargs...) where {T&lt;:AbstractNPSurv}

kaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,
   ; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li>wts::Vector{&lt;:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation</li><li>id::Vector{&lt;:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)</li><li>atol = 0.00000001; absolute tolerance for defining tied event times</li><li>censval = 0;  value of the outcome to be considered a censored event</li><li>keepy = true; keep the outcome vector after fitting (may save memory with large datasets)</li><li>eps = 0.00000001; deprecated (replaced by atol)</li></ul><pre><code class="language- hljs">using LSurvival
using Random
z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
enter = zeros(length(t));
m = fit(KMSurv, enter, t, d)
mw = fit(KMSurv, enter, t, d, wts=wt)</code></pre><p>or, equivalently:</p><pre><code class="language-julia hljs">kaplan_meier(enter, t, d, wts=wt)</code></pre><p>Aalen-Johansen estimator for cumulative cause-specific risk (in the presence of competing events)</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs"> StatsBase.fit!(m::T; kwargs...) where {T&lt;:AbstractNPSurv}

 aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,
   ; kwargs...)
</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>wts::Vector{&lt;:Real} = similar(enter, 0)</code>; vector of case weights (or zero length vector) for each observation</li><li><code>id::Vector{&lt;:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]</code>; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)</li><li><code>atol = 0.00000001</code>; absolute tolerance for defining tied event times</li><li><code>keepy = true</code>; keep the outcome vector after fitting (may save memory with large datasets)</li><li><code>eps = 0.00000001</code>; deprecated (replaced by atol)</li></ul><pre><code class="language- hljs">using LSurvival
using Random
z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
enter = zeros(length(t));
   # event variable is coded 0[referent],1,2
m = fit(AJSurv, enter, t, event)
mw = fit(AJSurv, enter, t, event, wts=wt)</code></pre><p>or, equivalently:</p><pre><code class="language-julia hljs">aalen_johansen(enter, t, event, wts=wt)</code></pre><p>Survival curve estimation using multiple cox models</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs">  risk_from_coxphmodels(fitlist::Vector{T}, args...; kwargs...) where {T&lt;:PHModel}

  fit(::Type{M}, fitlist::Vector{T}, ; fitargs...) where {M&lt;:PHSurv,T&lt;:PHModel}</code></pre><p><strong>Optional keywords</strong></p><ul><li><code>coef_vectors</code> = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]</li><li><code>pred_profile</code> = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]</li></ul><pre><code class="language- hljs"> using LSurvival
 using Random
 # event variable is coded 0[referent],1,2
 z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
 enter = zeros(length(t));

 ft1 = coxph(hcat(x,z), enter, t, (event .== 1))
 nidx = findall(event .!= 1)
 ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))

 # risk at referent levels of `x` and `z`
 risk_from_coxphmodels([ft1,ft2])

 # risk at average levels of `x` and `z`
 mnx = sum(x)/length(x)
 mnz = sum(z)/length(z)
 # equivalent
 fit(PHSurv, [ft1,ft2], pred_profile=[mnx,mnz])
 risk_from_coxphmodels([ft1,ft2], pred_profile=[mnx,mnz])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/npsurvival.jl#L109-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.fit-Union{Tuple{T}, Tuple{M}, Tuple{Type{M}, Vector{T}}} where {M&lt;:PHSurv, T&lt;:PHModel}" href="#StatsAPI.fit-Union{Tuple{T}, Tuple{M}, Tuple{Type{M}, Vector{T}}} where {M&lt;:PHSurv, T&lt;:PHModel}"><code>StatsAPI.fit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Survival curve estimation using multiple cox models</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs">  risk_from_coxphmodels(fitlist::Vector{T}, args...; kwargs...) where {T&lt;:PHModel}

  fit(::Type{M}, fitlist::Vector{T}, ; fitargs...) where {M&lt;:PHSurv,T&lt;:PHModel}</code></pre><p><strong>Optional keywords</strong></p><ul><li><code>coef_vectors</code> = nothing(default) or vector of coefficient vectors from the cox models [will default to the coefficients from fitlist models]</li><li><code>pred_profile</code> = nothing(default) or vector of specific predictor values of the same length as the coef_vectors[1]</li></ul><pre><code class="language- hljs"> using LSurvival
 using Random
 # event variable is coded 0[referent],1,2
 z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
 enter = zeros(length(t));

 ft1 = coxph(hcat(x,z), enter, t, (event .== 1))
 nidx = findall(event .!= 1)
 ft2 = coxph(hcat(x,z)[nidx,:], enter[nidx], t[nidx], (event[nidx] .== 2))

 # risk at referent levels of `x` and `z`
 risk_from_coxphmodels([ft1,ft2])

 # risk at average levels of `x` and `z`
 mnx = sum(x)/length(x)
 mnz = sum(z)/length(z)
 # equivalent
 fit(PHSurv, [ft1,ft2], pred_profile=[mnx,mnz])
 risk_from_coxphmodels([ft1,ft2], pred_profile=[mnx,mnz])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/coxmodel.jl#L847-L884">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Matrix{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:AbstractPH, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}" href="#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Matrix{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:AbstractPH, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}"><code>StatsAPI.fit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Fit method for AbstractPH objects (Cox models)</p><p>Keyword arguments (used here, and passed on to internal structs)</p><ul><li><p><code>ties</code> &quot;breslow&quot; or &quot;efron&quot; (default)</p></li><li><p><code>wts</code> observation weights</p></li><li><p><code>ties</code> &quot;breslow&quot; or &quot;efron&quot; (default)</p></li><li><p><code>offset</code> not currently used at all</p></li><li><p><code>fitargs</code> arguments passed to other structs, which include</p><ul><li><code>id</code> cluster or individual level ID (defaults to a unique value for each row of data) see note below on ID</li><li><code>contrasts</code> StatsModel style contrasts (dicts) that can be used for variable transformations/indicator variable creation (e.g. https://juliastats.org/StatsModels.jl/stable/contrasts/)</li></ul></li><li><p>Arguments passed onto fitting routine:</p><ul><li><code>eps</code> (default: Float64 = 1e-9) tolerance for declaring convergence. Model is determined to be converged when relative change in log-partial likelihood is &lt; <code>eps</code> .</li><li><code>getbasehaz</code> (default: true): estimate baseline hazard</li><li><code>start</code> (default: nothing) nothing, or vector of floats corresponding to initial values for parameters. Note that this defaults to a vector of zeros when set to nothing, and setting to other values invalidates some of the test statistics reported by default with <code>coxph.</code></li><li><code>keepx</code> (default: true) logical. Keep design matrix in AbstractPH object output (set to false for slight computational gain).</li><li><code>keepy</code> (default: true)logical.  Keep outcome in AbstractPH object output (set to false for slight computational gain).</li><li><code>bootstrap_sample</code> (default: false) Fit the model to a bootstrap sample of the data (not generally used by end-users, but provides some convenience toward bootstrap variance estimation).</li><li><code>bootstrap_rng</code> (default: Random.MersenneTwister()) Random number seed used when drawing a bootstrap sample of the data (not generally used by end-users, but provides some convenience toward bootstrap variance estimation).</li></ul><p><strong>Signatures</strong></p></li></ul><pre><code class="language-julia hljs">  fit(::Type{M},
  X::AbstractMatrix,#{&lt;:FP},
  enter::AbstractVector{&lt;:Real},
  exit::AbstractVector{&lt;:Real},
  y::Union{AbstractVector{&lt;:Real},BitVector}
  ;
  ties =&quot;breslow&quot;,
  wts::AbstractVector{&lt;:Real}      = similar(y, 0),
  offset::AbstractVector{&lt;:Real}   = similar(y, 0),
  fitargs...) where {M&lt;:AbstractPH}</code></pre><pre><code class="nohighlight hljs"> coxph(f::FormulaTerm, data; kwargs...)</code></pre><pre><code class="nohighlight hljs">  coxph(X, enter, exit, y, args...; kwargs...)</code></pre><pre><code class="language-julia hljs">   using LSurvival, Random
   z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
   enter = zeros(length(t));
   X = hcat(x,rand(length(x)));
    m = fit(PHModel, X, enter, t, d, ties=&quot;efron&quot;)
   m2 = fit(PHModel, X, enter, t, d, ties=&quot;breslow&quot;)
   coeftable(m)</code></pre><p><strong>Note on use of <code>id</code> keyword</strong></p><p><code>id</code> is not needed in person-period structure data for standard estimates or confidence intervals</p><pre><code class="language- hljs">  using Random, LSurvival
     id, int, outt, dat =
         LSurvival.dgm(MersenneTwister(123123), 100, 100; afun = LSurvival.int_0)
     data = (
             int = int,
             outt = outt,
             d = dat[:,4] .== 1,
             x = dat[:,1],
             z = dat[:,2]
     )

     f = @formula(Surv(int, outt,d)~x+z)
     coxph(f, data)</code></pre><p><strong>BUT, you must specify <code>id</code> to get appropriate robust variance and some other statistics.</strong></p><p>Here is an example where the same data are presented in two different ways, which should yield identical statistics when used in Cox model.</p><pre><code class="language- hljs"> dat1 = (
    time = [1,1,6,6,8,9],
    status = [1,0,1,1,0,1],
    x = [1,1,1,0,0,0]
  )
  ft = coxph(@formula(Surv(time,status)~x),dat1)
  bic(ft)
  nobs(ft)
  dof_residual(ft)
  # lrtest is another one

  stderror(ft)                     # model based
  stderror(ft, type=&quot;robust&quot;)   # robust standard error, based on dfbeta residuals
  ft

  # now using &quot;clustered&quot; data with multiple observations per individual
 dat1clust= (
     id = [1,2,3,3,4,4,5,5,6,6],
     enter = [0,0,0,1,0,1,0,1,0,1],
     exit = [1,1,1,6,1,6,1,8,1,9],
     status = [1,0,0,1,0,1,0,0,0,1],
     x = [1,1,1,1,0,0,0,0,0,0]
 )
 
 # use the `id` parameter with the ID struct
 ft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id))
 bic(ft2)                       # CORRECT        
 nobs(ft2)                      # CORRECT
 dof_residual(ft2)              # CORRECT
  
 stderror(ft2)                  # model based (CORRECT)
 stderror(ft2, type=&quot;robust&quot;)   # robust standard error, based on `id` level dfbeta residuals (CORRECT)
 # once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics
 ft2   # CORRECT (compare to `ft` object)</code></pre><p><strong>NOTE THE FOLLOWING IS INCORRECT because the <code>id</code> keyword is omitted</strong></p><pre><code class="language- hljs"> ft2w = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust)
 bic(ft2w)                          # INCORRECT 
 nobs(ft2w)                         # INCORRECT
 dof_residual(ft2w)                 # INCORRECT

 stderror(ft2w)                     # model based (CORRECT)
 stderror(ft2w, type=&quot;robust&quot;)      # robust variance (INCORRECT)
 
 ft2w # the coefficient table now shows incorrect confidence intervals and test statistics
  </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/coxmodel.jl#L292-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:AJSurv, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}" href="#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:AJSurv, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}"><code>StatsAPI.fit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Aalen-Johansen estimator for cumulative cause-specific risk (in the presence of competing events)</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs"> StatsBase.fit!(m::T; kwargs...) where {T&lt;:AbstractNPSurv}

 aalen_johansen(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,
   ; kwargs...)
</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>wts::Vector{&lt;:Real} = similar(enter, 0)</code>; vector of case weights (or zero length vector) for each observation</li><li><code>id::Vector{&lt;:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]</code>; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)</li><li><code>atol = 0.00000001</code>; absolute tolerance for defining tied event times</li><li><code>keepy = true</code>; keep the outcome vector after fitting (may save memory with large datasets)</li><li><code>eps = 0.00000001</code>; deprecated (replaced by atol)</li></ul><pre><code class="language- hljs">using LSurvival
using Random
z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
enter = zeros(length(t));
   # event variable is coded 0[referent],1,2
m = fit(AJSurv, enter, t, event)
mw = fit(AJSurv, enter, t, event, wts=wt)</code></pre><p>or, equivalently:</p><pre><code class="language-julia hljs">aalen_johansen(enter, t, event, wts=wt)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/npsurvival.jl#L174-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:KMSurv, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}" href="#StatsAPI.fit-Union{Tuple{Y}, Tuple{M}, Tuple{Type{M}, Vector{&lt;:Real}, Vector{&lt;:Real}, Y}} where {M&lt;:KMSurv, Y&lt;:Union{BitVector, Vector{&lt;:Real}}}"><code>StatsAPI.fit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Kaplan-Meier estimator for cumulative conditional risk</p><p><strong>Signatures</strong></p><pre><code class="language-julia hljs">StatsBase.fit!(m::T; kwargs...) where {T&lt;:AbstractNPSurv}

kaplan_meier(enter::AbstractVector, exit::AbstractVector, y::AbstractVector,
   ; kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li>wts::Vector{&lt;:Real} = similar(enter, 0); vector of case weights (or zero length vector) for each observation</li><li>id::Vector{&lt;:AbstractLSurvivalID} = [ID(i) for i in eachindex(y)]; Vector of AbstractSurvID objects denoting observations that form a single unit (used in bootstrap and jackknife methods)</li><li>atol = 0.00000001; absolute tolerance for defining tied event times</li><li>censval = 0;  value of the outcome to be considered a censored event</li><li>keepy = true; keep the outcome vector after fitting (may save memory with large datasets)</li><li>eps = 0.00000001; deprecated (replaced by atol)</li></ul><pre><code class="language- hljs">using LSurvival
using Random
z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
enter = zeros(length(t));
m = fit(KMSurv, enter, t, d)
mw = fit(KMSurv, enter, t, d, wts=wt)</code></pre><p>or, equivalently:</p><pre><code class="language-julia hljs">kaplan_meier(enter, t, d, wts=wt)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/npsurvival.jl#L120-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.loglikelihood-Tuple{M} where M&lt;:AbstractPH" href="#StatsAPI.loglikelihood-Tuple{M} where M&lt;:AbstractPH"><code>StatsAPI.loglikelihood</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Maximum log partial likelihood for a fitted <code>AbstractPH</code> model Efron or Breslow (depending on the <code>ties</code>` parameter)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/coxmodel.jl#L488-L491">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.loglikelihood-Tuple{M} where M&lt;:PSModel" href="#StatsAPI.loglikelihood-Tuple{M} where M&lt;:PSModel"><code>StatsAPI.loglikelihood</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Maximum log likelihood for a fitted <code>PSModel</code> model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/parsurvival.jl#L703-L705">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.nullloglikelihood-Tuple{M} where M&lt;:AbstractPH" href="#StatsAPI.nullloglikelihood-Tuple{M} where M&lt;:AbstractPH"><code>StatsAPI.nullloglikelihood</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Null log-partial likelihood for a fitted <code>AbstractPH</code> model Efron or Breslow (depending on the <code>ties</code>` parameter)</p><p>Note: this is just the log partial likelihood at the initial values of the model, which default to 0. If initial values are non-null, then this function no longer validly returns the null log-partial likelihood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/coxmodel.jl#L503-L508">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.nullloglikelihood-Tuple{M} where M&lt;:PSModel" href="#StatsAPI.nullloglikelihood-Tuple{M} where M&lt;:PSModel"><code>StatsAPI.nullloglikelihood</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Null log-partial likelihood for a fitted <code>PSModel</code> model</p><p>Note: this is just the log partial likelihood at the initial values of the model, which default to 0. If initial values are non-null, then this function no longer validly returns the null log-partial likelihood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/parsurvival.jl#L716-L720">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.residuals-Tuple{M} where M&lt;:PHModel" href="#StatsAPI.residuals-Tuple{M} where M&lt;:PHModel"><code>StatsAPI.residuals</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>####################################################################</p><p>Cox proportional hazards model residuals:</p><p>Signature</p><pre><code class="language-julia hljs">  residuals(m::M; type = &quot;martingale&quot;) where {M&lt;:PHModel}</code></pre><p>where type is one of </p><ul><li><p><code>martingale</code></p></li><li><p><code>schoenfeld</code></p></li><li><p><code>score</code></p></li><li><p><code>dfbeta</code></p></li><li><p><code>jackknife</code></p></li><li><p><code>dfbetas</code> (scaled dfbeta)</p></li><li><p><code>scaled_schoenfeld</code> or <code>schoenfelds</code>  (scaled Schoenfeld)</p><p>Residuals from the residuals function are designed to exactly emulate those from the <code>survival</code> package in R. Currently, they are validated for single observation data (e.g. one data row per individual).</p><p>####################################################################</p><p><strong>Martingale residuals: Observed versus expected</strong></p></li></ul><pre><code class="language- hljs">  # example from https://cran.r-project.org/web/packages/survival/vignettes/validate.pdf
  # by Terry Therneau

  dat1 = (
    time = [1,1,6,6,8,9],
    status = [1,0,1,1,0,1],
    x = [1,1,1,0,0,0]
  )

  # Nelson-Aalen type estimator for Breslow partial likelihood
  ft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=&quot;breslow&quot;)
  residuals(ft, type=&quot;martingale&quot;)</code></pre><pre><code class="language- hljs">  dat1 = (
    time = [1,1,6,6,8,9],
    status = [1,0,1,1,0,1],
    x = [1,1,1,0,0,0]
  )

  # Fleming-Harrington type estimator for Efron partial likelihood
  ft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=&quot;efron&quot;)
  residuals(ft, type=&quot;martingale&quot;)
</code></pre><p>####################################################################</p><p><strong>Score residuals: Per observation contribution to score function</strong></p><pre><code class="language-julia hljs">  using LSurvival
  dat1 = (
    time = [1,1,6,6,8,9],
    status = [1,0,1,1,0,1],
    x = [1,1,1,0,0,0]
  )
  ft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=&quot;breslow&quot;)
  S = residuals(ft, type=&quot;score&quot;)[:]
  ft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=&quot;efron&quot;, maxiter=0)
  S = residuals(ft, type=&quot;score&quot;)[:]</code></pre><p>####################################################################</p><p><strong>Schoenfeld residuals: Per time contribution to score function</strong></p><pre><code class="language-julia hljs">  using LSurvival
  dat1 = (
    time = [1,1,6,6,8,9],
    status = [1,0,1,1,0,1],
    x = [1,1,1,0,0,0]
  )
  ft = coxph(@formula(Surv(time,status)~x),dat1, keepx=true, keepy=true, ties=&quot;breslow&quot;, maxiter=0)


  X = ft.P.X
  M = residuals(ft, type=&quot;martingale&quot;)
  S = residuals(ft, type=&quot;schoenfeld&quot;)[:]
  Ss = residuals(ft, type=&quot;scaled_schoenfeld&quot;)[:]</code></pre><p>####################################################################</p><p><strong>dfbeta residuals: influence of individual observations on each parameter</strong></p><pre><code class="language- hljs">  using LSurvival
  dat1 = (
    time = [1,1,6,6,8,9],
    status = [1,0,1,1,0,1],
    x = [1,1,1,0,0,0]
  )

  ft = coxph(@formula(Surv(time,status)~x),dat1, ties=&quot;breslow&quot;)
  residuals(ft, type=&quot;dfbeta&quot;)

  # can also calculate from score residuals and Hessian matrix
  L = residuals(ft, type=&quot;score&quot;) # n X p
  H = ft.P._hess   # p X p
  dfbeta = L*inv(H)
  robVar = dfbeta&#39;dfbeta
  sqrt(robVar)
</code></pre><p><strong>using the <code>id</code> keyword argument</strong></p><p><strong>see help for LSurvival.vcov for what happens when <code>id</code> keyword is not used</strong></p><pre><code class="language- hljs">  dat1clust= (
    id = [1,2,3,3,4,4,5,5,6,6],
    enter = [0,0,0,1,0,1,0,1,0,1],
    exit = [1,1,1,6,1,6,1,8,1,9],
    status = [1,0,0,1,0,1,0,0,0,1],
    x = [1,1,1,1,0,0,0,0,0,0]
  )

  ft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id), ties=&quot;breslow&quot;)

  # note these are still on the observation level (not the id level)! 
  residuals(ft2, type=&quot;dfbeta&quot;)

  # getting id level dfbeta residuals
  dfbeta = residuals(ft2, type=&quot;dfbeta&quot;)
  id = values(ft2.R.id)
  D = reduce(vcat, [sum(dfbeta[findall(id .== i),:], dims=1) for i in unique(id)])
  D&#39;D
  vcov(ft, type=&quot;robust&quot;)
  vcov(ft2, type=&quot;robust&quot;)</code></pre><p>####################################################################</p><p><strong>jackknife residuals: influence of individual observations on each parameter using leave-one-out estimates</strong></p><p>note there are other definitions of jackknife residuals  See Chapter 7.1 of &quot;Extending the Cox Model&quot; by Therneau and Grambsch for an example of the type of jackknife residuals used here</p><p>Jackknife residuals <span>$r_i$</span> for <span>$i \in 1:n$</span> are given as the difference between the maximum partial likelihood estimate and the jackknife estimates for each observation</p><p class="math-container">\[r_i = \hat\beta - \hat\beta_{(-i)}\]</p><p>where <span>$\beta_{(-i)}$</span> is the maximum partial likelihood estimate of the log-hazard ratio vector obtained from a dataset in which observations belonging to individual <code>i</code> are removed</p><pre><code class="language- hljs">  using LSurvival
  dat1 = (
    time = [1,1,6,6,8,9],
    status = [1,0,1,1,0,1],
    x = [1,1,1,0,0,0]
  )

  ft = coxph(@formula(Surv(time,status)~x),dat1, ties=&quot;breslow&quot;)
  #jackknife(ft)
  residuals(ft, type=&quot;jackknife&quot;)

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/residuals.jl#L4-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.stderror-Tuple{AJSurv}" href="#StatsAPI.stderror-Tuple{AJSurv}"><code>StatsAPI.stderror</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Greenwood&#39;s formula for variance and confidence intervals of a Aalen-Johansen risk function</p><p><strong>Signatures:</strong></p><pre><code class="language-julia hljs">StatsBase.stderror(m::AJSurv)

StatsBase.confint(m:AJSurv; level=0.95, method=&quot;normal&quot;)</code></pre><p><strong>Keyword arguments</strong></p><ul><li>method<ul><li>&quot;normal&quot; normality-based confidence intervals</li><li>&quot;lognlog&quot; log(-log(S(t))) based confidence intervals</li></ul></li></ul><pre><code class="language- hljs">res = z, x, outt, d, event, wts = LSurvival.dgm_comprisk(MersenneTwister(123123), 100)
int = zeros(length(d)) # no late entry
m = fit(AJSurv, int, outt, event)
stderror(m)
confint(m, level=0.95)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/npsurvival.jl#L281-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.stderror-Tuple{KMSurv}" href="#StatsAPI.stderror-Tuple{KMSurv}"><code>StatsAPI.stderror</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Greenwood&#39;s formula for variance and confidence intervals of a Kaplan-Meier survival curve</p><p><strong>Signatures:</strong></p><pre><code class="language-julia hljs">StatsBase.stderror(m::KMSurv)

StatsBase.confint(m:KMSurv; level=0.95, method=&quot;normal&quot;)</code></pre><p><strong>Keyword arguments</strong></p><p><code>method</code>:</p><ul><li>&quot;normal&quot; normality-based confidence intervals</li><li>&quot;lognlog&quot; log(-log(S(t))) based confidence intervals</li></ul><pre><code class="language- hljs">using LSurvival
using Random
z,x,t,d, event,wt = LSurvival.dgm_comprisk(MersenneTwister(1212), 1000);
enter = zeros(length(t));
m = fit(KMSurv, enter, t, d)
mw = fit(KMSurv, enter, t, d, wts=wt)
stderror(m)
confint(m, method=&quot;normal&quot;)
confint(m, method=&quot;lognlog&quot;) # log-log transformation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/npsurvival.jl#L240-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.vcov-Tuple{M} where M&lt;:AbstractPH" href="#StatsAPI.vcov-Tuple{M} where M&lt;:AbstractPH"><code>StatsAPI.vcov</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Covariance matrix for Cox proportional hazards models  </p><p>Keyword arguments</p><ul><li><p><code>type</code> nothing or &quot;robust&quot;: determines whether model based or robust (dfbeta based) variance is returned.</p><p>See ?residuals for info on <code>dfbeta</code> residuals</p></li></ul><pre><code class="language- hljs">using LSurvival
dat1 = (
  time = [1,1,6,6,8,9],
  status = [1,0,1,1,0,1],
  x = [1,1,1,0,0,0]
)
ft = coxph(@formula(Surv(time,status)~x),dat1, id=ID.(collect(1:6)))

vcov(ft)                   # model based
vcov(ft, type=&quot;robust&quot;)    # robust variance, based on dfbeta residuals
# once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics
ft</code></pre><p><strong>cluster robust standard errors using the <code>id</code> keyword argument</strong></p><pre><code class="language- hljs">dat1clust= (
  id = [1,2,3,3,4,4,5,5,6,6],
  enter = [0,0,0,1,0,1,0,1,0,1],
  exit = [1,1,1,6,1,6,1,8,1,9],
  status = [1,0,0,1,0,1,0,0,0,1],
  x = [1,1,1,1,0,0,0,0,0,0]
)

ft2 = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust, id=ID.(dat1clust.id))

vcov(ft2)                     # model based
vcov(ft2, type=&quot;robust&quot;)       # robust variance, based on dfbeta residuals
stderror(ft2, type=&quot;robust&quot;)   # robust variance, based on dfbeta residuals
confint(ft2, type=&quot;robust&quot;)    # robust variance, based on dfbeta residuals
nobs(ft2)                     # id argument yields correct value of number of independent observations
# once robust SE is calculated, coefficient table uses the robust SE for confidence intervals and test statistics
ft2 </code></pre><p><strong>NOTE THE FOLLOWING IS INCORRECT because the <code>id</code> keyword is omitted</strong></p><pre><code class="language- hljs">ft2w = coxph(@formula(Surv(enter, exit, status) ~ x),dat1clust)

vcov(ft2w)                   # model based (CORRECT)
vcov(ft2w, type=&quot;robust&quot;)    # robust variance (INCORRECT)
nobs(ft2w)

ft2w</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexpkeil1/LSurvival.jl/blob/335162741343019368dc7ed0ade0f8d1a7e3a875/src/coxmodel.jl#L532-L588">source</a></section></article><h1 id="Implementation-details-and-further-help"><a class="docs-heading-anchor" href="#Implementation-details-and-further-help">Implementation details and further help</a><a id="Implementation-details-and-further-help-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-details-and-further-help" title="Permalink"></a></h1><ul><li><a href="Likelihood/#Likelihood-functions-for-time-to-event-observations-subject-to-left-truncation-and-right-censoring">Likelihood functions for time-to-event observations subject to left-truncation and right censoring</a></li><li class="no-marker"><ul><li><a href="Likelihood/#Introduction:">Introduction:</a></li><li><a href="Likelihood/#Definitions:">Definitions:</a></li><li><a href="Likelihood/#Likelihoods-for-survival-data-subject-to-right-censoring-and-left-truncation">Likelihoods for survival data subject to right censoring and left truncation</a></li><li class="no-marker"><ul><li><a href="Likelihood/#Special-case:-person-period-data">Special case: person-period data</a></li></ul></li><li><a href="Likelihood/#Parametric-likelihoods">Parametric likelihoods</a></li><li class="no-marker"><ul><li><a href="Likelihood/#Weibull-distribution">Weibull distribution</a></li><li><a href="Likelihood/#Exponential-distribution">Exponential distribution</a></li><li><a href="Likelihood/#Log-normal-distribution">Log-normal distribution</a></li><li><a href="Likelihood/#Generalized-Gamma-distribution">Generalized Gamma distribution</a></li><li><a href="Likelihood/#Gamma-distribution">Gamma distribution</a></li><li><a href="Likelihood/#Log-logistic-distribution">Log-logistic distribution</a></li></ul></li><li><a href="Likelihood/#Semi-parametric-partial-likelihoods">Semi-parametric partial likelihoods</a></li><li class="no-marker"><ul><li><a href="Likelihood/#Efron&#39;s-partial-likelihood">Efron&#39;s partial likelihood</a></li><li><a href="Likelihood/#Breslow&#39;s-partial-likelihood">Breslow&#39;s partial likelihood</a></li></ul></li><li><a href="Likelihood/#Time-varying-covariates">Time-varying covariates</a></li><li><a href="Likelihood/#Numerical-algorithms">Numerical algorithms</a></li><li class="no-marker"><ul><li><a href="Likelihood/#Non-parametric-analysis">Non-parametric analysis</a></li><li><a href="Likelihood/#Semi-parametric-analysis">Semi-parametric analysis</a></li><li><a href="Likelihood/#Parametric-analysis">Parametric analysis</a></li></ul></li></ul></li><li><a href="nonparametric/#Non-parametric-survival/risk-estimation:-Kaplan-Meier-and-Aalen-Johansen">Non-parametric survival/risk estimation: Kaplan-Meier and Aalen-Johansen</a></li><li class="no-marker"><ul><li><a href="nonparametric/#Kaplan-Meier-estimator-of-the-cumulative-risk/survival">Kaplan-Meier estimator of the cumulative risk/survival</a></li><li class="no-marker"><ul><li><a href="nonparametric/#Plotting-the-survival-curve">Plotting the survival curve</a></li><li><a href="nonparametric/#Checking-whether-marginal-distribution-of-the-outcome-comports-with-a-parametric-Weibull-or-Exponential-model">Checking whether marginal distribution of the outcome comports with a parametric Weibull or Exponential model</a></li></ul></li><li><a href="nonparametric/#Competing-event-analysis:-Aalen-Johansen-estimator-of-cumulative-risk">Competing event analysis: Aalen-Johansen estimator of cumulative risk</a></li><li class="no-marker"><ul><li><a href="nonparametric/#Plotting-marginal-cause-specific-risks">Plotting marginal cause-specific risks</a></li></ul></li></ul></li><li><a href="coxmodel/#Cox-models">Cox models</a></li><li class="no-marker"><ul><li><a href="coxmodel/#Plotting-survival-outcomes-(person-period-plot)">Plotting survival outcomes (person-period plot)</a></li><li><a href="coxmodel/#Estimating-baseline-hazards">Estimating baseline hazards</a></li><li><a href="coxmodel/#Model-fit:-Schoenfeld-residuals-(one-set-for-each-parameter)">Model fit: Schoenfeld residuals (one set for each parameter)</a></li><li><a href="coxmodel/#Influence:-Jackknife/dfbeta-residuals">Influence: Jackknife/dfbeta residuals</a></li><li><a href="coxmodel/#Competing-event-analysis:-Cox-model-based-estimator-of-the-cumulative-risk/survival-function">Competing event analysis: Cox-model-based estimator of the cumulative risk/survival function</a></li><li class="no-marker"><ul><li><a href="coxmodel/#Fitting-cause-specific-Cox-models-for-competing-event-types">Fitting cause-specific Cox models for competing event types</a></li><li><a href="coxmodel/#Cox-model-estimator:-cause-specific-risks-at-given-levels-of-covariates">Cox-model estimator: cause-specific risks at given levels of covariates</a></li><li><a href="coxmodel/#Cox-model-estimator:-standard-errors-and-confidence-intervals">Cox-model estimator: standard errors and confidence intervals</a></li></ul></li></ul></li><li><a href="parametric/#Parametric-survival/risk-estimation-with-Weibull-AFT-models">Parametric survival/risk estimation with Weibull AFT models</a></li><li class="no-marker"><ul><li><a href="parametric/#Weibull-accelerated-failure-time-model">Weibull accelerated failure time model</a></li><li><a href="parametric/#Comparing-Weibull-AFT-and-Cox-model-results">Comparing Weibull AFT and Cox model results</a></li><li><a href="parametric/#Visualizing-the-distributions,-probability-density">Visualizing the distributions, probability density</a></li><li><a href="parametric/#Visualizing-the-distributions,-survival-distribution">Visualizing the distributions, survival distribution</a></li><li><a href="parametric/#Visualizing-the-distributions,-hazard-function">Visualizing the distributions, hazard function</a></li><li><a href="parametric/#Visualizing-the-distributions,-risk-function">Visualizing the distributions, risk function</a></li><li><a href="parametric/#Other-distributions">Other distributions</a></li><li class="no-marker"><ul><li><a href="parametric/#Exponential">Exponential</a></li><li><a href="parametric/#Log-normal">Log-normal</a></li><li><a href="parametric/#Gamma">Gamma</a></li><li><a href="parametric/#Generalized-gamma">Generalized gamma</a></li><li><a href="parametric/#Log-logistic">Log-logistic</a></li><li><a href="parametric/#Gompertz">Gompertz</a></li></ul></li></ul></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="Likelihood/">Likelihood functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 14 July 2025 21:22">Monday 14 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
